// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.27.1
// source: v2/concordium/service.proto

package pb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	Queries_GetBlocks_FullMethodName                          = "/concordium.v2.Queries/GetBlocks"
	Queries_GetFinalizedBlocks_FullMethodName                 = "/concordium.v2.Queries/GetFinalizedBlocks"
	Queries_GetAccountInfo_FullMethodName                     = "/concordium.v2.Queries/GetAccountInfo"
	Queries_GetAccountList_FullMethodName                     = "/concordium.v2.Queries/GetAccountList"
	Queries_GetModuleList_FullMethodName                      = "/concordium.v2.Queries/GetModuleList"
	Queries_GetAncestors_FullMethodName                       = "/concordium.v2.Queries/GetAncestors"
	Queries_GetModuleSource_FullMethodName                    = "/concordium.v2.Queries/GetModuleSource"
	Queries_GetInstanceList_FullMethodName                    = "/concordium.v2.Queries/GetInstanceList"
	Queries_GetInstanceInfo_FullMethodName                    = "/concordium.v2.Queries/GetInstanceInfo"
	Queries_GetInstanceState_FullMethodName                   = "/concordium.v2.Queries/GetInstanceState"
	Queries_InstanceStateLookup_FullMethodName                = "/concordium.v2.Queries/InstanceStateLookup"
	Queries_GetNextAccountSequenceNumber_FullMethodName       = "/concordium.v2.Queries/GetNextAccountSequenceNumber"
	Queries_GetConsensusInfo_FullMethodName                   = "/concordium.v2.Queries/GetConsensusInfo"
	Queries_GetBlockItemStatus_FullMethodName                 = "/concordium.v2.Queries/GetBlockItemStatus"
	Queries_GetCryptographicParameters_FullMethodName         = "/concordium.v2.Queries/GetCryptographicParameters"
	Queries_GetBlockInfo_FullMethodName                       = "/concordium.v2.Queries/GetBlockInfo"
	Queries_GetBakerList_FullMethodName                       = "/concordium.v2.Queries/GetBakerList"
	Queries_GetPoolInfo_FullMethodName                        = "/concordium.v2.Queries/GetPoolInfo"
	Queries_GetPassiveDelegationInfo_FullMethodName           = "/concordium.v2.Queries/GetPassiveDelegationInfo"
	Queries_GetBlocksAtHeight_FullMethodName                  = "/concordium.v2.Queries/GetBlocksAtHeight"
	Queries_GetTokenomicsInfo_FullMethodName                  = "/concordium.v2.Queries/GetTokenomicsInfo"
	Queries_InvokeInstance_FullMethodName                     = "/concordium.v2.Queries/InvokeInstance"
	Queries_GetPoolDelegators_FullMethodName                  = "/concordium.v2.Queries/GetPoolDelegators"
	Queries_GetPoolDelegatorsRewardPeriod_FullMethodName      = "/concordium.v2.Queries/GetPoolDelegatorsRewardPeriod"
	Queries_GetPassiveDelegators_FullMethodName               = "/concordium.v2.Queries/GetPassiveDelegators"
	Queries_GetPassiveDelegatorsRewardPeriod_FullMethodName   = "/concordium.v2.Queries/GetPassiveDelegatorsRewardPeriod"
	Queries_GetBranches_FullMethodName                        = "/concordium.v2.Queries/GetBranches"
	Queries_GetElectionInfo_FullMethodName                    = "/concordium.v2.Queries/GetElectionInfo"
	Queries_GetIdentityProviders_FullMethodName               = "/concordium.v2.Queries/GetIdentityProviders"
	Queries_GetAnonymityRevokers_FullMethodName               = "/concordium.v2.Queries/GetAnonymityRevokers"
	Queries_GetAccountNonFinalizedTransactions_FullMethodName = "/concordium.v2.Queries/GetAccountNonFinalizedTransactions"
	Queries_GetBlockTransactionEvents_FullMethodName          = "/concordium.v2.Queries/GetBlockTransactionEvents"
	Queries_GetBlockSpecialEvents_FullMethodName              = "/concordium.v2.Queries/GetBlockSpecialEvents"
	Queries_GetBlockPendingUpdates_FullMethodName             = "/concordium.v2.Queries/GetBlockPendingUpdates"
	Queries_GetNextUpdateSequenceNumbers_FullMethodName       = "/concordium.v2.Queries/GetNextUpdateSequenceNumbers"
	Queries_GetBakerEarliestWinTime_FullMethodName            = "/concordium.v2.Queries/GetBakerEarliestWinTime"
	Queries_Shutdown_FullMethodName                           = "/concordium.v2.Queries/Shutdown"
	Queries_PeerConnect_FullMethodName                        = "/concordium.v2.Queries/PeerConnect"
	Queries_PeerDisconnect_FullMethodName                     = "/concordium.v2.Queries/PeerDisconnect"
	Queries_GetBannedPeers_FullMethodName                     = "/concordium.v2.Queries/GetBannedPeers"
	Queries_BanPeer_FullMethodName                            = "/concordium.v2.Queries/BanPeer"
	Queries_UnbanPeer_FullMethodName                          = "/concordium.v2.Queries/UnbanPeer"
	Queries_DumpStart_FullMethodName                          = "/concordium.v2.Queries/DumpStart"
	Queries_DumpStop_FullMethodName                           = "/concordium.v2.Queries/DumpStop"
	Queries_GetPeersInfo_FullMethodName                       = "/concordium.v2.Queries/GetPeersInfo"
	Queries_GetNodeInfo_FullMethodName                        = "/concordium.v2.Queries/GetNodeInfo"
	Queries_SendBlockItem_FullMethodName                      = "/concordium.v2.Queries/SendBlockItem"
	Queries_GetAccountTransactionSignHash_FullMethodName      = "/concordium.v2.Queries/GetAccountTransactionSignHash"
	Queries_GetBlockChainParameters_FullMethodName            = "/concordium.v2.Queries/GetBlockChainParameters"
	Queries_GetBlockFinalizationSummary_FullMethodName        = "/concordium.v2.Queries/GetBlockFinalizationSummary"
	Queries_GetBlockItems_FullMethodName                      = "/concordium.v2.Queries/GetBlockItems"
	Queries_GetBakersRewardPeriod_FullMethodName              = "/concordium.v2.Queries/GetBakersRewardPeriod"
	Queries_GetBlockCertificates_FullMethodName               = "/concordium.v2.Queries/GetBlockCertificates"
	Queries_GetWinningBakersEpoch_FullMethodName              = "/concordium.v2.Queries/GetWinningBakersEpoch"
	Queries_GetFirstBlockEpoch_FullMethodName                 = "/concordium.v2.Queries/GetFirstBlockEpoch"
	Queries_DryRun_FullMethodName                             = "/concordium.v2.Queries/DryRun"
)

// QueriesClient is the client API for Queries service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type QueriesClient interface {
	// Return a stream of blocks that arrive from the time the query is made onward.
	// This can be used to listen for incoming blocks.
	GetBlocks(ctx context.Context, in *Empty, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ArrivedBlockInfo], error)
	// Return a stream of blocks that are finalized from the time the query is
	// made onward. This can be used to listen for newly finalized blocks. Note
	// that there is no guarantee that blocks will not be skipped if the client is
	// too slow in processing the stream, however blocks will always be sent by
	// increasing block height.
	GetFinalizedBlocks(ctx context.Context, in *Empty, opts ...grpc.CallOption) (grpc.ServerStreamingClient[FinalizedBlockInfo], error)
	// Retrieve the information about the given account in the given block.
	GetAccountInfo(ctx context.Context, in *AccountInfoRequest, opts ...grpc.CallOption) (*AccountInfo, error)
	// Retrieve the list of accounts that exist at the end of the given block.
	GetAccountList(ctx context.Context, in *BlockHashInput, opts ...grpc.CallOption) (grpc.ServerStreamingClient[AccountAddress], error)
	// Get a list of all smart contract modules. The stream will end
	// when all modules that exist in the state at the end of the given
	// block have been returned.
	GetModuleList(ctx context.Context, in *BlockHashInput, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ModuleRef], error)
	// Get a stream of ancestors for the provided block.
	// Starting with the provided block itself, moving backwards until no more
	// ancestors or the requested number of ancestors has been returned.
	GetAncestors(ctx context.Context, in *AncestorsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[BlockHash], error)
	// Get the source of a smart contract module.
	GetModuleSource(ctx context.Context, in *ModuleSourceRequest, opts ...grpc.CallOption) (*VersionedModuleSource, error)
	// Get a list of addresses for all smart contract instances. The stream
	// will end when all instances that exist in the state at the end of the
	// given block has been returned.
	GetInstanceList(ctx context.Context, in *BlockHashInput, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ContractAddress], error)
	// Get info about a smart contract instance as it appears at the end of the
	// given block.
	GetInstanceInfo(ctx context.Context, in *InstanceInfoRequest, opts ...grpc.CallOption) (*InstanceInfo, error)
	// Get the exact state of a specific contract instance, streamed as a list of
	// key-value pairs. The list is streamed in lexicographic order of keys.
	GetInstanceState(ctx context.Context, in *InstanceInfoRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[InstanceStateKVPair], error)
	// Get the value at a specific key of a contract state. In contrast to
	// `GetInstanceState` this is more efficient, but requires the user to know
	// the specific key to look for.
	InstanceStateLookup(ctx context.Context, in *InstanceStateLookupRequest, opts ...grpc.CallOption) (*InstanceStateValueAtKey, error)
	// Get the best guess as to what the next account sequence number should be.
	// If all account transactions are finalized then this information is reliable.
	// Otherwise this is the best guess, assuming all other transactions will be
	// committed to blocks and eventually finalized.
	GetNextAccountSequenceNumber(ctx context.Context, in *AccountAddress, opts ...grpc.CallOption) (*NextAccountSequenceNumber, error)
	// Get information about the current state of consensus.
	GetConsensusInfo(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ConsensusInfo, error)
	// Get the status of and information about a specific block item (transaction).
	GetBlockItemStatus(ctx context.Context, in *TransactionHash, opts ...grpc.CallOption) (*BlockItemStatus, error)
	// Get the cryptographic parameters in a given block.
	GetCryptographicParameters(ctx context.Context, in *BlockHashInput, opts ...grpc.CallOption) (*CryptographicParameters, error)
	// Get information, such as height, timings, and transaction counts for the given block.
	GetBlockInfo(ctx context.Context, in *BlockHashInput, opts ...grpc.CallOption) (*BlockInfo, error)
	// Get all the bakers at the end of the given block.
	GetBakerList(ctx context.Context, in *BlockHashInput, opts ...grpc.CallOption) (grpc.ServerStreamingClient[BakerId], error)
	// Get information about a given pool at the end of a given block.
	GetPoolInfo(ctx context.Context, in *PoolInfoRequest, opts ...grpc.CallOption) (*PoolInfoResponse, error)
	// Get information about the passive delegators at the end of a given block.
	GetPassiveDelegationInfo(ctx context.Context, in *BlockHashInput, opts ...grpc.CallOption) (*PassiveDelegationInfo, error)
	// Get a list of live blocks at a given height.
	GetBlocksAtHeight(ctx context.Context, in *BlocksAtHeightRequest, opts ...grpc.CallOption) (*BlocksAtHeightResponse, error)
	// Get information about tokenomics at the end of a given block.
	GetTokenomicsInfo(ctx context.Context, in *BlockHashInput, opts ...grpc.CallOption) (*TokenomicsInfo, error)
	// Run the smart contract entrypoint in a given context and in the state at
	// the end of the given block.
	InvokeInstance(ctx context.Context, in *InvokeInstanceRequest, opts ...grpc.CallOption) (*InvokeInstanceResponse, error)
	// Get the registered delegators of a given pool at the end of a given block.
	// In contrast to the `GetPoolDelegatorsRewardPeriod` which returns delegators
	// that are fixed for the reward period of the block, this endpoint returns the
	// list of delegators that are registered in the block. Any changes to delegators
	// are immediately visible in this list.
	// The stream will end when all the delegators has been returned.
	GetPoolDelegators(ctx context.Context, in *GetPoolDelegatorsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[DelegatorInfo], error)
	// Get the fixed delegators of a given pool for the reward period of the given block.
	// In contracts to the `GetPoolDelegators` which returns delegators registered
	// for the given block, this endpoint returns the fixed delegators contributing
	// stake in the reward period containing the given block.
	// The stream will end when all the delegators has been returned.
	GetPoolDelegatorsRewardPeriod(ctx context.Context, in *GetPoolDelegatorsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[DelegatorRewardPeriodInfo], error)
	// Get the registered passive delegators at the end of a given block.
	// In contrast to the `GetPassiveDelegatorsRewardPeriod` which returns delegators
	// that are fixed for the reward period of the block, this endpoint returns the
	// list of delegators that are registered in the block. Any changes to delegators
	// are immediately visible in this list.
	// The stream will end when all the delegators has been returned.
	GetPassiveDelegators(ctx context.Context, in *BlockHashInput, opts ...grpc.CallOption) (grpc.ServerStreamingClient[DelegatorInfo], error)
	// Get the fixed passive delegators for the reward period of the given block.
	// In contracts to the `GetPassiveDelegators` which returns delegators registered
	// for the given block, this endpoint returns the fixed delegators contributing
	// stake in the reward period containing the given block.
	// The stream will end when all the delegators has been returned.
	GetPassiveDelegatorsRewardPeriod(ctx context.Context, in *BlockHashInput, opts ...grpc.CallOption) (grpc.ServerStreamingClient[DelegatorRewardPeriodInfo], error)
	// Get the current branches of blocks starting from and including the last finalized block.
	GetBranches(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Branch, error)
	// Get information related to the baker election for a particular block.
	GetElectionInfo(ctx context.Context, in *BlockHashInput, opts ...grpc.CallOption) (*ElectionInfo, error)
	// Get the identity providers registered as of the end of a given block.
	// The stream will end when all the identity providers have been returned.
	GetIdentityProviders(ctx context.Context, in *BlockHashInput, opts ...grpc.CallOption) (grpc.ServerStreamingClient[IpInfo], error)
	// Get the anonymity revokers registered as of the end of a given block.
	// The stream will end when all the anonymity revokers have been returned.
	GetAnonymityRevokers(ctx context.Context, in *BlockHashInput, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ArInfo], error)
	// Get a list of non-finalized transaction hashes for a given account. This
	// endpoint is not expected to return a large amount of data in most cases,
	// but in bad network condtions it might. The stream will end when all the
	// non-finalized transaction hashes have been returned.
	GetAccountNonFinalizedTransactions(ctx context.Context, in *AccountAddress, opts ...grpc.CallOption) (grpc.ServerStreamingClient[TransactionHash], error)
	// Get a list of transaction events in a given block.
	// The stream will end when all the transaction events for a given block have been returned.
	GetBlockTransactionEvents(ctx context.Context, in *BlockHashInput, opts ...grpc.CallOption) (grpc.ServerStreamingClient[BlockItemSummary], error)
	// Get a list of special events in a given block. These are events generated
	// by the protocol, such as minting and reward payouts. They are not directly
	// generated by any transaction. The stream will end when all the special
	// events for a given block have been returned.
	GetBlockSpecialEvents(ctx context.Context, in *BlockHashInput, opts ...grpc.CallOption) (grpc.ServerStreamingClient[BlockSpecialEvent], error)
	// Get the pending updates to chain parameters at the end of a given block.
	// The stream will end when all the pending updates for a given block have been returned.
	GetBlockPendingUpdates(ctx context.Context, in *BlockHashInput, opts ...grpc.CallOption) (grpc.ServerStreamingClient[PendingUpdate], error)
	// Get next available sequence numbers for updating chain parameters after a given block.
	GetNextUpdateSequenceNumbers(ctx context.Context, in *BlockHashInput, opts ...grpc.CallOption) (*NextUpdateSequenceNumbers, error)
	// Get the projected earliest time at which a particular baker will be required to bake a block.
	// If the current consensus version is 0, this returns the status 'Unavailable', as the endpoint
	// is only supported by consensus version 1.
	//
	// If the baker is not a baker for the current reward period, this returns a timestamp at the
	// start of the next reward period. If the baker is a baker for the current reward period, the
	// earliest win time is projected from the current round forward, assuming that each round after
	// the last finalized round will take the minimum block time. (If blocks take longer, or timeouts
	// occur, the actual time may be later, and the reported time in subsequent queries may reflect
	// this.) At the end of an epoch (or if the baker is not projected to bake before the end of the
	// epoch) the earliest win time for a (current) baker will be projected as the start of the next
	// epoch. This is because the seed for the leader election is updated at the epoch boundary, and
	// so the winners cannot be predicted beyond that. Note that in some circumstances the returned
	// timestamp can be in the past, especially at the end of an epoch.
	GetBakerEarliestWinTime(ctx context.Context, in *BakerId, opts ...grpc.CallOption) (*Timestamp, error)
	// Shut down the node.
	// Return a GRPC error if the shutdown failed.
	Shutdown(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error)
	// Suggest to a peer to connect to the submitted peer details.
	// This, if successful, adds the peer to the list of given addresses.
	// Otherwise return a GRPC error.
	// Note. The peer might not be connected to instantly, in that case
	// the node will try to establish the connection in near future. This
	// function returns a GRPC status 'Ok' in this case.
	PeerConnect(ctx context.Context, in *IpSocketAddress, opts ...grpc.CallOption) (*Empty, error)
	// Disconnect from the peer and remove them from the given addresses list
	// if they are on it. Return if the request was processed successfully.
	// Otherwise return a GRPC error.
	PeerDisconnect(ctx context.Context, in *IpSocketAddress, opts ...grpc.CallOption) (*Empty, error)
	// Get a list of banned peers.
	GetBannedPeers(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*BannedPeers, error)
	// Ban the given peer.
	// Returns a GRPC error if the action failed.
	BanPeer(ctx context.Context, in *PeerToBan, opts ...grpc.CallOption) (*Empty, error)
	// Unban the banned peer.
	// Returns a GRPC error if the action failed.
	UnbanPeer(ctx context.Context, in *BannedPeer, opts ...grpc.CallOption) (*Empty, error)
	// Start dumping packages into the specified file.
	// Only enabled if the node was built with the `network_dump` feature.
	// Returns a GRPC error if the network dump failed to start.
	DumpStart(ctx context.Context, in *DumpRequest, opts ...grpc.CallOption) (*Empty, error)
	// Stop dumping packages.
	// Only enabled if the node was built with the `network_dump` feature.
	// Returns a GRPC error if the network dump failed to be stopped.
	DumpStop(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error)
	// / Get a list of the peers that the node is connected to
	// / and assoicated network related information for each peer.
	GetPeersInfo(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*PeersInfo, error)
	// Get information about the node.
	// The `NodeInfo` includes information of
	//   - Meta information such as the, version of the node, type of the node, uptime and the local time of the node.
	//   - NetworkInfo which yields data such as the node id, packets sent/received,
	//     average bytes per second sent/received.
	//   - ConsensusInfo. The `ConsensusInfo` returned depends on if the node supports
	//     the protocol on chain and whether the node is configured as a baker or not.
	GetNodeInfo(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*NodeInfo, error)
	// Send a block item. A block item is either an `AccountTransaction`, which is
	// a transaction signed and paid for by an account, a `CredentialDeployment`,
	// which creates a new account, or `UpdateInstruction`, which is an
	// instruction to change some parameters of the chain. Update instructions can
	// only be sent by the governance committee.
	//
	// Returns a hash of the block item, which can be used with
	// `GetBlockItemStatus`.
	SendBlockItem(ctx context.Context, in *SendBlockItemRequest, opts ...grpc.CallOption) (*TransactionHash, error)
	// Get the hash to be signed for an account transaction. The hash returned
	// should be signed and the signatures included as an
	// AccountTransactionSignature when calling `SendBlockItem`. This is provided as
	// a convenience to support cases where the right SDK is not available for
	// interacting with the node. If an SDK is available then it is strongly
	// recommended to compute this hash off-line using it. That reduces the trust
	// in the node, removes networking failure modes, and will perform better.
	GetAccountTransactionSignHash(ctx context.Context, in *PreAccountTransaction, opts ...grpc.CallOption) (*AccountTransactionSignHash, error)
	// Get the values of chain parameters in effect in the given block.
	GetBlockChainParameters(ctx context.Context, in *BlockHashInput, opts ...grpc.CallOption) (*ChainParameters, error)
	// Get the summary of the finalization data in a given block.
	GetBlockFinalizationSummary(ctx context.Context, in *BlockHashInput, opts ...grpc.CallOption) (*BlockFinalizationSummary, error)
	// Get the items of a block.
	GetBlockItems(ctx context.Context, in *BlockHashInput, opts ...grpc.CallOption) (grpc.ServerStreamingClient[BlockItem], error)
	// Get all bakers in the reward period of a block.
	// This endpoint is only supported for protocol version 6 and onwards.
	// If the protocol does not support the endpoint then an  'IllegalArgument' error is returned.
	GetBakersRewardPeriod(ctx context.Context, in *BlockHashInput, opts ...grpc.CallOption) (grpc.ServerStreamingClient[BakerRewardPeriodInfo], error)
	// For a non-genesis block, this returns the quorum certificate, a timeout
	// certificate (if present) and epoch finalization entry (if present).
	// Note that, if the block being pointed to is not a product of ConcordiumBFT,
	// then the response will be a grpc error (invalid argument).
	// If the endpoint is not enabled by the node, then an 'unimplemented' error
	// will be returned.
	GetBlockCertificates(ctx context.Context, in *BlockHashInput, opts ...grpc.CallOption) (*BlockCertificates, error)
	// Get the list of bakers that won the lottery in a particular historical epoch (i.e. the
	// last finalized block is in a later epoch). This lists the winners for each round in the
	// epoch, starting from the round after the last block in the previous epoch, running to
	// the round before the first block in the next epoch. It also indicates if a block in each
	// round was included in the finalized chain.
	//
	// The following error cases are possible:
	//   - `NOT_FOUND` if the query specifies an unknown block.
	//   - `UNAVAILABLE` if the query is for an epoch that is not finalized in the current genesis
	//
	// /    index, or is for a future genesis index.
	//   - `INVALID_ARGUMENT` if the query is for an epoch that is not finalized for a past genesis
	//     index.
	//   - `INVALID_ARGUMENT` if the query is for a genesis index at consensus version 0.
	//   - `INVALID_ARGUMENT` if the input `EpochRequest` is malformed.
	//   - `UNIMPLEMENTED` if the endpoint is disabled on the node.
	GetWinningBakersEpoch(ctx context.Context, in *EpochRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[WinningBaker], error)
	// Get the block hash of the first finalized block in a specified epoch.
	//
	// The following error cases are possible:
	//   - `NOT_FOUND` if the query specifies an unknown block.
	//   - `UNAVAILABLE` if the query is for an epoch that is not finalized in the current genesis
	//     index, or is for a future genesis index.
	//   - `INVALID_ARGUMENT` if the query is for an epoch with no finalized blocks for a past genesis
	//     index.
	//   - `INVALID_ARGUMENT` if the input `EpochRequest` is malformed.
	//   - `UNIMPLEMENTED` if the endpoint is disabled on the node.
	GetFirstBlockEpoch(ctx context.Context, in *EpochRequest, opts ...grpc.CallOption) (*BlockHash, error)
	// Dry run a series of transactions and operations on a state derived from a specified block.
	// The server should send a single `DryRunResponse` for each `DryRunRequest` received, unless
	// the call fails with an error status code. If a request produces a `DryRunErrorResponse`, then
	// the server will still process subsequent requests, just as if the request causing the error
	// did not happen.
	//
	// The first request should be `load_block_at_state` to determine the block state that will be
	// used for the dry run.
	//
	// The server associates each request with an energy cost, and limits the total energy that may
	// be expended in a single invocation of `DryRun`. This limit is reported as `quota` in the
	// initial metadata returned by the server. If executing an operation exceeds the limit,
	// the server terminates the session with `RESOURCE_EXHAUSTED`.
	//
	// The server also imposes a timeout for a dry-run session to complete. The server reports
	// the timeout duration in milliseconds in the initial metadata field `timeout`. If the session
	// is not completed before the timeout elapses, the server terminates the session with
	// `DEADLINE_EXCEEDED`.
	//
	// The following error cases are possible:
	//   - `INVALID_ARGUMENT` if any `DryRunRequest` is malformed.
	//   - `RESOURCE_EXHAUSTED` if the energy quota is exceeded.
	//   - `DEADLINE_EXCEEDED` if the session does not complete before the server-imposed timeout.
	//   - `RESOURCE_EXHAUSTED` if the server is not currently accepting new `DryRun` sessions.
	//     (The server may impose a limit on the number of concurrent sessions.)
	//   - `INTERNAL` if an interal server error occurs. This should not happen, and likely indicates
	//     a bug.
	//   - `UNIMPLEMENTED` if the endpoint is disabled on the node.
	DryRun(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[DryRunRequest, DryRunResponse], error)
}

type queriesClient struct {
	cc grpc.ClientConnInterface
}

func NewQueriesClient(cc grpc.ClientConnInterface) QueriesClient {
	return &queriesClient{cc}
}

func (c *queriesClient) GetBlocks(ctx context.Context, in *Empty, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ArrivedBlockInfo], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Queries_ServiceDesc.Streams[0], Queries_GetBlocks_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[Empty, ArrivedBlockInfo]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Queries_GetBlocksClient = grpc.ServerStreamingClient[ArrivedBlockInfo]

func (c *queriesClient) GetFinalizedBlocks(ctx context.Context, in *Empty, opts ...grpc.CallOption) (grpc.ServerStreamingClient[FinalizedBlockInfo], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Queries_ServiceDesc.Streams[1], Queries_GetFinalizedBlocks_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[Empty, FinalizedBlockInfo]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Queries_GetFinalizedBlocksClient = grpc.ServerStreamingClient[FinalizedBlockInfo]

func (c *queriesClient) GetAccountInfo(ctx context.Context, in *AccountInfoRequest, opts ...grpc.CallOption) (*AccountInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AccountInfo)
	err := c.cc.Invoke(ctx, Queries_GetAccountInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) GetAccountList(ctx context.Context, in *BlockHashInput, opts ...grpc.CallOption) (grpc.ServerStreamingClient[AccountAddress], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Queries_ServiceDesc.Streams[2], Queries_GetAccountList_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[BlockHashInput, AccountAddress]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Queries_GetAccountListClient = grpc.ServerStreamingClient[AccountAddress]

func (c *queriesClient) GetModuleList(ctx context.Context, in *BlockHashInput, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ModuleRef], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Queries_ServiceDesc.Streams[3], Queries_GetModuleList_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[BlockHashInput, ModuleRef]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Queries_GetModuleListClient = grpc.ServerStreamingClient[ModuleRef]

func (c *queriesClient) GetAncestors(ctx context.Context, in *AncestorsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[BlockHash], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Queries_ServiceDesc.Streams[4], Queries_GetAncestors_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[AncestorsRequest, BlockHash]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Queries_GetAncestorsClient = grpc.ServerStreamingClient[BlockHash]

func (c *queriesClient) GetModuleSource(ctx context.Context, in *ModuleSourceRequest, opts ...grpc.CallOption) (*VersionedModuleSource, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VersionedModuleSource)
	err := c.cc.Invoke(ctx, Queries_GetModuleSource_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) GetInstanceList(ctx context.Context, in *BlockHashInput, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ContractAddress], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Queries_ServiceDesc.Streams[5], Queries_GetInstanceList_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[BlockHashInput, ContractAddress]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Queries_GetInstanceListClient = grpc.ServerStreamingClient[ContractAddress]

func (c *queriesClient) GetInstanceInfo(ctx context.Context, in *InstanceInfoRequest, opts ...grpc.CallOption) (*InstanceInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(InstanceInfo)
	err := c.cc.Invoke(ctx, Queries_GetInstanceInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) GetInstanceState(ctx context.Context, in *InstanceInfoRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[InstanceStateKVPair], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Queries_ServiceDesc.Streams[6], Queries_GetInstanceState_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[InstanceInfoRequest, InstanceStateKVPair]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Queries_GetInstanceStateClient = grpc.ServerStreamingClient[InstanceStateKVPair]

func (c *queriesClient) InstanceStateLookup(ctx context.Context, in *InstanceStateLookupRequest, opts ...grpc.CallOption) (*InstanceStateValueAtKey, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(InstanceStateValueAtKey)
	err := c.cc.Invoke(ctx, Queries_InstanceStateLookup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) GetNextAccountSequenceNumber(ctx context.Context, in *AccountAddress, opts ...grpc.CallOption) (*NextAccountSequenceNumber, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(NextAccountSequenceNumber)
	err := c.cc.Invoke(ctx, Queries_GetNextAccountSequenceNumber_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) GetConsensusInfo(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ConsensusInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ConsensusInfo)
	err := c.cc.Invoke(ctx, Queries_GetConsensusInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) GetBlockItemStatus(ctx context.Context, in *TransactionHash, opts ...grpc.CallOption) (*BlockItemStatus, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BlockItemStatus)
	err := c.cc.Invoke(ctx, Queries_GetBlockItemStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) GetCryptographicParameters(ctx context.Context, in *BlockHashInput, opts ...grpc.CallOption) (*CryptographicParameters, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CryptographicParameters)
	err := c.cc.Invoke(ctx, Queries_GetCryptographicParameters_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) GetBlockInfo(ctx context.Context, in *BlockHashInput, opts ...grpc.CallOption) (*BlockInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BlockInfo)
	err := c.cc.Invoke(ctx, Queries_GetBlockInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) GetBakerList(ctx context.Context, in *BlockHashInput, opts ...grpc.CallOption) (grpc.ServerStreamingClient[BakerId], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Queries_ServiceDesc.Streams[7], Queries_GetBakerList_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[BlockHashInput, BakerId]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Queries_GetBakerListClient = grpc.ServerStreamingClient[BakerId]

func (c *queriesClient) GetPoolInfo(ctx context.Context, in *PoolInfoRequest, opts ...grpc.CallOption) (*PoolInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PoolInfoResponse)
	err := c.cc.Invoke(ctx, Queries_GetPoolInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) GetPassiveDelegationInfo(ctx context.Context, in *BlockHashInput, opts ...grpc.CallOption) (*PassiveDelegationInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PassiveDelegationInfo)
	err := c.cc.Invoke(ctx, Queries_GetPassiveDelegationInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) GetBlocksAtHeight(ctx context.Context, in *BlocksAtHeightRequest, opts ...grpc.CallOption) (*BlocksAtHeightResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BlocksAtHeightResponse)
	err := c.cc.Invoke(ctx, Queries_GetBlocksAtHeight_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) GetTokenomicsInfo(ctx context.Context, in *BlockHashInput, opts ...grpc.CallOption) (*TokenomicsInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TokenomicsInfo)
	err := c.cc.Invoke(ctx, Queries_GetTokenomicsInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) InvokeInstance(ctx context.Context, in *InvokeInstanceRequest, opts ...grpc.CallOption) (*InvokeInstanceResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(InvokeInstanceResponse)
	err := c.cc.Invoke(ctx, Queries_InvokeInstance_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) GetPoolDelegators(ctx context.Context, in *GetPoolDelegatorsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[DelegatorInfo], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Queries_ServiceDesc.Streams[8], Queries_GetPoolDelegators_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[GetPoolDelegatorsRequest, DelegatorInfo]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Queries_GetPoolDelegatorsClient = grpc.ServerStreamingClient[DelegatorInfo]

func (c *queriesClient) GetPoolDelegatorsRewardPeriod(ctx context.Context, in *GetPoolDelegatorsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[DelegatorRewardPeriodInfo], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Queries_ServiceDesc.Streams[9], Queries_GetPoolDelegatorsRewardPeriod_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[GetPoolDelegatorsRequest, DelegatorRewardPeriodInfo]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Queries_GetPoolDelegatorsRewardPeriodClient = grpc.ServerStreamingClient[DelegatorRewardPeriodInfo]

func (c *queriesClient) GetPassiveDelegators(ctx context.Context, in *BlockHashInput, opts ...grpc.CallOption) (grpc.ServerStreamingClient[DelegatorInfo], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Queries_ServiceDesc.Streams[10], Queries_GetPassiveDelegators_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[BlockHashInput, DelegatorInfo]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Queries_GetPassiveDelegatorsClient = grpc.ServerStreamingClient[DelegatorInfo]

func (c *queriesClient) GetPassiveDelegatorsRewardPeriod(ctx context.Context, in *BlockHashInput, opts ...grpc.CallOption) (grpc.ServerStreamingClient[DelegatorRewardPeriodInfo], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Queries_ServiceDesc.Streams[11], Queries_GetPassiveDelegatorsRewardPeriod_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[BlockHashInput, DelegatorRewardPeriodInfo]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Queries_GetPassiveDelegatorsRewardPeriodClient = grpc.ServerStreamingClient[DelegatorRewardPeriodInfo]

func (c *queriesClient) GetBranches(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Branch, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Branch)
	err := c.cc.Invoke(ctx, Queries_GetBranches_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) GetElectionInfo(ctx context.Context, in *BlockHashInput, opts ...grpc.CallOption) (*ElectionInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ElectionInfo)
	err := c.cc.Invoke(ctx, Queries_GetElectionInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) GetIdentityProviders(ctx context.Context, in *BlockHashInput, opts ...grpc.CallOption) (grpc.ServerStreamingClient[IpInfo], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Queries_ServiceDesc.Streams[12], Queries_GetIdentityProviders_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[BlockHashInput, IpInfo]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Queries_GetIdentityProvidersClient = grpc.ServerStreamingClient[IpInfo]

func (c *queriesClient) GetAnonymityRevokers(ctx context.Context, in *BlockHashInput, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ArInfo], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Queries_ServiceDesc.Streams[13], Queries_GetAnonymityRevokers_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[BlockHashInput, ArInfo]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Queries_GetAnonymityRevokersClient = grpc.ServerStreamingClient[ArInfo]

func (c *queriesClient) GetAccountNonFinalizedTransactions(ctx context.Context, in *AccountAddress, opts ...grpc.CallOption) (grpc.ServerStreamingClient[TransactionHash], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Queries_ServiceDesc.Streams[14], Queries_GetAccountNonFinalizedTransactions_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[AccountAddress, TransactionHash]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Queries_GetAccountNonFinalizedTransactionsClient = grpc.ServerStreamingClient[TransactionHash]

func (c *queriesClient) GetBlockTransactionEvents(ctx context.Context, in *BlockHashInput, opts ...grpc.CallOption) (grpc.ServerStreamingClient[BlockItemSummary], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Queries_ServiceDesc.Streams[15], Queries_GetBlockTransactionEvents_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[BlockHashInput, BlockItemSummary]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Queries_GetBlockTransactionEventsClient = grpc.ServerStreamingClient[BlockItemSummary]

func (c *queriesClient) GetBlockSpecialEvents(ctx context.Context, in *BlockHashInput, opts ...grpc.CallOption) (grpc.ServerStreamingClient[BlockSpecialEvent], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Queries_ServiceDesc.Streams[16], Queries_GetBlockSpecialEvents_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[BlockHashInput, BlockSpecialEvent]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Queries_GetBlockSpecialEventsClient = grpc.ServerStreamingClient[BlockSpecialEvent]

func (c *queriesClient) GetBlockPendingUpdates(ctx context.Context, in *BlockHashInput, opts ...grpc.CallOption) (grpc.ServerStreamingClient[PendingUpdate], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Queries_ServiceDesc.Streams[17], Queries_GetBlockPendingUpdates_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[BlockHashInput, PendingUpdate]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Queries_GetBlockPendingUpdatesClient = grpc.ServerStreamingClient[PendingUpdate]

func (c *queriesClient) GetNextUpdateSequenceNumbers(ctx context.Context, in *BlockHashInput, opts ...grpc.CallOption) (*NextUpdateSequenceNumbers, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(NextUpdateSequenceNumbers)
	err := c.cc.Invoke(ctx, Queries_GetNextUpdateSequenceNumbers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) GetBakerEarliestWinTime(ctx context.Context, in *BakerId, opts ...grpc.CallOption) (*Timestamp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Timestamp)
	err := c.cc.Invoke(ctx, Queries_GetBakerEarliestWinTime_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) Shutdown(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Queries_Shutdown_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) PeerConnect(ctx context.Context, in *IpSocketAddress, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Queries_PeerConnect_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) PeerDisconnect(ctx context.Context, in *IpSocketAddress, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Queries_PeerDisconnect_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) GetBannedPeers(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*BannedPeers, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BannedPeers)
	err := c.cc.Invoke(ctx, Queries_GetBannedPeers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) BanPeer(ctx context.Context, in *PeerToBan, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Queries_BanPeer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) UnbanPeer(ctx context.Context, in *BannedPeer, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Queries_UnbanPeer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) DumpStart(ctx context.Context, in *DumpRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Queries_DumpStart_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) DumpStop(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Queries_DumpStop_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) GetPeersInfo(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*PeersInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PeersInfo)
	err := c.cc.Invoke(ctx, Queries_GetPeersInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) GetNodeInfo(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*NodeInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(NodeInfo)
	err := c.cc.Invoke(ctx, Queries_GetNodeInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) SendBlockItem(ctx context.Context, in *SendBlockItemRequest, opts ...grpc.CallOption) (*TransactionHash, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TransactionHash)
	err := c.cc.Invoke(ctx, Queries_SendBlockItem_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) GetAccountTransactionSignHash(ctx context.Context, in *PreAccountTransaction, opts ...grpc.CallOption) (*AccountTransactionSignHash, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AccountTransactionSignHash)
	err := c.cc.Invoke(ctx, Queries_GetAccountTransactionSignHash_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) GetBlockChainParameters(ctx context.Context, in *BlockHashInput, opts ...grpc.CallOption) (*ChainParameters, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ChainParameters)
	err := c.cc.Invoke(ctx, Queries_GetBlockChainParameters_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) GetBlockFinalizationSummary(ctx context.Context, in *BlockHashInput, opts ...grpc.CallOption) (*BlockFinalizationSummary, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BlockFinalizationSummary)
	err := c.cc.Invoke(ctx, Queries_GetBlockFinalizationSummary_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) GetBlockItems(ctx context.Context, in *BlockHashInput, opts ...grpc.CallOption) (grpc.ServerStreamingClient[BlockItem], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Queries_ServiceDesc.Streams[18], Queries_GetBlockItems_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[BlockHashInput, BlockItem]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Queries_GetBlockItemsClient = grpc.ServerStreamingClient[BlockItem]

func (c *queriesClient) GetBakersRewardPeriod(ctx context.Context, in *BlockHashInput, opts ...grpc.CallOption) (grpc.ServerStreamingClient[BakerRewardPeriodInfo], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Queries_ServiceDesc.Streams[19], Queries_GetBakersRewardPeriod_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[BlockHashInput, BakerRewardPeriodInfo]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Queries_GetBakersRewardPeriodClient = grpc.ServerStreamingClient[BakerRewardPeriodInfo]

func (c *queriesClient) GetBlockCertificates(ctx context.Context, in *BlockHashInput, opts ...grpc.CallOption) (*BlockCertificates, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BlockCertificates)
	err := c.cc.Invoke(ctx, Queries_GetBlockCertificates_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) GetWinningBakersEpoch(ctx context.Context, in *EpochRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[WinningBaker], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Queries_ServiceDesc.Streams[20], Queries_GetWinningBakersEpoch_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[EpochRequest, WinningBaker]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Queries_GetWinningBakersEpochClient = grpc.ServerStreamingClient[WinningBaker]

func (c *queriesClient) GetFirstBlockEpoch(ctx context.Context, in *EpochRequest, opts ...grpc.CallOption) (*BlockHash, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BlockHash)
	err := c.cc.Invoke(ctx, Queries_GetFirstBlockEpoch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) DryRun(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[DryRunRequest, DryRunResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Queries_ServiceDesc.Streams[21], Queries_DryRun_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[DryRunRequest, DryRunResponse]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Queries_DryRunClient = grpc.BidiStreamingClient[DryRunRequest, DryRunResponse]

// QueriesServer is the server API for Queries service.
// All implementations must embed UnimplementedQueriesServer
// for forward compatibility.
type QueriesServer interface {
	// Return a stream of blocks that arrive from the time the query is made onward.
	// This can be used to listen for incoming blocks.
	GetBlocks(*Empty, grpc.ServerStreamingServer[ArrivedBlockInfo]) error
	// Return a stream of blocks that are finalized from the time the query is
	// made onward. This can be used to listen for newly finalized blocks. Note
	// that there is no guarantee that blocks will not be skipped if the client is
	// too slow in processing the stream, however blocks will always be sent by
	// increasing block height.
	GetFinalizedBlocks(*Empty, grpc.ServerStreamingServer[FinalizedBlockInfo]) error
	// Retrieve the information about the given account in the given block.
	GetAccountInfo(context.Context, *AccountInfoRequest) (*AccountInfo, error)
	// Retrieve the list of accounts that exist at the end of the given block.
	GetAccountList(*BlockHashInput, grpc.ServerStreamingServer[AccountAddress]) error
	// Get a list of all smart contract modules. The stream will end
	// when all modules that exist in the state at the end of the given
	// block have been returned.
	GetModuleList(*BlockHashInput, grpc.ServerStreamingServer[ModuleRef]) error
	// Get a stream of ancestors for the provided block.
	// Starting with the provided block itself, moving backwards until no more
	// ancestors or the requested number of ancestors has been returned.
	GetAncestors(*AncestorsRequest, grpc.ServerStreamingServer[BlockHash]) error
	// Get the source of a smart contract module.
	GetModuleSource(context.Context, *ModuleSourceRequest) (*VersionedModuleSource, error)
	// Get a list of addresses for all smart contract instances. The stream
	// will end when all instances that exist in the state at the end of the
	// given block has been returned.
	GetInstanceList(*BlockHashInput, grpc.ServerStreamingServer[ContractAddress]) error
	// Get info about a smart contract instance as it appears at the end of the
	// given block.
	GetInstanceInfo(context.Context, *InstanceInfoRequest) (*InstanceInfo, error)
	// Get the exact state of a specific contract instance, streamed as a list of
	// key-value pairs. The list is streamed in lexicographic order of keys.
	GetInstanceState(*InstanceInfoRequest, grpc.ServerStreamingServer[InstanceStateKVPair]) error
	// Get the value at a specific key of a contract state. In contrast to
	// `GetInstanceState` this is more efficient, but requires the user to know
	// the specific key to look for.
	InstanceStateLookup(context.Context, *InstanceStateLookupRequest) (*InstanceStateValueAtKey, error)
	// Get the best guess as to what the next account sequence number should be.
	// If all account transactions are finalized then this information is reliable.
	// Otherwise this is the best guess, assuming all other transactions will be
	// committed to blocks and eventually finalized.
	GetNextAccountSequenceNumber(context.Context, *AccountAddress) (*NextAccountSequenceNumber, error)
	// Get information about the current state of consensus.
	GetConsensusInfo(context.Context, *Empty) (*ConsensusInfo, error)
	// Get the status of and information about a specific block item (transaction).
	GetBlockItemStatus(context.Context, *TransactionHash) (*BlockItemStatus, error)
	// Get the cryptographic parameters in a given block.
	GetCryptographicParameters(context.Context, *BlockHashInput) (*CryptographicParameters, error)
	// Get information, such as height, timings, and transaction counts for the given block.
	GetBlockInfo(context.Context, *BlockHashInput) (*BlockInfo, error)
	// Get all the bakers at the end of the given block.
	GetBakerList(*BlockHashInput, grpc.ServerStreamingServer[BakerId]) error
	// Get information about a given pool at the end of a given block.
	GetPoolInfo(context.Context, *PoolInfoRequest) (*PoolInfoResponse, error)
	// Get information about the passive delegators at the end of a given block.
	GetPassiveDelegationInfo(context.Context, *BlockHashInput) (*PassiveDelegationInfo, error)
	// Get a list of live blocks at a given height.
	GetBlocksAtHeight(context.Context, *BlocksAtHeightRequest) (*BlocksAtHeightResponse, error)
	// Get information about tokenomics at the end of a given block.
	GetTokenomicsInfo(context.Context, *BlockHashInput) (*TokenomicsInfo, error)
	// Run the smart contract entrypoint in a given context and in the state at
	// the end of the given block.
	InvokeInstance(context.Context, *InvokeInstanceRequest) (*InvokeInstanceResponse, error)
	// Get the registered delegators of a given pool at the end of a given block.
	// In contrast to the `GetPoolDelegatorsRewardPeriod` which returns delegators
	// that are fixed for the reward period of the block, this endpoint returns the
	// list of delegators that are registered in the block. Any changes to delegators
	// are immediately visible in this list.
	// The stream will end when all the delegators has been returned.
	GetPoolDelegators(*GetPoolDelegatorsRequest, grpc.ServerStreamingServer[DelegatorInfo]) error
	// Get the fixed delegators of a given pool for the reward period of the given block.
	// In contracts to the `GetPoolDelegators` which returns delegators registered
	// for the given block, this endpoint returns the fixed delegators contributing
	// stake in the reward period containing the given block.
	// The stream will end when all the delegators has been returned.
	GetPoolDelegatorsRewardPeriod(*GetPoolDelegatorsRequest, grpc.ServerStreamingServer[DelegatorRewardPeriodInfo]) error
	// Get the registered passive delegators at the end of a given block.
	// In contrast to the `GetPassiveDelegatorsRewardPeriod` which returns delegators
	// that are fixed for the reward period of the block, this endpoint returns the
	// list of delegators that are registered in the block. Any changes to delegators
	// are immediately visible in this list.
	// The stream will end when all the delegators has been returned.
	GetPassiveDelegators(*BlockHashInput, grpc.ServerStreamingServer[DelegatorInfo]) error
	// Get the fixed passive delegators for the reward period of the given block.
	// In contracts to the `GetPassiveDelegators` which returns delegators registered
	// for the given block, this endpoint returns the fixed delegators contributing
	// stake in the reward period containing the given block.
	// The stream will end when all the delegators has been returned.
	GetPassiveDelegatorsRewardPeriod(*BlockHashInput, grpc.ServerStreamingServer[DelegatorRewardPeriodInfo]) error
	// Get the current branches of blocks starting from and including the last finalized block.
	GetBranches(context.Context, *Empty) (*Branch, error)
	// Get information related to the baker election for a particular block.
	GetElectionInfo(context.Context, *BlockHashInput) (*ElectionInfo, error)
	// Get the identity providers registered as of the end of a given block.
	// The stream will end when all the identity providers have been returned.
	GetIdentityProviders(*BlockHashInput, grpc.ServerStreamingServer[IpInfo]) error
	// Get the anonymity revokers registered as of the end of a given block.
	// The stream will end when all the anonymity revokers have been returned.
	GetAnonymityRevokers(*BlockHashInput, grpc.ServerStreamingServer[ArInfo]) error
	// Get a list of non-finalized transaction hashes for a given account. This
	// endpoint is not expected to return a large amount of data in most cases,
	// but in bad network condtions it might. The stream will end when all the
	// non-finalized transaction hashes have been returned.
	GetAccountNonFinalizedTransactions(*AccountAddress, grpc.ServerStreamingServer[TransactionHash]) error
	// Get a list of transaction events in a given block.
	// The stream will end when all the transaction events for a given block have been returned.
	GetBlockTransactionEvents(*BlockHashInput, grpc.ServerStreamingServer[BlockItemSummary]) error
	// Get a list of special events in a given block. These are events generated
	// by the protocol, such as minting and reward payouts. They are not directly
	// generated by any transaction. The stream will end when all the special
	// events for a given block have been returned.
	GetBlockSpecialEvents(*BlockHashInput, grpc.ServerStreamingServer[BlockSpecialEvent]) error
	// Get the pending updates to chain parameters at the end of a given block.
	// The stream will end when all the pending updates for a given block have been returned.
	GetBlockPendingUpdates(*BlockHashInput, grpc.ServerStreamingServer[PendingUpdate]) error
	// Get next available sequence numbers for updating chain parameters after a given block.
	GetNextUpdateSequenceNumbers(context.Context, *BlockHashInput) (*NextUpdateSequenceNumbers, error)
	// Get the projected earliest time at which a particular baker will be required to bake a block.
	// If the current consensus version is 0, this returns the status 'Unavailable', as the endpoint
	// is only supported by consensus version 1.
	//
	// If the baker is not a baker for the current reward period, this returns a timestamp at the
	// start of the next reward period. If the baker is a baker for the current reward period, the
	// earliest win time is projected from the current round forward, assuming that each round after
	// the last finalized round will take the minimum block time. (If blocks take longer, or timeouts
	// occur, the actual time may be later, and the reported time in subsequent queries may reflect
	// this.) At the end of an epoch (or if the baker is not projected to bake before the end of the
	// epoch) the earliest win time for a (current) baker will be projected as the start of the next
	// epoch. This is because the seed for the leader election is updated at the epoch boundary, and
	// so the winners cannot be predicted beyond that. Note that in some circumstances the returned
	// timestamp can be in the past, especially at the end of an epoch.
	GetBakerEarliestWinTime(context.Context, *BakerId) (*Timestamp, error)
	// Shut down the node.
	// Return a GRPC error if the shutdown failed.
	Shutdown(context.Context, *Empty) (*Empty, error)
	// Suggest to a peer to connect to the submitted peer details.
	// This, if successful, adds the peer to the list of given addresses.
	// Otherwise return a GRPC error.
	// Note. The peer might not be connected to instantly, in that case
	// the node will try to establish the connection in near future. This
	// function returns a GRPC status 'Ok' in this case.
	PeerConnect(context.Context, *IpSocketAddress) (*Empty, error)
	// Disconnect from the peer and remove them from the given addresses list
	// if they are on it. Return if the request was processed successfully.
	// Otherwise return a GRPC error.
	PeerDisconnect(context.Context, *IpSocketAddress) (*Empty, error)
	// Get a list of banned peers.
	GetBannedPeers(context.Context, *Empty) (*BannedPeers, error)
	// Ban the given peer.
	// Returns a GRPC error if the action failed.
	BanPeer(context.Context, *PeerToBan) (*Empty, error)
	// Unban the banned peer.
	// Returns a GRPC error if the action failed.
	UnbanPeer(context.Context, *BannedPeer) (*Empty, error)
	// Start dumping packages into the specified file.
	// Only enabled if the node was built with the `network_dump` feature.
	// Returns a GRPC error if the network dump failed to start.
	DumpStart(context.Context, *DumpRequest) (*Empty, error)
	// Stop dumping packages.
	// Only enabled if the node was built with the `network_dump` feature.
	// Returns a GRPC error if the network dump failed to be stopped.
	DumpStop(context.Context, *Empty) (*Empty, error)
	// / Get a list of the peers that the node is connected to
	// / and assoicated network related information for each peer.
	GetPeersInfo(context.Context, *Empty) (*PeersInfo, error)
	// Get information about the node.
	// The `NodeInfo` includes information of
	//   - Meta information such as the, version of the node, type of the node, uptime and the local time of the node.
	//   - NetworkInfo which yields data such as the node id, packets sent/received,
	//     average bytes per second sent/received.
	//   - ConsensusInfo. The `ConsensusInfo` returned depends on if the node supports
	//     the protocol on chain and whether the node is configured as a baker or not.
	GetNodeInfo(context.Context, *Empty) (*NodeInfo, error)
	// Send a block item. A block item is either an `AccountTransaction`, which is
	// a transaction signed and paid for by an account, a `CredentialDeployment`,
	// which creates a new account, or `UpdateInstruction`, which is an
	// instruction to change some parameters of the chain. Update instructions can
	// only be sent by the governance committee.
	//
	// Returns a hash of the block item, which can be used with
	// `GetBlockItemStatus`.
	SendBlockItem(context.Context, *SendBlockItemRequest) (*TransactionHash, error)
	// Get the hash to be signed for an account transaction. The hash returned
	// should be signed and the signatures included as an
	// AccountTransactionSignature when calling `SendBlockItem`. This is provided as
	// a convenience to support cases where the right SDK is not available for
	// interacting with the node. If an SDK is available then it is strongly
	// recommended to compute this hash off-line using it. That reduces the trust
	// in the node, removes networking failure modes, and will perform better.
	GetAccountTransactionSignHash(context.Context, *PreAccountTransaction) (*AccountTransactionSignHash, error)
	// Get the values of chain parameters in effect in the given block.
	GetBlockChainParameters(context.Context, *BlockHashInput) (*ChainParameters, error)
	// Get the summary of the finalization data in a given block.
	GetBlockFinalizationSummary(context.Context, *BlockHashInput) (*BlockFinalizationSummary, error)
	// Get the items of a block.
	GetBlockItems(*BlockHashInput, grpc.ServerStreamingServer[BlockItem]) error
	// Get all bakers in the reward period of a block.
	// This endpoint is only supported for protocol version 6 and onwards.
	// If the protocol does not support the endpoint then an  'IllegalArgument' error is returned.
	GetBakersRewardPeriod(*BlockHashInput, grpc.ServerStreamingServer[BakerRewardPeriodInfo]) error
	// For a non-genesis block, this returns the quorum certificate, a timeout
	// certificate (if present) and epoch finalization entry (if present).
	// Note that, if the block being pointed to is not a product of ConcordiumBFT,
	// then the response will be a grpc error (invalid argument).
	// If the endpoint is not enabled by the node, then an 'unimplemented' error
	// will be returned.
	GetBlockCertificates(context.Context, *BlockHashInput) (*BlockCertificates, error)
	// Get the list of bakers that won the lottery in a particular historical epoch (i.e. the
	// last finalized block is in a later epoch). This lists the winners for each round in the
	// epoch, starting from the round after the last block in the previous epoch, running to
	// the round before the first block in the next epoch. It also indicates if a block in each
	// round was included in the finalized chain.
	//
	// The following error cases are possible:
	//   - `NOT_FOUND` if the query specifies an unknown block.
	//   - `UNAVAILABLE` if the query is for an epoch that is not finalized in the current genesis
	//
	// /    index, or is for a future genesis index.
	//   - `INVALID_ARGUMENT` if the query is for an epoch that is not finalized for a past genesis
	//     index.
	//   - `INVALID_ARGUMENT` if the query is for a genesis index at consensus version 0.
	//   - `INVALID_ARGUMENT` if the input `EpochRequest` is malformed.
	//   - `UNIMPLEMENTED` if the endpoint is disabled on the node.
	GetWinningBakersEpoch(*EpochRequest, grpc.ServerStreamingServer[WinningBaker]) error
	// Get the block hash of the first finalized block in a specified epoch.
	//
	// The following error cases are possible:
	//   - `NOT_FOUND` if the query specifies an unknown block.
	//   - `UNAVAILABLE` if the query is for an epoch that is not finalized in the current genesis
	//     index, or is for a future genesis index.
	//   - `INVALID_ARGUMENT` if the query is for an epoch with no finalized blocks for a past genesis
	//     index.
	//   - `INVALID_ARGUMENT` if the input `EpochRequest` is malformed.
	//   - `UNIMPLEMENTED` if the endpoint is disabled on the node.
	GetFirstBlockEpoch(context.Context, *EpochRequest) (*BlockHash, error)
	// Dry run a series of transactions and operations on a state derived from a specified block.
	// The server should send a single `DryRunResponse` for each `DryRunRequest` received, unless
	// the call fails with an error status code. If a request produces a `DryRunErrorResponse`, then
	// the server will still process subsequent requests, just as if the request causing the error
	// did not happen.
	//
	// The first request should be `load_block_at_state` to determine the block state that will be
	// used for the dry run.
	//
	// The server associates each request with an energy cost, and limits the total energy that may
	// be expended in a single invocation of `DryRun`. This limit is reported as `quota` in the
	// initial metadata returned by the server. If executing an operation exceeds the limit,
	// the server terminates the session with `RESOURCE_EXHAUSTED`.
	//
	// The server also imposes a timeout for a dry-run session to complete. The server reports
	// the timeout duration in milliseconds in the initial metadata field `timeout`. If the session
	// is not completed before the timeout elapses, the server terminates the session with
	// `DEADLINE_EXCEEDED`.
	//
	// The following error cases are possible:
	//   - `INVALID_ARGUMENT` if any `DryRunRequest` is malformed.
	//   - `RESOURCE_EXHAUSTED` if the energy quota is exceeded.
	//   - `DEADLINE_EXCEEDED` if the session does not complete before the server-imposed timeout.
	//   - `RESOURCE_EXHAUSTED` if the server is not currently accepting new `DryRun` sessions.
	//     (The server may impose a limit on the number of concurrent sessions.)
	//   - `INTERNAL` if an interal server error occurs. This should not happen, and likely indicates
	//     a bug.
	//   - `UNIMPLEMENTED` if the endpoint is disabled on the node.
	DryRun(grpc.BidiStreamingServer[DryRunRequest, DryRunResponse]) error
	mustEmbedUnimplementedQueriesServer()
}

// UnimplementedQueriesServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedQueriesServer struct{}

func (UnimplementedQueriesServer) GetBlocks(*Empty, grpc.ServerStreamingServer[ArrivedBlockInfo]) error {
	return status.Errorf(codes.Unimplemented, "method GetBlocks not implemented")
}
func (UnimplementedQueriesServer) GetFinalizedBlocks(*Empty, grpc.ServerStreamingServer[FinalizedBlockInfo]) error {
	return status.Errorf(codes.Unimplemented, "method GetFinalizedBlocks not implemented")
}
func (UnimplementedQueriesServer) GetAccountInfo(context.Context, *AccountInfoRequest) (*AccountInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAccountInfo not implemented")
}
func (UnimplementedQueriesServer) GetAccountList(*BlockHashInput, grpc.ServerStreamingServer[AccountAddress]) error {
	return status.Errorf(codes.Unimplemented, "method GetAccountList not implemented")
}
func (UnimplementedQueriesServer) GetModuleList(*BlockHashInput, grpc.ServerStreamingServer[ModuleRef]) error {
	return status.Errorf(codes.Unimplemented, "method GetModuleList not implemented")
}
func (UnimplementedQueriesServer) GetAncestors(*AncestorsRequest, grpc.ServerStreamingServer[BlockHash]) error {
	return status.Errorf(codes.Unimplemented, "method GetAncestors not implemented")
}
func (UnimplementedQueriesServer) GetModuleSource(context.Context, *ModuleSourceRequest) (*VersionedModuleSource, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetModuleSource not implemented")
}
func (UnimplementedQueriesServer) GetInstanceList(*BlockHashInput, grpc.ServerStreamingServer[ContractAddress]) error {
	return status.Errorf(codes.Unimplemented, "method GetInstanceList not implemented")
}
func (UnimplementedQueriesServer) GetInstanceInfo(context.Context, *InstanceInfoRequest) (*InstanceInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetInstanceInfo not implemented")
}
func (UnimplementedQueriesServer) GetInstanceState(*InstanceInfoRequest, grpc.ServerStreamingServer[InstanceStateKVPair]) error {
	return status.Errorf(codes.Unimplemented, "method GetInstanceState not implemented")
}
func (UnimplementedQueriesServer) InstanceStateLookup(context.Context, *InstanceStateLookupRequest) (*InstanceStateValueAtKey, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InstanceStateLookup not implemented")
}
func (UnimplementedQueriesServer) GetNextAccountSequenceNumber(context.Context, *AccountAddress) (*NextAccountSequenceNumber, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNextAccountSequenceNumber not implemented")
}
func (UnimplementedQueriesServer) GetConsensusInfo(context.Context, *Empty) (*ConsensusInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetConsensusInfo not implemented")
}
func (UnimplementedQueriesServer) GetBlockItemStatus(context.Context, *TransactionHash) (*BlockItemStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBlockItemStatus not implemented")
}
func (UnimplementedQueriesServer) GetCryptographicParameters(context.Context, *BlockHashInput) (*CryptographicParameters, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCryptographicParameters not implemented")
}
func (UnimplementedQueriesServer) GetBlockInfo(context.Context, *BlockHashInput) (*BlockInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBlockInfo not implemented")
}
func (UnimplementedQueriesServer) GetBakerList(*BlockHashInput, grpc.ServerStreamingServer[BakerId]) error {
	return status.Errorf(codes.Unimplemented, "method GetBakerList not implemented")
}
func (UnimplementedQueriesServer) GetPoolInfo(context.Context, *PoolInfoRequest) (*PoolInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPoolInfo not implemented")
}
func (UnimplementedQueriesServer) GetPassiveDelegationInfo(context.Context, *BlockHashInput) (*PassiveDelegationInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPassiveDelegationInfo not implemented")
}
func (UnimplementedQueriesServer) GetBlocksAtHeight(context.Context, *BlocksAtHeightRequest) (*BlocksAtHeightResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBlocksAtHeight not implemented")
}
func (UnimplementedQueriesServer) GetTokenomicsInfo(context.Context, *BlockHashInput) (*TokenomicsInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTokenomicsInfo not implemented")
}
func (UnimplementedQueriesServer) InvokeInstance(context.Context, *InvokeInstanceRequest) (*InvokeInstanceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InvokeInstance not implemented")
}
func (UnimplementedQueriesServer) GetPoolDelegators(*GetPoolDelegatorsRequest, grpc.ServerStreamingServer[DelegatorInfo]) error {
	return status.Errorf(codes.Unimplemented, "method GetPoolDelegators not implemented")
}
func (UnimplementedQueriesServer) GetPoolDelegatorsRewardPeriod(*GetPoolDelegatorsRequest, grpc.ServerStreamingServer[DelegatorRewardPeriodInfo]) error {
	return status.Errorf(codes.Unimplemented, "method GetPoolDelegatorsRewardPeriod not implemented")
}
func (UnimplementedQueriesServer) GetPassiveDelegators(*BlockHashInput, grpc.ServerStreamingServer[DelegatorInfo]) error {
	return status.Errorf(codes.Unimplemented, "method GetPassiveDelegators not implemented")
}
func (UnimplementedQueriesServer) GetPassiveDelegatorsRewardPeriod(*BlockHashInput, grpc.ServerStreamingServer[DelegatorRewardPeriodInfo]) error {
	return status.Errorf(codes.Unimplemented, "method GetPassiveDelegatorsRewardPeriod not implemented")
}
func (UnimplementedQueriesServer) GetBranches(context.Context, *Empty) (*Branch, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBranches not implemented")
}
func (UnimplementedQueriesServer) GetElectionInfo(context.Context, *BlockHashInput) (*ElectionInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetElectionInfo not implemented")
}
func (UnimplementedQueriesServer) GetIdentityProviders(*BlockHashInput, grpc.ServerStreamingServer[IpInfo]) error {
	return status.Errorf(codes.Unimplemented, "method GetIdentityProviders not implemented")
}
func (UnimplementedQueriesServer) GetAnonymityRevokers(*BlockHashInput, grpc.ServerStreamingServer[ArInfo]) error {
	return status.Errorf(codes.Unimplemented, "method GetAnonymityRevokers not implemented")
}
func (UnimplementedQueriesServer) GetAccountNonFinalizedTransactions(*AccountAddress, grpc.ServerStreamingServer[TransactionHash]) error {
	return status.Errorf(codes.Unimplemented, "method GetAccountNonFinalizedTransactions not implemented")
}
func (UnimplementedQueriesServer) GetBlockTransactionEvents(*BlockHashInput, grpc.ServerStreamingServer[BlockItemSummary]) error {
	return status.Errorf(codes.Unimplemented, "method GetBlockTransactionEvents not implemented")
}
func (UnimplementedQueriesServer) GetBlockSpecialEvents(*BlockHashInput, grpc.ServerStreamingServer[BlockSpecialEvent]) error {
	return status.Errorf(codes.Unimplemented, "method GetBlockSpecialEvents not implemented")
}
func (UnimplementedQueriesServer) GetBlockPendingUpdates(*BlockHashInput, grpc.ServerStreamingServer[PendingUpdate]) error {
	return status.Errorf(codes.Unimplemented, "method GetBlockPendingUpdates not implemented")
}
func (UnimplementedQueriesServer) GetNextUpdateSequenceNumbers(context.Context, *BlockHashInput) (*NextUpdateSequenceNumbers, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNextUpdateSequenceNumbers not implemented")
}
func (UnimplementedQueriesServer) GetBakerEarliestWinTime(context.Context, *BakerId) (*Timestamp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBakerEarliestWinTime not implemented")
}
func (UnimplementedQueriesServer) Shutdown(context.Context, *Empty) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Shutdown not implemented")
}
func (UnimplementedQueriesServer) PeerConnect(context.Context, *IpSocketAddress) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PeerConnect not implemented")
}
func (UnimplementedQueriesServer) PeerDisconnect(context.Context, *IpSocketAddress) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PeerDisconnect not implemented")
}
func (UnimplementedQueriesServer) GetBannedPeers(context.Context, *Empty) (*BannedPeers, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBannedPeers not implemented")
}
func (UnimplementedQueriesServer) BanPeer(context.Context, *PeerToBan) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BanPeer not implemented")
}
func (UnimplementedQueriesServer) UnbanPeer(context.Context, *BannedPeer) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnbanPeer not implemented")
}
func (UnimplementedQueriesServer) DumpStart(context.Context, *DumpRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DumpStart not implemented")
}
func (UnimplementedQueriesServer) DumpStop(context.Context, *Empty) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DumpStop not implemented")
}
func (UnimplementedQueriesServer) GetPeersInfo(context.Context, *Empty) (*PeersInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPeersInfo not implemented")
}
func (UnimplementedQueriesServer) GetNodeInfo(context.Context, *Empty) (*NodeInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNodeInfo not implemented")
}
func (UnimplementedQueriesServer) SendBlockItem(context.Context, *SendBlockItemRequest) (*TransactionHash, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendBlockItem not implemented")
}
func (UnimplementedQueriesServer) GetAccountTransactionSignHash(context.Context, *PreAccountTransaction) (*AccountTransactionSignHash, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAccountTransactionSignHash not implemented")
}
func (UnimplementedQueriesServer) GetBlockChainParameters(context.Context, *BlockHashInput) (*ChainParameters, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBlockChainParameters not implemented")
}
func (UnimplementedQueriesServer) GetBlockFinalizationSummary(context.Context, *BlockHashInput) (*BlockFinalizationSummary, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBlockFinalizationSummary not implemented")
}
func (UnimplementedQueriesServer) GetBlockItems(*BlockHashInput, grpc.ServerStreamingServer[BlockItem]) error {
	return status.Errorf(codes.Unimplemented, "method GetBlockItems not implemented")
}
func (UnimplementedQueriesServer) GetBakersRewardPeriod(*BlockHashInput, grpc.ServerStreamingServer[BakerRewardPeriodInfo]) error {
	return status.Errorf(codes.Unimplemented, "method GetBakersRewardPeriod not implemented")
}
func (UnimplementedQueriesServer) GetBlockCertificates(context.Context, *BlockHashInput) (*BlockCertificates, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBlockCertificates not implemented")
}
func (UnimplementedQueriesServer) GetWinningBakersEpoch(*EpochRequest, grpc.ServerStreamingServer[WinningBaker]) error {
	return status.Errorf(codes.Unimplemented, "method GetWinningBakersEpoch not implemented")
}
func (UnimplementedQueriesServer) GetFirstBlockEpoch(context.Context, *EpochRequest) (*BlockHash, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFirstBlockEpoch not implemented")
}
func (UnimplementedQueriesServer) DryRun(grpc.BidiStreamingServer[DryRunRequest, DryRunResponse]) error {
	return status.Errorf(codes.Unimplemented, "method DryRun not implemented")
}
func (UnimplementedQueriesServer) mustEmbedUnimplementedQueriesServer() {}
func (UnimplementedQueriesServer) testEmbeddedByValue()                 {}

// UnsafeQueriesServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to QueriesServer will
// result in compilation errors.
type UnsafeQueriesServer interface {
	mustEmbedUnimplementedQueriesServer()
}

func RegisterQueriesServer(s grpc.ServiceRegistrar, srv QueriesServer) {
	// If the following call pancis, it indicates UnimplementedQueriesServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Queries_ServiceDesc, srv)
}

func _Queries_GetBlocks_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueriesServer).GetBlocks(m, &grpc.GenericServerStream[Empty, ArrivedBlockInfo]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Queries_GetBlocksServer = grpc.ServerStreamingServer[ArrivedBlockInfo]

func _Queries_GetFinalizedBlocks_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueriesServer).GetFinalizedBlocks(m, &grpc.GenericServerStream[Empty, FinalizedBlockInfo]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Queries_GetFinalizedBlocksServer = grpc.ServerStreamingServer[FinalizedBlockInfo]

func _Queries_GetAccountInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccountInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).GetAccountInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Queries_GetAccountInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).GetAccountInfo(ctx, req.(*AccountInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_GetAccountList_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(BlockHashInput)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueriesServer).GetAccountList(m, &grpc.GenericServerStream[BlockHashInput, AccountAddress]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Queries_GetAccountListServer = grpc.ServerStreamingServer[AccountAddress]

func _Queries_GetModuleList_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(BlockHashInput)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueriesServer).GetModuleList(m, &grpc.GenericServerStream[BlockHashInput, ModuleRef]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Queries_GetModuleListServer = grpc.ServerStreamingServer[ModuleRef]

func _Queries_GetAncestors_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(AncestorsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueriesServer).GetAncestors(m, &grpc.GenericServerStream[AncestorsRequest, BlockHash]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Queries_GetAncestorsServer = grpc.ServerStreamingServer[BlockHash]

func _Queries_GetModuleSource_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ModuleSourceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).GetModuleSource(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Queries_GetModuleSource_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).GetModuleSource(ctx, req.(*ModuleSourceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_GetInstanceList_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(BlockHashInput)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueriesServer).GetInstanceList(m, &grpc.GenericServerStream[BlockHashInput, ContractAddress]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Queries_GetInstanceListServer = grpc.ServerStreamingServer[ContractAddress]

func _Queries_GetInstanceInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InstanceInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).GetInstanceInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Queries_GetInstanceInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).GetInstanceInfo(ctx, req.(*InstanceInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_GetInstanceState_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(InstanceInfoRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueriesServer).GetInstanceState(m, &grpc.GenericServerStream[InstanceInfoRequest, InstanceStateKVPair]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Queries_GetInstanceStateServer = grpc.ServerStreamingServer[InstanceStateKVPair]

func _Queries_InstanceStateLookup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InstanceStateLookupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).InstanceStateLookup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Queries_InstanceStateLookup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).InstanceStateLookup(ctx, req.(*InstanceStateLookupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_GetNextAccountSequenceNumber_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccountAddress)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).GetNextAccountSequenceNumber(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Queries_GetNextAccountSequenceNumber_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).GetNextAccountSequenceNumber(ctx, req.(*AccountAddress))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_GetConsensusInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).GetConsensusInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Queries_GetConsensusInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).GetConsensusInfo(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_GetBlockItemStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TransactionHash)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).GetBlockItemStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Queries_GetBlockItemStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).GetBlockItemStatus(ctx, req.(*TransactionHash))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_GetCryptographicParameters_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlockHashInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).GetCryptographicParameters(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Queries_GetCryptographicParameters_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).GetCryptographicParameters(ctx, req.(*BlockHashInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_GetBlockInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlockHashInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).GetBlockInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Queries_GetBlockInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).GetBlockInfo(ctx, req.(*BlockHashInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_GetBakerList_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(BlockHashInput)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueriesServer).GetBakerList(m, &grpc.GenericServerStream[BlockHashInput, BakerId]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Queries_GetBakerListServer = grpc.ServerStreamingServer[BakerId]

func _Queries_GetPoolInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PoolInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).GetPoolInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Queries_GetPoolInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).GetPoolInfo(ctx, req.(*PoolInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_GetPassiveDelegationInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlockHashInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).GetPassiveDelegationInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Queries_GetPassiveDelegationInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).GetPassiveDelegationInfo(ctx, req.(*BlockHashInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_GetBlocksAtHeight_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlocksAtHeightRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).GetBlocksAtHeight(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Queries_GetBlocksAtHeight_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).GetBlocksAtHeight(ctx, req.(*BlocksAtHeightRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_GetTokenomicsInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlockHashInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).GetTokenomicsInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Queries_GetTokenomicsInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).GetTokenomicsInfo(ctx, req.(*BlockHashInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_InvokeInstance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InvokeInstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).InvokeInstance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Queries_InvokeInstance_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).InvokeInstance(ctx, req.(*InvokeInstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_GetPoolDelegators_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetPoolDelegatorsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueriesServer).GetPoolDelegators(m, &grpc.GenericServerStream[GetPoolDelegatorsRequest, DelegatorInfo]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Queries_GetPoolDelegatorsServer = grpc.ServerStreamingServer[DelegatorInfo]

func _Queries_GetPoolDelegatorsRewardPeriod_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetPoolDelegatorsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueriesServer).GetPoolDelegatorsRewardPeriod(m, &grpc.GenericServerStream[GetPoolDelegatorsRequest, DelegatorRewardPeriodInfo]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Queries_GetPoolDelegatorsRewardPeriodServer = grpc.ServerStreamingServer[DelegatorRewardPeriodInfo]

func _Queries_GetPassiveDelegators_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(BlockHashInput)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueriesServer).GetPassiveDelegators(m, &grpc.GenericServerStream[BlockHashInput, DelegatorInfo]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Queries_GetPassiveDelegatorsServer = grpc.ServerStreamingServer[DelegatorInfo]

func _Queries_GetPassiveDelegatorsRewardPeriod_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(BlockHashInput)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueriesServer).GetPassiveDelegatorsRewardPeriod(m, &grpc.GenericServerStream[BlockHashInput, DelegatorRewardPeriodInfo]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Queries_GetPassiveDelegatorsRewardPeriodServer = grpc.ServerStreamingServer[DelegatorRewardPeriodInfo]

func _Queries_GetBranches_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).GetBranches(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Queries_GetBranches_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).GetBranches(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_GetElectionInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlockHashInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).GetElectionInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Queries_GetElectionInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).GetElectionInfo(ctx, req.(*BlockHashInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_GetIdentityProviders_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(BlockHashInput)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueriesServer).GetIdentityProviders(m, &grpc.GenericServerStream[BlockHashInput, IpInfo]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Queries_GetIdentityProvidersServer = grpc.ServerStreamingServer[IpInfo]

func _Queries_GetAnonymityRevokers_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(BlockHashInput)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueriesServer).GetAnonymityRevokers(m, &grpc.GenericServerStream[BlockHashInput, ArInfo]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Queries_GetAnonymityRevokersServer = grpc.ServerStreamingServer[ArInfo]

func _Queries_GetAccountNonFinalizedTransactions_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(AccountAddress)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueriesServer).GetAccountNonFinalizedTransactions(m, &grpc.GenericServerStream[AccountAddress, TransactionHash]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Queries_GetAccountNonFinalizedTransactionsServer = grpc.ServerStreamingServer[TransactionHash]

func _Queries_GetBlockTransactionEvents_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(BlockHashInput)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueriesServer).GetBlockTransactionEvents(m, &grpc.GenericServerStream[BlockHashInput, BlockItemSummary]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Queries_GetBlockTransactionEventsServer = grpc.ServerStreamingServer[BlockItemSummary]

func _Queries_GetBlockSpecialEvents_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(BlockHashInput)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueriesServer).GetBlockSpecialEvents(m, &grpc.GenericServerStream[BlockHashInput, BlockSpecialEvent]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Queries_GetBlockSpecialEventsServer = grpc.ServerStreamingServer[BlockSpecialEvent]

func _Queries_GetBlockPendingUpdates_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(BlockHashInput)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueriesServer).GetBlockPendingUpdates(m, &grpc.GenericServerStream[BlockHashInput, PendingUpdate]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Queries_GetBlockPendingUpdatesServer = grpc.ServerStreamingServer[PendingUpdate]

func _Queries_GetNextUpdateSequenceNumbers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlockHashInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).GetNextUpdateSequenceNumbers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Queries_GetNextUpdateSequenceNumbers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).GetNextUpdateSequenceNumbers(ctx, req.(*BlockHashInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_GetBakerEarliestWinTime_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BakerId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).GetBakerEarliestWinTime(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Queries_GetBakerEarliestWinTime_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).GetBakerEarliestWinTime(ctx, req.(*BakerId))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_Shutdown_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).Shutdown(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Queries_Shutdown_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).Shutdown(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_PeerConnect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IpSocketAddress)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).PeerConnect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Queries_PeerConnect_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).PeerConnect(ctx, req.(*IpSocketAddress))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_PeerDisconnect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IpSocketAddress)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).PeerDisconnect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Queries_PeerDisconnect_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).PeerDisconnect(ctx, req.(*IpSocketAddress))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_GetBannedPeers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).GetBannedPeers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Queries_GetBannedPeers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).GetBannedPeers(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_BanPeer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PeerToBan)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).BanPeer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Queries_BanPeer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).BanPeer(ctx, req.(*PeerToBan))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_UnbanPeer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BannedPeer)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).UnbanPeer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Queries_UnbanPeer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).UnbanPeer(ctx, req.(*BannedPeer))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_DumpStart_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DumpRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).DumpStart(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Queries_DumpStart_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).DumpStart(ctx, req.(*DumpRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_DumpStop_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).DumpStop(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Queries_DumpStop_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).DumpStop(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_GetPeersInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).GetPeersInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Queries_GetPeersInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).GetPeersInfo(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_GetNodeInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).GetNodeInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Queries_GetNodeInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).GetNodeInfo(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_SendBlockItem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendBlockItemRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).SendBlockItem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Queries_SendBlockItem_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).SendBlockItem(ctx, req.(*SendBlockItemRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_GetAccountTransactionSignHash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PreAccountTransaction)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).GetAccountTransactionSignHash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Queries_GetAccountTransactionSignHash_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).GetAccountTransactionSignHash(ctx, req.(*PreAccountTransaction))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_GetBlockChainParameters_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlockHashInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).GetBlockChainParameters(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Queries_GetBlockChainParameters_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).GetBlockChainParameters(ctx, req.(*BlockHashInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_GetBlockFinalizationSummary_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlockHashInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).GetBlockFinalizationSummary(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Queries_GetBlockFinalizationSummary_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).GetBlockFinalizationSummary(ctx, req.(*BlockHashInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_GetBlockItems_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(BlockHashInput)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueriesServer).GetBlockItems(m, &grpc.GenericServerStream[BlockHashInput, BlockItem]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Queries_GetBlockItemsServer = grpc.ServerStreamingServer[BlockItem]

func _Queries_GetBakersRewardPeriod_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(BlockHashInput)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueriesServer).GetBakersRewardPeriod(m, &grpc.GenericServerStream[BlockHashInput, BakerRewardPeriodInfo]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Queries_GetBakersRewardPeriodServer = grpc.ServerStreamingServer[BakerRewardPeriodInfo]

func _Queries_GetBlockCertificates_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlockHashInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).GetBlockCertificates(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Queries_GetBlockCertificates_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).GetBlockCertificates(ctx, req.(*BlockHashInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_GetWinningBakersEpoch_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(EpochRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueriesServer).GetWinningBakersEpoch(m, &grpc.GenericServerStream[EpochRequest, WinningBaker]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Queries_GetWinningBakersEpochServer = grpc.ServerStreamingServer[WinningBaker]

func _Queries_GetFirstBlockEpoch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EpochRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).GetFirstBlockEpoch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Queries_GetFirstBlockEpoch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).GetFirstBlockEpoch(ctx, req.(*EpochRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_DryRun_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(QueriesServer).DryRun(&grpc.GenericServerStream[DryRunRequest, DryRunResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Queries_DryRunServer = grpc.BidiStreamingServer[DryRunRequest, DryRunResponse]

// Queries_ServiceDesc is the grpc.ServiceDesc for Queries service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Queries_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "concordium.v2.Queries",
	HandlerType: (*QueriesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetAccountInfo",
			Handler:    _Queries_GetAccountInfo_Handler,
		},
		{
			MethodName: "GetModuleSource",
			Handler:    _Queries_GetModuleSource_Handler,
		},
		{
			MethodName: "GetInstanceInfo",
			Handler:    _Queries_GetInstanceInfo_Handler,
		},
		{
			MethodName: "InstanceStateLookup",
			Handler:    _Queries_InstanceStateLookup_Handler,
		},
		{
			MethodName: "GetNextAccountSequenceNumber",
			Handler:    _Queries_GetNextAccountSequenceNumber_Handler,
		},
		{
			MethodName: "GetConsensusInfo",
			Handler:    _Queries_GetConsensusInfo_Handler,
		},
		{
			MethodName: "GetBlockItemStatus",
			Handler:    _Queries_GetBlockItemStatus_Handler,
		},
		{
			MethodName: "GetCryptographicParameters",
			Handler:    _Queries_GetCryptographicParameters_Handler,
		},
		{
			MethodName: "GetBlockInfo",
			Handler:    _Queries_GetBlockInfo_Handler,
		},
		{
			MethodName: "GetPoolInfo",
			Handler:    _Queries_GetPoolInfo_Handler,
		},
		{
			MethodName: "GetPassiveDelegationInfo",
			Handler:    _Queries_GetPassiveDelegationInfo_Handler,
		},
		{
			MethodName: "GetBlocksAtHeight",
			Handler:    _Queries_GetBlocksAtHeight_Handler,
		},
		{
			MethodName: "GetTokenomicsInfo",
			Handler:    _Queries_GetTokenomicsInfo_Handler,
		},
		{
			MethodName: "InvokeInstance",
			Handler:    _Queries_InvokeInstance_Handler,
		},
		{
			MethodName: "GetBranches",
			Handler:    _Queries_GetBranches_Handler,
		},
		{
			MethodName: "GetElectionInfo",
			Handler:    _Queries_GetElectionInfo_Handler,
		},
		{
			MethodName: "GetNextUpdateSequenceNumbers",
			Handler:    _Queries_GetNextUpdateSequenceNumbers_Handler,
		},
		{
			MethodName: "GetBakerEarliestWinTime",
			Handler:    _Queries_GetBakerEarliestWinTime_Handler,
		},
		{
			MethodName: "Shutdown",
			Handler:    _Queries_Shutdown_Handler,
		},
		{
			MethodName: "PeerConnect",
			Handler:    _Queries_PeerConnect_Handler,
		},
		{
			MethodName: "PeerDisconnect",
			Handler:    _Queries_PeerDisconnect_Handler,
		},
		{
			MethodName: "GetBannedPeers",
			Handler:    _Queries_GetBannedPeers_Handler,
		},
		{
			MethodName: "BanPeer",
			Handler:    _Queries_BanPeer_Handler,
		},
		{
			MethodName: "UnbanPeer",
			Handler:    _Queries_UnbanPeer_Handler,
		},
		{
			MethodName: "DumpStart",
			Handler:    _Queries_DumpStart_Handler,
		},
		{
			MethodName: "DumpStop",
			Handler:    _Queries_DumpStop_Handler,
		},
		{
			MethodName: "GetPeersInfo",
			Handler:    _Queries_GetPeersInfo_Handler,
		},
		{
			MethodName: "GetNodeInfo",
			Handler:    _Queries_GetNodeInfo_Handler,
		},
		{
			MethodName: "SendBlockItem",
			Handler:    _Queries_SendBlockItem_Handler,
		},
		{
			MethodName: "GetAccountTransactionSignHash",
			Handler:    _Queries_GetAccountTransactionSignHash_Handler,
		},
		{
			MethodName: "GetBlockChainParameters",
			Handler:    _Queries_GetBlockChainParameters_Handler,
		},
		{
			MethodName: "GetBlockFinalizationSummary",
			Handler:    _Queries_GetBlockFinalizationSummary_Handler,
		},
		{
			MethodName: "GetBlockCertificates",
			Handler:    _Queries_GetBlockCertificates_Handler,
		},
		{
			MethodName: "GetFirstBlockEpoch",
			Handler:    _Queries_GetFirstBlockEpoch_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetBlocks",
			Handler:       _Queries_GetBlocks_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetFinalizedBlocks",
			Handler:       _Queries_GetFinalizedBlocks_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetAccountList",
			Handler:       _Queries_GetAccountList_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetModuleList",
			Handler:       _Queries_GetModuleList_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetAncestors",
			Handler:       _Queries_GetAncestors_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetInstanceList",
			Handler:       _Queries_GetInstanceList_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetInstanceState",
			Handler:       _Queries_GetInstanceState_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetBakerList",
			Handler:       _Queries_GetBakerList_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetPoolDelegators",
			Handler:       _Queries_GetPoolDelegators_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetPoolDelegatorsRewardPeriod",
			Handler:       _Queries_GetPoolDelegatorsRewardPeriod_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetPassiveDelegators",
			Handler:       _Queries_GetPassiveDelegators_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetPassiveDelegatorsRewardPeriod",
			Handler:       _Queries_GetPassiveDelegatorsRewardPeriod_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetIdentityProviders",
			Handler:       _Queries_GetIdentityProviders_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetAnonymityRevokers",
			Handler:       _Queries_GetAnonymityRevokers_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetAccountNonFinalizedTransactions",
			Handler:       _Queries_GetAccountNonFinalizedTransactions_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetBlockTransactionEvents",
			Handler:       _Queries_GetBlockTransactionEvents_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetBlockSpecialEvents",
			Handler:       _Queries_GetBlockSpecialEvents_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetBlockPendingUpdates",
			Handler:       _Queries_GetBlockPendingUpdates_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetBlockItems",
			Handler:       _Queries_GetBlockItems_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetBakersRewardPeriod",
			Handler:       _Queries_GetBakersRewardPeriod_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetWinningBakersEpoch",
			Handler:       _Queries_GetWinningBakersEpoch_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "DryRun",
			Handler:       _Queries_DryRun_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "v2/concordium/service.proto",
}
