// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v4.25.1
// source: v2/concordium/service.proto

package pb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// QueriesClient is the client API for Queries service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type QueriesClient interface {
	// Return a stream of blocks that arrive from the time the query is made onward.
	// This can be used to listen for incoming blocks.
	GetBlocks(ctx context.Context, in *Empty, opts ...grpc.CallOption) (Queries_GetBlocksClient, error)
	// Return a stream of blocks that are finalized from the time the query is
	// made onward. This can be used to listen for newly finalized blocks. Note
	// that there is no guarantee that blocks will not be skipped if the client is
	// too slow in processing the stream, however blocks will always be sent by
	// increasing block height.
	GetFinalizedBlocks(ctx context.Context, in *Empty, opts ...grpc.CallOption) (Queries_GetFinalizedBlocksClient, error)
	// Retrieve the information about the given account in the given block.
	GetAccountInfo(ctx context.Context, in *AccountInfoRequest, opts ...grpc.CallOption) (*AccountInfo, error)
	// Retrieve the list of accounts that exist at the end of the given block.
	GetAccountList(ctx context.Context, in *BlockHashInput, opts ...grpc.CallOption) (Queries_GetAccountListClient, error)
	// Get a list of all smart contract modules. The stream will end
	// when all modules that exist in the state at the end of the given
	// block have been returned.
	GetModuleList(ctx context.Context, in *BlockHashInput, opts ...grpc.CallOption) (Queries_GetModuleListClient, error)
	// Get a stream of ancestors for the provided block.
	// Starting with the provided block itself, moving backwards until no more
	// ancestors or the requested number of ancestors has been returned.
	GetAncestors(ctx context.Context, in *AncestorsRequest, opts ...grpc.CallOption) (Queries_GetAncestorsClient, error)
	// Get the source of a smart contract module.
	GetModuleSource(ctx context.Context, in *ModuleSourceRequest, opts ...grpc.CallOption) (*VersionedModuleSource, error)
	// Get a list of addresses for all smart contract instances. The stream
	// will end when all instances that exist in the state at the end of the
	// given block has been returned.
	GetInstanceList(ctx context.Context, in *BlockHashInput, opts ...grpc.CallOption) (Queries_GetInstanceListClient, error)
	// Get info about a smart contract instance as it appears at the end of the
	// given block.
	GetInstanceInfo(ctx context.Context, in *InstanceInfoRequest, opts ...grpc.CallOption) (*InstanceInfo, error)
	// Get the exact state of a specific contract instance, streamed as a list of
	// key-value pairs. The list is streamed in lexicographic order of keys.
	GetInstanceState(ctx context.Context, in *InstanceInfoRequest, opts ...grpc.CallOption) (Queries_GetInstanceStateClient, error)
	// Get the value at a specific key of a contract state. In contrast to
	// `GetInstanceState` this is more efficient, but requires the user to know
	// the specific key to look for.
	InstanceStateLookup(ctx context.Context, in *InstanceStateLookupRequest, opts ...grpc.CallOption) (*InstanceStateValueAtKey, error)
	// Get the best guess as to what the next account sequence number should be.
	// If all account transactions are finalized then this information is reliable.
	// Otherwise this is the best guess, assuming all other transactions will be
	// committed to blocks and eventually finalized.
	GetNextAccountSequenceNumber(ctx context.Context, in *AccountAddress, opts ...grpc.CallOption) (*NextAccountSequenceNumber, error)
	// Get information about the current state of consensus.
	GetConsensusInfo(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ConsensusInfo, error)
	// Get the status of and information about a specific block item (transaction).
	GetBlockItemStatus(ctx context.Context, in *TransactionHash, opts ...grpc.CallOption) (*BlockItemStatus, error)
	// Get the cryptographic parameters in a given block.
	GetCryptographicParameters(ctx context.Context, in *BlockHashInput, opts ...grpc.CallOption) (*CryptographicParameters, error)
	// Get information, such as height, timings, and transaction counts for the given block.
	GetBlockInfo(ctx context.Context, in *BlockHashInput, opts ...grpc.CallOption) (*BlockInfo, error)
	// Get all the bakers at the end of the given block.
	GetBakerList(ctx context.Context, in *BlockHashInput, opts ...grpc.CallOption) (Queries_GetBakerListClient, error)
	// Get information about a given pool at the end of a given block.
	GetPoolInfo(ctx context.Context, in *PoolInfoRequest, opts ...grpc.CallOption) (*PoolInfoResponse, error)
	// Get information about the passive delegators at the end of a given block.
	GetPassiveDelegationInfo(ctx context.Context, in *BlockHashInput, opts ...grpc.CallOption) (*PassiveDelegationInfo, error)
	// Get a list of live blocks at a given height.
	GetBlocksAtHeight(ctx context.Context, in *BlocksAtHeightRequest, opts ...grpc.CallOption) (*BlocksAtHeightResponse, error)
	// Get information about tokenomics at the end of a given block.
	GetTokenomicsInfo(ctx context.Context, in *BlockHashInput, opts ...grpc.CallOption) (*TokenomicsInfo, error)
	// Run the smart contract entrypoint in a given context and in the state at
	// the end of the given block.
	InvokeInstance(ctx context.Context, in *InvokeInstanceRequest, opts ...grpc.CallOption) (*InvokeInstanceResponse, error)
	// Get the registered delegators of a given pool at the end of a given block.
	// In contrast to the `GetPoolDelegatorsRewardPeriod` which returns delegators
	// that are fixed for the reward period of the block, this endpoint returns the
	// list of delegators that are registered in the block. Any changes to delegators
	// are immediately visible in this list.
	// The stream will end when all the delegators has been returned.
	GetPoolDelegators(ctx context.Context, in *GetPoolDelegatorsRequest, opts ...grpc.CallOption) (Queries_GetPoolDelegatorsClient, error)
	// Get the fixed delegators of a given pool for the reward period of the given block.
	// In contracts to the `GetPoolDelegators` which returns delegators registered
	// for the given block, this endpoint returns the fixed delegators contributing
	// stake in the reward period containing the given block.
	// The stream will end when all the delegators has been returned.
	GetPoolDelegatorsRewardPeriod(ctx context.Context, in *GetPoolDelegatorsRequest, opts ...grpc.CallOption) (Queries_GetPoolDelegatorsRewardPeriodClient, error)
	// Get the registered passive delegators at the end of a given block.
	// In contrast to the `GetPassiveDelegatorsRewardPeriod` which returns delegators
	// that are fixed for the reward period of the block, this endpoint returns the
	// list of delegators that are registered in the block. Any changes to delegators
	// are immediately visible in this list.
	// The stream will end when all the delegators has been returned.
	GetPassiveDelegators(ctx context.Context, in *BlockHashInput, opts ...grpc.CallOption) (Queries_GetPassiveDelegatorsClient, error)
	// Get the fixed passive delegators for the reward period of the given block.
	// In contracts to the `GetPassiveDelegators` which returns delegators registered
	// for the given block, this endpoint returns the fixed delegators contributing
	// stake in the reward period containing the given block.
	// The stream will end when all the delegators has been returned.
	GetPassiveDelegatorsRewardPeriod(ctx context.Context, in *BlockHashInput, opts ...grpc.CallOption) (Queries_GetPassiveDelegatorsRewardPeriodClient, error)
	// Get the current branches of blocks starting from and including the last finalized block.
	GetBranches(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Branch, error)
	// Get information related to the baker election for a particular block.
	GetElectionInfo(ctx context.Context, in *BlockHashInput, opts ...grpc.CallOption) (*ElectionInfo, error)
	// Get the identity providers registered as of the end of a given block.
	// The stream will end when all the identity providers have been returned.
	GetIdentityProviders(ctx context.Context, in *BlockHashInput, opts ...grpc.CallOption) (Queries_GetIdentityProvidersClient, error)
	// Get the anonymity revokers registered as of the end of a given block.
	// The stream will end when all the anonymity revokers have been returned.
	GetAnonymityRevokers(ctx context.Context, in *BlockHashInput, opts ...grpc.CallOption) (Queries_GetAnonymityRevokersClient, error)
	// Get a list of non-finalized transaction hashes for a given account. This
	// endpoint is not expected to return a large amount of data in most cases,
	// but in bad network condtions it might. The stream will end when all the
	// non-finalized transaction hashes have been returned.
	GetAccountNonFinalizedTransactions(ctx context.Context, in *AccountAddress, opts ...grpc.CallOption) (Queries_GetAccountNonFinalizedTransactionsClient, error)
	// Get a list of transaction events in a given block.
	// The stream will end when all the transaction events for a given block have been returned.
	GetBlockTransactionEvents(ctx context.Context, in *BlockHashInput, opts ...grpc.CallOption) (Queries_GetBlockTransactionEventsClient, error)
	// Get a list of special events in a given block. These are events generated
	// by the protocol, such as minting and reward payouts. They are not directly
	// generated by any transaction. The stream will end when all the special
	// events for a given block have been returned.
	GetBlockSpecialEvents(ctx context.Context, in *BlockHashInput, opts ...grpc.CallOption) (Queries_GetBlockSpecialEventsClient, error)
	// Get the pending updates to chain parameters at the end of a given block.
	// The stream will end when all the pending updates for a given block have been returned.
	GetBlockPendingUpdates(ctx context.Context, in *BlockHashInput, opts ...grpc.CallOption) (Queries_GetBlockPendingUpdatesClient, error)
	// Get next available sequence numbers for updating chain parameters after a given block.
	GetNextUpdateSequenceNumbers(ctx context.Context, in *BlockHashInput, opts ...grpc.CallOption) (*NextUpdateSequenceNumbers, error)
	// Get the projected earliest time at which a particular baker will be required to bake a block.
	// If the current consensus version is 0, this returns the status 'Unavailable', as the endpoint
	// is only supported by consensus version 1.
	//
	// If the baker is not a baker for the current reward period, this returns a timestamp at the
	// start of the next reward period. If the baker is a baker for the current reward period, the
	// earliest win time is projected from the current round forward, assuming that each round after
	// the last finalized round will take the minimum block time. (If blocks take longer, or timeouts
	// occur, the actual time may be later, and the reported time in subsequent queries may reflect
	// this.) At the end of an epoch (or if the baker is not projected to bake before the end of the
	// epoch) the earliest win time for a (current) baker will be projected as the start of the next
	// epoch. This is because the seed for the leader election is updated at the epoch boundary, and
	// so the winners cannot be predicted beyond that. Note that in some circumstances the returned
	// timestamp can be in the past, especially at the end of an epoch.
	GetBakerEarliestWinTime(ctx context.Context, in *BakerId, opts ...grpc.CallOption) (*Timestamp, error)
	// Shut down the node.
	// Return a GRPC error if the shutdown failed.
	Shutdown(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error)
	// Suggest to a peer to connect to the submitted peer details.
	// This, if successful, adds the peer to the list of given addresses.
	// Otherwise return a GRPC error.
	// Note. The peer might not be connected to instantly, in that case
	// the node will try to establish the connection in near future. This
	// function returns a GRPC status 'Ok' in this case.
	PeerConnect(ctx context.Context, in *IpSocketAddress, opts ...grpc.CallOption) (*Empty, error)
	// Disconnect from the peer and remove them from the given addresses list
	// if they are on it. Return if the request was processed successfully.
	// Otherwise return a GRPC error.
	PeerDisconnect(ctx context.Context, in *IpSocketAddress, opts ...grpc.CallOption) (*Empty, error)
	// Get a list of banned peers.
	GetBannedPeers(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*BannedPeers, error)
	// Ban the given peer.
	// Returns a GRPC error if the action failed.
	BanPeer(ctx context.Context, in *PeerToBan, opts ...grpc.CallOption) (*Empty, error)
	// Unban the banned peer.
	// Returns a GRPC error if the action failed.
	UnbanPeer(ctx context.Context, in *BannedPeer, opts ...grpc.CallOption) (*Empty, error)
	// Start dumping packages into the specified file.
	// Only enabled if the node was built with the `network_dump` feature.
	// Returns a GRPC error if the network dump failed to start.
	DumpStart(ctx context.Context, in *DumpRequest, opts ...grpc.CallOption) (*Empty, error)
	// Stop dumping packages.
	// Only enabled if the node was built with the `network_dump` feature.
	// Returns a GRPC error if the network dump failed to be stopped.
	DumpStop(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error)
	// / Get a list of the peers that the node is connected to
	// / and assoicated network related information for each peer.
	GetPeersInfo(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*PeersInfo, error)
	// Get information about the node.
	// The `NodeInfo` includes information of
	//   - Meta information such as the, version of the node, type of the node, uptime and the local time of the node.
	//   - NetworkInfo which yields data such as the node id, packets sent/received,
	//     average bytes per second sent/received.
	//   - ConsensusInfo. The `ConsensusInfo` returned depends on if the node supports
	//     the protocol on chain and whether the node is configured as a baker or not.
	GetNodeInfo(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*NodeInfo, error)
	// Send a block item. A block item is either an `AccountTransaction`, which is
	// a transaction signed and paid for by an account, a `CredentialDeployment`,
	// which creates a new account, or `UpdateInstruction`, which is an
	// instruction to change some parameters of the chain. Update instructions can
	// only be sent by the governance committee.
	//
	// Returns a hash of the block item, which can be used with
	// `GetBlockItemStatus`.
	SendBlockItem(ctx context.Context, in *SendBlockItemRequest, opts ...grpc.CallOption) (*TransactionHash, error)
	// Get the hash to be signed for an account transaction. The hash returned
	// should be signed and the signatures included as an
	// AccountTransactionSignature when calling `SendBlockItem`. This is provided as
	// a convenience to support cases where the right SDK is not available for
	// interacting with the node. If an SDK is available then it is strongly
	// recommended to compute this hash off-line using it. That reduces the trust
	// in the node, removes networking failure modes, and will perform better.
	GetAccountTransactionSignHash(ctx context.Context, in *PreAccountTransaction, opts ...grpc.CallOption) (*AccountTransactionSignHash, error)
	// Get the values of chain parameters in effect in the given block.
	GetBlockChainParameters(ctx context.Context, in *BlockHashInput, opts ...grpc.CallOption) (*ChainParameters, error)
	// Get the summary of the finalization data in a given block.
	GetBlockFinalizationSummary(ctx context.Context, in *BlockHashInput, opts ...grpc.CallOption) (*BlockFinalizationSummary, error)
	// Get the items of a block.
	GetBlockItems(ctx context.Context, in *BlockHashInput, opts ...grpc.CallOption) (Queries_GetBlockItemsClient, error)
	// Get all bakers in the reward period of a block.
	// This endpoint is only supported for protocol version 6 and onwards.
	// If the protocol does not support the endpoint then an  'IllegalArgument' error is returned.
	GetBakersRewardPeriod(ctx context.Context, in *BlockHashInput, opts ...grpc.CallOption) (Queries_GetBakersRewardPeriodClient, error)
	// For a non-genesis block, this returns the quorum certificate, a timeout
	// certificate (if present) and epoch finalization entry (if present).
	// Note that, if the block being pointed to is not a product of ConcordiumBFT,
	// then the response will be a grpc error (invalid argument).
	// If the endpoint is not enabled by the node, then an 'unimplemented' error
	// will be returned.
	GetBlockCertificates(ctx context.Context, in *BlockHashInput, opts ...grpc.CallOption) (*BlockCertificates, error)
	// Get the list of bakers that won the lottery in a particular historical epoch (i.e. the
	// last finalized block is in a later epoch). This lists the winners for each round in the
	// epoch, starting from the round after the last block in the previous epoch, running to
	// the round before the first block in the next epoch. It also indicates if a block in each
	// round was included in the finalized chain.
	//
	// The following error cases are possible:
	//   - `NOT_FOUND` if the query specifies an unknown block.
	//   - `UNAVAILABLE` if the query is for an epoch that is not finalized in the current genesis
	//
	// /    index, or is for a future genesis index.
	//   - `INVALID_ARGUMENT` if the query is for an epoch that is not finalized for a past genesis
	//     index.
	//   - `INVALID_ARGUMENT` if the query is for a genesis index at consensus version 0.
	//   - `INVALID_ARGUMENT` if the input `EpochRequest` is malformed.
	//   - `UNIMPLEMENTED` if the endpoint is disabled on the node.
	GetWinningBakersEpoch(ctx context.Context, in *EpochRequest, opts ...grpc.CallOption) (Queries_GetWinningBakersEpochClient, error)
	// Get the block hash of the first finalized block in a specified epoch.
	//
	// The following error cases are possible:
	//   - `NOT_FOUND` if the query specifies an unknown block.
	//   - `UNAVAILABLE` if the query is for an epoch that is not finalized in the current genesis
	//     index, or is for a future genesis index.
	//   - `INVALID_ARGUMENT` if the query is for an epoch with no finalized blocks for a past genesis
	//     index.
	//   - `INVALID_ARGUMENT` if the input `EpochRequest` is malformed.
	//   - `UNIMPLEMENTED` if the endpoint is disabled on the node.
	GetFirstBlockEpoch(ctx context.Context, in *EpochRequest, opts ...grpc.CallOption) (*BlockHash, error)
	// Dry run a series of transactions and operations on a state derived from a specified block.
	// The server should send a single `DryRunResponse` for each `DryRunRequest` received, unless
	// the call fails with an error status code. If a request produces a `DryRunErrorResponse`, then
	// the server will still process subsequent requests, just as if the request causing the error
	// did not happen.
	//
	// The first request should be `load_block_at_state` to determine the block state that will be
	// used for the dry run.
	//
	// The server associates each request with an energy cost, and limits the total energy that may
	// be expended in a single invocation of `DryRun`. This limit is reported as `quota` in the
	// initial metadata returned by the server. If executing an operation exceeds the limit,
	// the server terminates the session with `RESOURCE_EXHAUSTED`.
	//
	// The server also imposes a timeout for a dry-run session to complete. The server reports
	// the timeout duration in milliseconds in the initial metadata field `timeout`. If the session
	// is not completed before the timeout elapses, the server terminates the session with
	// `DEADLINE_EXCEEDED`.
	//
	// The following error cases are possible:
	//   - `INVALID_ARGUMENT` if any `DryRunRequest` is malformed.
	//   - `RESOURCE_EXHAUSTED` if the energy quota is exceeded.
	//   - `DEADLINE_EXCEEDED` if the session does not complete before the server-imposed timeout.
	//   - `RESOURCE_EXHAUSTED` if the server is not currently accepting new `DryRun` sessions.
	//     (The server may impose a limit on the number of concurrent sessions.)
	//   - `INTERNAL` if an interal server error occurs. This should not happen, and likely indicates
	//     a bug.
	//   - `UNIMPLEMENTED` if the endpoint is disabled on the node.
	DryRun(ctx context.Context, opts ...grpc.CallOption) (Queries_DryRunClient, error)
}

type queriesClient struct {
	cc grpc.ClientConnInterface
}

func NewQueriesClient(cc grpc.ClientConnInterface) QueriesClient {
	return &queriesClient{cc}
}

func (c *queriesClient) GetBlocks(ctx context.Context, in *Empty, opts ...grpc.CallOption) (Queries_GetBlocksClient, error) {
	stream, err := c.cc.NewStream(ctx, &Queries_ServiceDesc.Streams[0], "/concordium.v2.Queries/GetBlocks", opts...)
	if err != nil {
		return nil, err
	}
	x := &queriesGetBlocksClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Queries_GetBlocksClient interface {
	Recv() (*ArrivedBlockInfo, error)
	grpc.ClientStream
}

type queriesGetBlocksClient struct {
	grpc.ClientStream
}

func (x *queriesGetBlocksClient) Recv() (*ArrivedBlockInfo, error) {
	m := new(ArrivedBlockInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *queriesClient) GetFinalizedBlocks(ctx context.Context, in *Empty, opts ...grpc.CallOption) (Queries_GetFinalizedBlocksClient, error) {
	stream, err := c.cc.NewStream(ctx, &Queries_ServiceDesc.Streams[1], "/concordium.v2.Queries/GetFinalizedBlocks", opts...)
	if err != nil {
		return nil, err
	}
	x := &queriesGetFinalizedBlocksClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Queries_GetFinalizedBlocksClient interface {
	Recv() (*FinalizedBlockInfo, error)
	grpc.ClientStream
}

type queriesGetFinalizedBlocksClient struct {
	grpc.ClientStream
}

func (x *queriesGetFinalizedBlocksClient) Recv() (*FinalizedBlockInfo, error) {
	m := new(FinalizedBlockInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *queriesClient) GetAccountInfo(ctx context.Context, in *AccountInfoRequest, opts ...grpc.CallOption) (*AccountInfo, error) {
	out := new(AccountInfo)
	err := c.cc.Invoke(ctx, "/concordium.v2.Queries/GetAccountInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) GetAccountList(ctx context.Context, in *BlockHashInput, opts ...grpc.CallOption) (Queries_GetAccountListClient, error) {
	stream, err := c.cc.NewStream(ctx, &Queries_ServiceDesc.Streams[2], "/concordium.v2.Queries/GetAccountList", opts...)
	if err != nil {
		return nil, err
	}
	x := &queriesGetAccountListClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Queries_GetAccountListClient interface {
	Recv() (*AccountAddress, error)
	grpc.ClientStream
}

type queriesGetAccountListClient struct {
	grpc.ClientStream
}

func (x *queriesGetAccountListClient) Recv() (*AccountAddress, error) {
	m := new(AccountAddress)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *queriesClient) GetModuleList(ctx context.Context, in *BlockHashInput, opts ...grpc.CallOption) (Queries_GetModuleListClient, error) {
	stream, err := c.cc.NewStream(ctx, &Queries_ServiceDesc.Streams[3], "/concordium.v2.Queries/GetModuleList", opts...)
	if err != nil {
		return nil, err
	}
	x := &queriesGetModuleListClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Queries_GetModuleListClient interface {
	Recv() (*ModuleRef, error)
	grpc.ClientStream
}

type queriesGetModuleListClient struct {
	grpc.ClientStream
}

func (x *queriesGetModuleListClient) Recv() (*ModuleRef, error) {
	m := new(ModuleRef)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *queriesClient) GetAncestors(ctx context.Context, in *AncestorsRequest, opts ...grpc.CallOption) (Queries_GetAncestorsClient, error) {
	stream, err := c.cc.NewStream(ctx, &Queries_ServiceDesc.Streams[4], "/concordium.v2.Queries/GetAncestors", opts...)
	if err != nil {
		return nil, err
	}
	x := &queriesGetAncestorsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Queries_GetAncestorsClient interface {
	Recv() (*BlockHash, error)
	grpc.ClientStream
}

type queriesGetAncestorsClient struct {
	grpc.ClientStream
}

func (x *queriesGetAncestorsClient) Recv() (*BlockHash, error) {
	m := new(BlockHash)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *queriesClient) GetModuleSource(ctx context.Context, in *ModuleSourceRequest, opts ...grpc.CallOption) (*VersionedModuleSource, error) {
	out := new(VersionedModuleSource)
	err := c.cc.Invoke(ctx, "/concordium.v2.Queries/GetModuleSource", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) GetInstanceList(ctx context.Context, in *BlockHashInput, opts ...grpc.CallOption) (Queries_GetInstanceListClient, error) {
	stream, err := c.cc.NewStream(ctx, &Queries_ServiceDesc.Streams[5], "/concordium.v2.Queries/GetInstanceList", opts...)
	if err != nil {
		return nil, err
	}
	x := &queriesGetInstanceListClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Queries_GetInstanceListClient interface {
	Recv() (*ContractAddress, error)
	grpc.ClientStream
}

type queriesGetInstanceListClient struct {
	grpc.ClientStream
}

func (x *queriesGetInstanceListClient) Recv() (*ContractAddress, error) {
	m := new(ContractAddress)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *queriesClient) GetInstanceInfo(ctx context.Context, in *InstanceInfoRequest, opts ...grpc.CallOption) (*InstanceInfo, error) {
	out := new(InstanceInfo)
	err := c.cc.Invoke(ctx, "/concordium.v2.Queries/GetInstanceInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) GetInstanceState(ctx context.Context, in *InstanceInfoRequest, opts ...grpc.CallOption) (Queries_GetInstanceStateClient, error) {
	stream, err := c.cc.NewStream(ctx, &Queries_ServiceDesc.Streams[6], "/concordium.v2.Queries/GetInstanceState", opts...)
	if err != nil {
		return nil, err
	}
	x := &queriesGetInstanceStateClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Queries_GetInstanceStateClient interface {
	Recv() (*InstanceStateKVPair, error)
	grpc.ClientStream
}

type queriesGetInstanceStateClient struct {
	grpc.ClientStream
}

func (x *queriesGetInstanceStateClient) Recv() (*InstanceStateKVPair, error) {
	m := new(InstanceStateKVPair)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *queriesClient) InstanceStateLookup(ctx context.Context, in *InstanceStateLookupRequest, opts ...grpc.CallOption) (*InstanceStateValueAtKey, error) {
	out := new(InstanceStateValueAtKey)
	err := c.cc.Invoke(ctx, "/concordium.v2.Queries/InstanceStateLookup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) GetNextAccountSequenceNumber(ctx context.Context, in *AccountAddress, opts ...grpc.CallOption) (*NextAccountSequenceNumber, error) {
	out := new(NextAccountSequenceNumber)
	err := c.cc.Invoke(ctx, "/concordium.v2.Queries/GetNextAccountSequenceNumber", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) GetConsensusInfo(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ConsensusInfo, error) {
	out := new(ConsensusInfo)
	err := c.cc.Invoke(ctx, "/concordium.v2.Queries/GetConsensusInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) GetBlockItemStatus(ctx context.Context, in *TransactionHash, opts ...grpc.CallOption) (*BlockItemStatus, error) {
	out := new(BlockItemStatus)
	err := c.cc.Invoke(ctx, "/concordium.v2.Queries/GetBlockItemStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) GetCryptographicParameters(ctx context.Context, in *BlockHashInput, opts ...grpc.CallOption) (*CryptographicParameters, error) {
	out := new(CryptographicParameters)
	err := c.cc.Invoke(ctx, "/concordium.v2.Queries/GetCryptographicParameters", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) GetBlockInfo(ctx context.Context, in *BlockHashInput, opts ...grpc.CallOption) (*BlockInfo, error) {
	out := new(BlockInfo)
	err := c.cc.Invoke(ctx, "/concordium.v2.Queries/GetBlockInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) GetBakerList(ctx context.Context, in *BlockHashInput, opts ...grpc.CallOption) (Queries_GetBakerListClient, error) {
	stream, err := c.cc.NewStream(ctx, &Queries_ServiceDesc.Streams[7], "/concordium.v2.Queries/GetBakerList", opts...)
	if err != nil {
		return nil, err
	}
	x := &queriesGetBakerListClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Queries_GetBakerListClient interface {
	Recv() (*BakerId, error)
	grpc.ClientStream
}

type queriesGetBakerListClient struct {
	grpc.ClientStream
}

func (x *queriesGetBakerListClient) Recv() (*BakerId, error) {
	m := new(BakerId)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *queriesClient) GetPoolInfo(ctx context.Context, in *PoolInfoRequest, opts ...grpc.CallOption) (*PoolInfoResponse, error) {
	out := new(PoolInfoResponse)
	err := c.cc.Invoke(ctx, "/concordium.v2.Queries/GetPoolInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) GetPassiveDelegationInfo(ctx context.Context, in *BlockHashInput, opts ...grpc.CallOption) (*PassiveDelegationInfo, error) {
	out := new(PassiveDelegationInfo)
	err := c.cc.Invoke(ctx, "/concordium.v2.Queries/GetPassiveDelegationInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) GetBlocksAtHeight(ctx context.Context, in *BlocksAtHeightRequest, opts ...grpc.CallOption) (*BlocksAtHeightResponse, error) {
	out := new(BlocksAtHeightResponse)
	err := c.cc.Invoke(ctx, "/concordium.v2.Queries/GetBlocksAtHeight", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) GetTokenomicsInfo(ctx context.Context, in *BlockHashInput, opts ...grpc.CallOption) (*TokenomicsInfo, error) {
	out := new(TokenomicsInfo)
	err := c.cc.Invoke(ctx, "/concordium.v2.Queries/GetTokenomicsInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) InvokeInstance(ctx context.Context, in *InvokeInstanceRequest, opts ...grpc.CallOption) (*InvokeInstanceResponse, error) {
	out := new(InvokeInstanceResponse)
	err := c.cc.Invoke(ctx, "/concordium.v2.Queries/InvokeInstance", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) GetPoolDelegators(ctx context.Context, in *GetPoolDelegatorsRequest, opts ...grpc.CallOption) (Queries_GetPoolDelegatorsClient, error) {
	stream, err := c.cc.NewStream(ctx, &Queries_ServiceDesc.Streams[8], "/concordium.v2.Queries/GetPoolDelegators", opts...)
	if err != nil {
		return nil, err
	}
	x := &queriesGetPoolDelegatorsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Queries_GetPoolDelegatorsClient interface {
	Recv() (*DelegatorInfo, error)
	grpc.ClientStream
}

type queriesGetPoolDelegatorsClient struct {
	grpc.ClientStream
}

func (x *queriesGetPoolDelegatorsClient) Recv() (*DelegatorInfo, error) {
	m := new(DelegatorInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *queriesClient) GetPoolDelegatorsRewardPeriod(ctx context.Context, in *GetPoolDelegatorsRequest, opts ...grpc.CallOption) (Queries_GetPoolDelegatorsRewardPeriodClient, error) {
	stream, err := c.cc.NewStream(ctx, &Queries_ServiceDesc.Streams[9], "/concordium.v2.Queries/GetPoolDelegatorsRewardPeriod", opts...)
	if err != nil {
		return nil, err
	}
	x := &queriesGetPoolDelegatorsRewardPeriodClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Queries_GetPoolDelegatorsRewardPeriodClient interface {
	Recv() (*DelegatorRewardPeriodInfo, error)
	grpc.ClientStream
}

type queriesGetPoolDelegatorsRewardPeriodClient struct {
	grpc.ClientStream
}

func (x *queriesGetPoolDelegatorsRewardPeriodClient) Recv() (*DelegatorRewardPeriodInfo, error) {
	m := new(DelegatorRewardPeriodInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *queriesClient) GetPassiveDelegators(ctx context.Context, in *BlockHashInput, opts ...grpc.CallOption) (Queries_GetPassiveDelegatorsClient, error) {
	stream, err := c.cc.NewStream(ctx, &Queries_ServiceDesc.Streams[10], "/concordium.v2.Queries/GetPassiveDelegators", opts...)
	if err != nil {
		return nil, err
	}
	x := &queriesGetPassiveDelegatorsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Queries_GetPassiveDelegatorsClient interface {
	Recv() (*DelegatorInfo, error)
	grpc.ClientStream
}

type queriesGetPassiveDelegatorsClient struct {
	grpc.ClientStream
}

func (x *queriesGetPassiveDelegatorsClient) Recv() (*DelegatorInfo, error) {
	m := new(DelegatorInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *queriesClient) GetPassiveDelegatorsRewardPeriod(ctx context.Context, in *BlockHashInput, opts ...grpc.CallOption) (Queries_GetPassiveDelegatorsRewardPeriodClient, error) {
	stream, err := c.cc.NewStream(ctx, &Queries_ServiceDesc.Streams[11], "/concordium.v2.Queries/GetPassiveDelegatorsRewardPeriod", opts...)
	if err != nil {
		return nil, err
	}
	x := &queriesGetPassiveDelegatorsRewardPeriodClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Queries_GetPassiveDelegatorsRewardPeriodClient interface {
	Recv() (*DelegatorRewardPeriodInfo, error)
	grpc.ClientStream
}

type queriesGetPassiveDelegatorsRewardPeriodClient struct {
	grpc.ClientStream
}

func (x *queriesGetPassiveDelegatorsRewardPeriodClient) Recv() (*DelegatorRewardPeriodInfo, error) {
	m := new(DelegatorRewardPeriodInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *queriesClient) GetBranches(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Branch, error) {
	out := new(Branch)
	err := c.cc.Invoke(ctx, "/concordium.v2.Queries/GetBranches", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) GetElectionInfo(ctx context.Context, in *BlockHashInput, opts ...grpc.CallOption) (*ElectionInfo, error) {
	out := new(ElectionInfo)
	err := c.cc.Invoke(ctx, "/concordium.v2.Queries/GetElectionInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) GetIdentityProviders(ctx context.Context, in *BlockHashInput, opts ...grpc.CallOption) (Queries_GetIdentityProvidersClient, error) {
	stream, err := c.cc.NewStream(ctx, &Queries_ServiceDesc.Streams[12], "/concordium.v2.Queries/GetIdentityProviders", opts...)
	if err != nil {
		return nil, err
	}
	x := &queriesGetIdentityProvidersClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Queries_GetIdentityProvidersClient interface {
	Recv() (*IpInfo, error)
	grpc.ClientStream
}

type queriesGetIdentityProvidersClient struct {
	grpc.ClientStream
}

func (x *queriesGetIdentityProvidersClient) Recv() (*IpInfo, error) {
	m := new(IpInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *queriesClient) GetAnonymityRevokers(ctx context.Context, in *BlockHashInput, opts ...grpc.CallOption) (Queries_GetAnonymityRevokersClient, error) {
	stream, err := c.cc.NewStream(ctx, &Queries_ServiceDesc.Streams[13], "/concordium.v2.Queries/GetAnonymityRevokers", opts...)
	if err != nil {
		return nil, err
	}
	x := &queriesGetAnonymityRevokersClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Queries_GetAnonymityRevokersClient interface {
	Recv() (*ArInfo, error)
	grpc.ClientStream
}

type queriesGetAnonymityRevokersClient struct {
	grpc.ClientStream
}

func (x *queriesGetAnonymityRevokersClient) Recv() (*ArInfo, error) {
	m := new(ArInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *queriesClient) GetAccountNonFinalizedTransactions(ctx context.Context, in *AccountAddress, opts ...grpc.CallOption) (Queries_GetAccountNonFinalizedTransactionsClient, error) {
	stream, err := c.cc.NewStream(ctx, &Queries_ServiceDesc.Streams[14], "/concordium.v2.Queries/GetAccountNonFinalizedTransactions", opts...)
	if err != nil {
		return nil, err
	}
	x := &queriesGetAccountNonFinalizedTransactionsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Queries_GetAccountNonFinalizedTransactionsClient interface {
	Recv() (*TransactionHash, error)
	grpc.ClientStream
}

type queriesGetAccountNonFinalizedTransactionsClient struct {
	grpc.ClientStream
}

func (x *queriesGetAccountNonFinalizedTransactionsClient) Recv() (*TransactionHash, error) {
	m := new(TransactionHash)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *queriesClient) GetBlockTransactionEvents(ctx context.Context, in *BlockHashInput, opts ...grpc.CallOption) (Queries_GetBlockTransactionEventsClient, error) {
	stream, err := c.cc.NewStream(ctx, &Queries_ServiceDesc.Streams[15], "/concordium.v2.Queries/GetBlockTransactionEvents", opts...)
	if err != nil {
		return nil, err
	}
	x := &queriesGetBlockTransactionEventsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Queries_GetBlockTransactionEventsClient interface {
	Recv() (*BlockItemSummary, error)
	grpc.ClientStream
}

type queriesGetBlockTransactionEventsClient struct {
	grpc.ClientStream
}

func (x *queriesGetBlockTransactionEventsClient) Recv() (*BlockItemSummary, error) {
	m := new(BlockItemSummary)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *queriesClient) GetBlockSpecialEvents(ctx context.Context, in *BlockHashInput, opts ...grpc.CallOption) (Queries_GetBlockSpecialEventsClient, error) {
	stream, err := c.cc.NewStream(ctx, &Queries_ServiceDesc.Streams[16], "/concordium.v2.Queries/GetBlockSpecialEvents", opts...)
	if err != nil {
		return nil, err
	}
	x := &queriesGetBlockSpecialEventsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Queries_GetBlockSpecialEventsClient interface {
	Recv() (*BlockSpecialEvent, error)
	grpc.ClientStream
}

type queriesGetBlockSpecialEventsClient struct {
	grpc.ClientStream
}

func (x *queriesGetBlockSpecialEventsClient) Recv() (*BlockSpecialEvent, error) {
	m := new(BlockSpecialEvent)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *queriesClient) GetBlockPendingUpdates(ctx context.Context, in *BlockHashInput, opts ...grpc.CallOption) (Queries_GetBlockPendingUpdatesClient, error) {
	stream, err := c.cc.NewStream(ctx, &Queries_ServiceDesc.Streams[17], "/concordium.v2.Queries/GetBlockPendingUpdates", opts...)
	if err != nil {
		return nil, err
	}
	x := &queriesGetBlockPendingUpdatesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Queries_GetBlockPendingUpdatesClient interface {
	Recv() (*PendingUpdate, error)
	grpc.ClientStream
}

type queriesGetBlockPendingUpdatesClient struct {
	grpc.ClientStream
}

func (x *queriesGetBlockPendingUpdatesClient) Recv() (*PendingUpdate, error) {
	m := new(PendingUpdate)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *queriesClient) GetNextUpdateSequenceNumbers(ctx context.Context, in *BlockHashInput, opts ...grpc.CallOption) (*NextUpdateSequenceNumbers, error) {
	out := new(NextUpdateSequenceNumbers)
	err := c.cc.Invoke(ctx, "/concordium.v2.Queries/GetNextUpdateSequenceNumbers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) GetBakerEarliestWinTime(ctx context.Context, in *BakerId, opts ...grpc.CallOption) (*Timestamp, error) {
	out := new(Timestamp)
	err := c.cc.Invoke(ctx, "/concordium.v2.Queries/GetBakerEarliestWinTime", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) Shutdown(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/concordium.v2.Queries/Shutdown", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) PeerConnect(ctx context.Context, in *IpSocketAddress, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/concordium.v2.Queries/PeerConnect", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) PeerDisconnect(ctx context.Context, in *IpSocketAddress, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/concordium.v2.Queries/PeerDisconnect", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) GetBannedPeers(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*BannedPeers, error) {
	out := new(BannedPeers)
	err := c.cc.Invoke(ctx, "/concordium.v2.Queries/GetBannedPeers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) BanPeer(ctx context.Context, in *PeerToBan, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/concordium.v2.Queries/BanPeer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) UnbanPeer(ctx context.Context, in *BannedPeer, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/concordium.v2.Queries/UnbanPeer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) DumpStart(ctx context.Context, in *DumpRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/concordium.v2.Queries/DumpStart", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) DumpStop(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/concordium.v2.Queries/DumpStop", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) GetPeersInfo(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*PeersInfo, error) {
	out := new(PeersInfo)
	err := c.cc.Invoke(ctx, "/concordium.v2.Queries/GetPeersInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) GetNodeInfo(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*NodeInfo, error) {
	out := new(NodeInfo)
	err := c.cc.Invoke(ctx, "/concordium.v2.Queries/GetNodeInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) SendBlockItem(ctx context.Context, in *SendBlockItemRequest, opts ...grpc.CallOption) (*TransactionHash, error) {
	out := new(TransactionHash)
	err := c.cc.Invoke(ctx, "/concordium.v2.Queries/SendBlockItem", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) GetAccountTransactionSignHash(ctx context.Context, in *PreAccountTransaction, opts ...grpc.CallOption) (*AccountTransactionSignHash, error) {
	out := new(AccountTransactionSignHash)
	err := c.cc.Invoke(ctx, "/concordium.v2.Queries/GetAccountTransactionSignHash", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) GetBlockChainParameters(ctx context.Context, in *BlockHashInput, opts ...grpc.CallOption) (*ChainParameters, error) {
	out := new(ChainParameters)
	err := c.cc.Invoke(ctx, "/concordium.v2.Queries/GetBlockChainParameters", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) GetBlockFinalizationSummary(ctx context.Context, in *BlockHashInput, opts ...grpc.CallOption) (*BlockFinalizationSummary, error) {
	out := new(BlockFinalizationSummary)
	err := c.cc.Invoke(ctx, "/concordium.v2.Queries/GetBlockFinalizationSummary", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) GetBlockItems(ctx context.Context, in *BlockHashInput, opts ...grpc.CallOption) (Queries_GetBlockItemsClient, error) {
	stream, err := c.cc.NewStream(ctx, &Queries_ServiceDesc.Streams[18], "/concordium.v2.Queries/GetBlockItems", opts...)
	if err != nil {
		return nil, err
	}
	x := &queriesGetBlockItemsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Queries_GetBlockItemsClient interface {
	Recv() (*BlockItem, error)
	grpc.ClientStream
}

type queriesGetBlockItemsClient struct {
	grpc.ClientStream
}

func (x *queriesGetBlockItemsClient) Recv() (*BlockItem, error) {
	m := new(BlockItem)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *queriesClient) GetBakersRewardPeriod(ctx context.Context, in *BlockHashInput, opts ...grpc.CallOption) (Queries_GetBakersRewardPeriodClient, error) {
	stream, err := c.cc.NewStream(ctx, &Queries_ServiceDesc.Streams[19], "/concordium.v2.Queries/GetBakersRewardPeriod", opts...)
	if err != nil {
		return nil, err
	}
	x := &queriesGetBakersRewardPeriodClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Queries_GetBakersRewardPeriodClient interface {
	Recv() (*BakerRewardPeriodInfo, error)
	grpc.ClientStream
}

type queriesGetBakersRewardPeriodClient struct {
	grpc.ClientStream
}

func (x *queriesGetBakersRewardPeriodClient) Recv() (*BakerRewardPeriodInfo, error) {
	m := new(BakerRewardPeriodInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *queriesClient) GetBlockCertificates(ctx context.Context, in *BlockHashInput, opts ...grpc.CallOption) (*BlockCertificates, error) {
	out := new(BlockCertificates)
	err := c.cc.Invoke(ctx, "/concordium.v2.Queries/GetBlockCertificates", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) GetWinningBakersEpoch(ctx context.Context, in *EpochRequest, opts ...grpc.CallOption) (Queries_GetWinningBakersEpochClient, error) {
	stream, err := c.cc.NewStream(ctx, &Queries_ServiceDesc.Streams[20], "/concordium.v2.Queries/GetWinningBakersEpoch", opts...)
	if err != nil {
		return nil, err
	}
	x := &queriesGetWinningBakersEpochClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Queries_GetWinningBakersEpochClient interface {
	Recv() (*WinningBaker, error)
	grpc.ClientStream
}

type queriesGetWinningBakersEpochClient struct {
	grpc.ClientStream
}

func (x *queriesGetWinningBakersEpochClient) Recv() (*WinningBaker, error) {
	m := new(WinningBaker)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *queriesClient) GetFirstBlockEpoch(ctx context.Context, in *EpochRequest, opts ...grpc.CallOption) (*BlockHash, error) {
	out := new(BlockHash)
	err := c.cc.Invoke(ctx, "/concordium.v2.Queries/GetFirstBlockEpoch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) DryRun(ctx context.Context, opts ...grpc.CallOption) (Queries_DryRunClient, error) {
	stream, err := c.cc.NewStream(ctx, &Queries_ServiceDesc.Streams[21], "/concordium.v2.Queries/DryRun", opts...)
	if err != nil {
		return nil, err
	}
	x := &queriesDryRunClient{stream}
	return x, nil
}

type Queries_DryRunClient interface {
	Send(*DryRunRequest) error
	Recv() (*DryRunResponse, error)
	grpc.ClientStream
}

type queriesDryRunClient struct {
	grpc.ClientStream
}

func (x *queriesDryRunClient) Send(m *DryRunRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *queriesDryRunClient) Recv() (*DryRunResponse, error) {
	m := new(DryRunResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// QueriesServer is the server API for Queries service.
// All implementations must embed UnimplementedQueriesServer
// for forward compatibility
type QueriesServer interface {
	// Return a stream of blocks that arrive from the time the query is made onward.
	// This can be used to listen for incoming blocks.
	GetBlocks(*Empty, Queries_GetBlocksServer) error
	// Return a stream of blocks that are finalized from the time the query is
	// made onward. This can be used to listen for newly finalized blocks. Note
	// that there is no guarantee that blocks will not be skipped if the client is
	// too slow in processing the stream, however blocks will always be sent by
	// increasing block height.
	GetFinalizedBlocks(*Empty, Queries_GetFinalizedBlocksServer) error
	// Retrieve the information about the given account in the given block.
	GetAccountInfo(context.Context, *AccountInfoRequest) (*AccountInfo, error)
	// Retrieve the list of accounts that exist at the end of the given block.
	GetAccountList(*BlockHashInput, Queries_GetAccountListServer) error
	// Get a list of all smart contract modules. The stream will end
	// when all modules that exist in the state at the end of the given
	// block have been returned.
	GetModuleList(*BlockHashInput, Queries_GetModuleListServer) error
	// Get a stream of ancestors for the provided block.
	// Starting with the provided block itself, moving backwards until no more
	// ancestors or the requested number of ancestors has been returned.
	GetAncestors(*AncestorsRequest, Queries_GetAncestorsServer) error
	// Get the source of a smart contract module.
	GetModuleSource(context.Context, *ModuleSourceRequest) (*VersionedModuleSource, error)
	// Get a list of addresses for all smart contract instances. The stream
	// will end when all instances that exist in the state at the end of the
	// given block has been returned.
	GetInstanceList(*BlockHashInput, Queries_GetInstanceListServer) error
	// Get info about a smart contract instance as it appears at the end of the
	// given block.
	GetInstanceInfo(context.Context, *InstanceInfoRequest) (*InstanceInfo, error)
	// Get the exact state of a specific contract instance, streamed as a list of
	// key-value pairs. The list is streamed in lexicographic order of keys.
	GetInstanceState(*InstanceInfoRequest, Queries_GetInstanceStateServer) error
	// Get the value at a specific key of a contract state. In contrast to
	// `GetInstanceState` this is more efficient, but requires the user to know
	// the specific key to look for.
	InstanceStateLookup(context.Context, *InstanceStateLookupRequest) (*InstanceStateValueAtKey, error)
	// Get the best guess as to what the next account sequence number should be.
	// If all account transactions are finalized then this information is reliable.
	// Otherwise this is the best guess, assuming all other transactions will be
	// committed to blocks and eventually finalized.
	GetNextAccountSequenceNumber(context.Context, *AccountAddress) (*NextAccountSequenceNumber, error)
	// Get information about the current state of consensus.
	GetConsensusInfo(context.Context, *Empty) (*ConsensusInfo, error)
	// Get the status of and information about a specific block item (transaction).
	GetBlockItemStatus(context.Context, *TransactionHash) (*BlockItemStatus, error)
	// Get the cryptographic parameters in a given block.
	GetCryptographicParameters(context.Context, *BlockHashInput) (*CryptographicParameters, error)
	// Get information, such as height, timings, and transaction counts for the given block.
	GetBlockInfo(context.Context, *BlockHashInput) (*BlockInfo, error)
	// Get all the bakers at the end of the given block.
	GetBakerList(*BlockHashInput, Queries_GetBakerListServer) error
	// Get information about a given pool at the end of a given block.
	GetPoolInfo(context.Context, *PoolInfoRequest) (*PoolInfoResponse, error)
	// Get information about the passive delegators at the end of a given block.
	GetPassiveDelegationInfo(context.Context, *BlockHashInput) (*PassiveDelegationInfo, error)
	// Get a list of live blocks at a given height.
	GetBlocksAtHeight(context.Context, *BlocksAtHeightRequest) (*BlocksAtHeightResponse, error)
	// Get information about tokenomics at the end of a given block.
	GetTokenomicsInfo(context.Context, *BlockHashInput) (*TokenomicsInfo, error)
	// Run the smart contract entrypoint in a given context and in the state at
	// the end of the given block.
	InvokeInstance(context.Context, *InvokeInstanceRequest) (*InvokeInstanceResponse, error)
	// Get the registered delegators of a given pool at the end of a given block.
	// In contrast to the `GetPoolDelegatorsRewardPeriod` which returns delegators
	// that are fixed for the reward period of the block, this endpoint returns the
	// list of delegators that are registered in the block. Any changes to delegators
	// are immediately visible in this list.
	// The stream will end when all the delegators has been returned.
	GetPoolDelegators(*GetPoolDelegatorsRequest, Queries_GetPoolDelegatorsServer) error
	// Get the fixed delegators of a given pool for the reward period of the given block.
	// In contracts to the `GetPoolDelegators` which returns delegators registered
	// for the given block, this endpoint returns the fixed delegators contributing
	// stake in the reward period containing the given block.
	// The stream will end when all the delegators has been returned.
	GetPoolDelegatorsRewardPeriod(*GetPoolDelegatorsRequest, Queries_GetPoolDelegatorsRewardPeriodServer) error
	// Get the registered passive delegators at the end of a given block.
	// In contrast to the `GetPassiveDelegatorsRewardPeriod` which returns delegators
	// that are fixed for the reward period of the block, this endpoint returns the
	// list of delegators that are registered in the block. Any changes to delegators
	// are immediately visible in this list.
	// The stream will end when all the delegators has been returned.
	GetPassiveDelegators(*BlockHashInput, Queries_GetPassiveDelegatorsServer) error
	// Get the fixed passive delegators for the reward period of the given block.
	// In contracts to the `GetPassiveDelegators` which returns delegators registered
	// for the given block, this endpoint returns the fixed delegators contributing
	// stake in the reward period containing the given block.
	// The stream will end when all the delegators has been returned.
	GetPassiveDelegatorsRewardPeriod(*BlockHashInput, Queries_GetPassiveDelegatorsRewardPeriodServer) error
	// Get the current branches of blocks starting from and including the last finalized block.
	GetBranches(context.Context, *Empty) (*Branch, error)
	// Get information related to the baker election for a particular block.
	GetElectionInfo(context.Context, *BlockHashInput) (*ElectionInfo, error)
	// Get the identity providers registered as of the end of a given block.
	// The stream will end when all the identity providers have been returned.
	GetIdentityProviders(*BlockHashInput, Queries_GetIdentityProvidersServer) error
	// Get the anonymity revokers registered as of the end of a given block.
	// The stream will end when all the anonymity revokers have been returned.
	GetAnonymityRevokers(*BlockHashInput, Queries_GetAnonymityRevokersServer) error
	// Get a list of non-finalized transaction hashes for a given account. This
	// endpoint is not expected to return a large amount of data in most cases,
	// but in bad network condtions it might. The stream will end when all the
	// non-finalized transaction hashes have been returned.
	GetAccountNonFinalizedTransactions(*AccountAddress, Queries_GetAccountNonFinalizedTransactionsServer) error
	// Get a list of transaction events in a given block.
	// The stream will end when all the transaction events for a given block have been returned.
	GetBlockTransactionEvents(*BlockHashInput, Queries_GetBlockTransactionEventsServer) error
	// Get a list of special events in a given block. These are events generated
	// by the protocol, such as minting and reward payouts. They are not directly
	// generated by any transaction. The stream will end when all the special
	// events for a given block have been returned.
	GetBlockSpecialEvents(*BlockHashInput, Queries_GetBlockSpecialEventsServer) error
	// Get the pending updates to chain parameters at the end of a given block.
	// The stream will end when all the pending updates for a given block have been returned.
	GetBlockPendingUpdates(*BlockHashInput, Queries_GetBlockPendingUpdatesServer) error
	// Get next available sequence numbers for updating chain parameters after a given block.
	GetNextUpdateSequenceNumbers(context.Context, *BlockHashInput) (*NextUpdateSequenceNumbers, error)
	// Get the projected earliest time at which a particular baker will be required to bake a block.
	// If the current consensus version is 0, this returns the status 'Unavailable', as the endpoint
	// is only supported by consensus version 1.
	//
	// If the baker is not a baker for the current reward period, this returns a timestamp at the
	// start of the next reward period. If the baker is a baker for the current reward period, the
	// earliest win time is projected from the current round forward, assuming that each round after
	// the last finalized round will take the minimum block time. (If blocks take longer, or timeouts
	// occur, the actual time may be later, and the reported time in subsequent queries may reflect
	// this.) At the end of an epoch (or if the baker is not projected to bake before the end of the
	// epoch) the earliest win time for a (current) baker will be projected as the start of the next
	// epoch. This is because the seed for the leader election is updated at the epoch boundary, and
	// so the winners cannot be predicted beyond that. Note that in some circumstances the returned
	// timestamp can be in the past, especially at the end of an epoch.
	GetBakerEarliestWinTime(context.Context, *BakerId) (*Timestamp, error)
	// Shut down the node.
	// Return a GRPC error if the shutdown failed.
	Shutdown(context.Context, *Empty) (*Empty, error)
	// Suggest to a peer to connect to the submitted peer details.
	// This, if successful, adds the peer to the list of given addresses.
	// Otherwise return a GRPC error.
	// Note. The peer might not be connected to instantly, in that case
	// the node will try to establish the connection in near future. This
	// function returns a GRPC status 'Ok' in this case.
	PeerConnect(context.Context, *IpSocketAddress) (*Empty, error)
	// Disconnect from the peer and remove them from the given addresses list
	// if they are on it. Return if the request was processed successfully.
	// Otherwise return a GRPC error.
	PeerDisconnect(context.Context, *IpSocketAddress) (*Empty, error)
	// Get a list of banned peers.
	GetBannedPeers(context.Context, *Empty) (*BannedPeers, error)
	// Ban the given peer.
	// Returns a GRPC error if the action failed.
	BanPeer(context.Context, *PeerToBan) (*Empty, error)
	// Unban the banned peer.
	// Returns a GRPC error if the action failed.
	UnbanPeer(context.Context, *BannedPeer) (*Empty, error)
	// Start dumping packages into the specified file.
	// Only enabled if the node was built with the `network_dump` feature.
	// Returns a GRPC error if the network dump failed to start.
	DumpStart(context.Context, *DumpRequest) (*Empty, error)
	// Stop dumping packages.
	// Only enabled if the node was built with the `network_dump` feature.
	// Returns a GRPC error if the network dump failed to be stopped.
	DumpStop(context.Context, *Empty) (*Empty, error)
	// / Get a list of the peers that the node is connected to
	// / and assoicated network related information for each peer.
	GetPeersInfo(context.Context, *Empty) (*PeersInfo, error)
	// Get information about the node.
	// The `NodeInfo` includes information of
	//   - Meta information such as the, version of the node, type of the node, uptime and the local time of the node.
	//   - NetworkInfo which yields data such as the node id, packets sent/received,
	//     average bytes per second sent/received.
	//   - ConsensusInfo. The `ConsensusInfo` returned depends on if the node supports
	//     the protocol on chain and whether the node is configured as a baker or not.
	GetNodeInfo(context.Context, *Empty) (*NodeInfo, error)
	// Send a block item. A block item is either an `AccountTransaction`, which is
	// a transaction signed and paid for by an account, a `CredentialDeployment`,
	// which creates a new account, or `UpdateInstruction`, which is an
	// instruction to change some parameters of the chain. Update instructions can
	// only be sent by the governance committee.
	//
	// Returns a hash of the block item, which can be used with
	// `GetBlockItemStatus`.
	SendBlockItem(context.Context, *SendBlockItemRequest) (*TransactionHash, error)
	// Get the hash to be signed for an account transaction. The hash returned
	// should be signed and the signatures included as an
	// AccountTransactionSignature when calling `SendBlockItem`. This is provided as
	// a convenience to support cases where the right SDK is not available for
	// interacting with the node. If an SDK is available then it is strongly
	// recommended to compute this hash off-line using it. That reduces the trust
	// in the node, removes networking failure modes, and will perform better.
	GetAccountTransactionSignHash(context.Context, *PreAccountTransaction) (*AccountTransactionSignHash, error)
	// Get the values of chain parameters in effect in the given block.
	GetBlockChainParameters(context.Context, *BlockHashInput) (*ChainParameters, error)
	// Get the summary of the finalization data in a given block.
	GetBlockFinalizationSummary(context.Context, *BlockHashInput) (*BlockFinalizationSummary, error)
	// Get the items of a block.
	GetBlockItems(*BlockHashInput, Queries_GetBlockItemsServer) error
	// Get all bakers in the reward period of a block.
	// This endpoint is only supported for protocol version 6 and onwards.
	// If the protocol does not support the endpoint then an  'IllegalArgument' error is returned.
	GetBakersRewardPeriod(*BlockHashInput, Queries_GetBakersRewardPeriodServer) error
	// For a non-genesis block, this returns the quorum certificate, a timeout
	// certificate (if present) and epoch finalization entry (if present).
	// Note that, if the block being pointed to is not a product of ConcordiumBFT,
	// then the response will be a grpc error (invalid argument).
	// If the endpoint is not enabled by the node, then an 'unimplemented' error
	// will be returned.
	GetBlockCertificates(context.Context, *BlockHashInput) (*BlockCertificates, error)
	// Get the list of bakers that won the lottery in a particular historical epoch (i.e. the
	// last finalized block is in a later epoch). This lists the winners for each round in the
	// epoch, starting from the round after the last block in the previous epoch, running to
	// the round before the first block in the next epoch. It also indicates if a block in each
	// round was included in the finalized chain.
	//
	// The following error cases are possible:
	//   - `NOT_FOUND` if the query specifies an unknown block.
	//   - `UNAVAILABLE` if the query is for an epoch that is not finalized in the current genesis
	//
	// /    index, or is for a future genesis index.
	//   - `INVALID_ARGUMENT` if the query is for an epoch that is not finalized for a past genesis
	//     index.
	//   - `INVALID_ARGUMENT` if the query is for a genesis index at consensus version 0.
	//   - `INVALID_ARGUMENT` if the input `EpochRequest` is malformed.
	//   - `UNIMPLEMENTED` if the endpoint is disabled on the node.
	GetWinningBakersEpoch(*EpochRequest, Queries_GetWinningBakersEpochServer) error
	// Get the block hash of the first finalized block in a specified epoch.
	//
	// The following error cases are possible:
	//   - `NOT_FOUND` if the query specifies an unknown block.
	//   - `UNAVAILABLE` if the query is for an epoch that is not finalized in the current genesis
	//     index, or is for a future genesis index.
	//   - `INVALID_ARGUMENT` if the query is for an epoch with no finalized blocks for a past genesis
	//     index.
	//   - `INVALID_ARGUMENT` if the input `EpochRequest` is malformed.
	//   - `UNIMPLEMENTED` if the endpoint is disabled on the node.
	GetFirstBlockEpoch(context.Context, *EpochRequest) (*BlockHash, error)
	// Dry run a series of transactions and operations on a state derived from a specified block.
	// The server should send a single `DryRunResponse` for each `DryRunRequest` received, unless
	// the call fails with an error status code. If a request produces a `DryRunErrorResponse`, then
	// the server will still process subsequent requests, just as if the request causing the error
	// did not happen.
	//
	// The first request should be `load_block_at_state` to determine the block state that will be
	// used for the dry run.
	//
	// The server associates each request with an energy cost, and limits the total energy that may
	// be expended in a single invocation of `DryRun`. This limit is reported as `quota` in the
	// initial metadata returned by the server. If executing an operation exceeds the limit,
	// the server terminates the session with `RESOURCE_EXHAUSTED`.
	//
	// The server also imposes a timeout for a dry-run session to complete. The server reports
	// the timeout duration in milliseconds in the initial metadata field `timeout`. If the session
	// is not completed before the timeout elapses, the server terminates the session with
	// `DEADLINE_EXCEEDED`.
	//
	// The following error cases are possible:
	//   - `INVALID_ARGUMENT` if any `DryRunRequest` is malformed.
	//   - `RESOURCE_EXHAUSTED` if the energy quota is exceeded.
	//   - `DEADLINE_EXCEEDED` if the session does not complete before the server-imposed timeout.
	//   - `RESOURCE_EXHAUSTED` if the server is not currently accepting new `DryRun` sessions.
	//     (The server may impose a limit on the number of concurrent sessions.)
	//   - `INTERNAL` if an interal server error occurs. This should not happen, and likely indicates
	//     a bug.
	//   - `UNIMPLEMENTED` if the endpoint is disabled on the node.
	DryRun(Queries_DryRunServer) error
	mustEmbedUnimplementedQueriesServer()
}

// UnimplementedQueriesServer must be embedded to have forward compatible implementations.
type UnimplementedQueriesServer struct {
}

func (UnimplementedQueriesServer) GetBlocks(*Empty, Queries_GetBlocksServer) error {
	return status.Errorf(codes.Unimplemented, "method GetBlocks not implemented")
}
func (UnimplementedQueriesServer) GetFinalizedBlocks(*Empty, Queries_GetFinalizedBlocksServer) error {
	return status.Errorf(codes.Unimplemented, "method GetFinalizedBlocks not implemented")
}
func (UnimplementedQueriesServer) GetAccountInfo(context.Context, *AccountInfoRequest) (*AccountInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAccountInfo not implemented")
}
func (UnimplementedQueriesServer) GetAccountList(*BlockHashInput, Queries_GetAccountListServer) error {
	return status.Errorf(codes.Unimplemented, "method GetAccountList not implemented")
}
func (UnimplementedQueriesServer) GetModuleList(*BlockHashInput, Queries_GetModuleListServer) error {
	return status.Errorf(codes.Unimplemented, "method GetModuleList not implemented")
}
func (UnimplementedQueriesServer) GetAncestors(*AncestorsRequest, Queries_GetAncestorsServer) error {
	return status.Errorf(codes.Unimplemented, "method GetAncestors not implemented")
}
func (UnimplementedQueriesServer) GetModuleSource(context.Context, *ModuleSourceRequest) (*VersionedModuleSource, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetModuleSource not implemented")
}
func (UnimplementedQueriesServer) GetInstanceList(*BlockHashInput, Queries_GetInstanceListServer) error {
	return status.Errorf(codes.Unimplemented, "method GetInstanceList not implemented")
}
func (UnimplementedQueriesServer) GetInstanceInfo(context.Context, *InstanceInfoRequest) (*InstanceInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetInstanceInfo not implemented")
}
func (UnimplementedQueriesServer) GetInstanceState(*InstanceInfoRequest, Queries_GetInstanceStateServer) error {
	return status.Errorf(codes.Unimplemented, "method GetInstanceState not implemented")
}
func (UnimplementedQueriesServer) InstanceStateLookup(context.Context, *InstanceStateLookupRequest) (*InstanceStateValueAtKey, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InstanceStateLookup not implemented")
}
func (UnimplementedQueriesServer) GetNextAccountSequenceNumber(context.Context, *AccountAddress) (*NextAccountSequenceNumber, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNextAccountSequenceNumber not implemented")
}
func (UnimplementedQueriesServer) GetConsensusInfo(context.Context, *Empty) (*ConsensusInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetConsensusInfo not implemented")
}
func (UnimplementedQueriesServer) GetBlockItemStatus(context.Context, *TransactionHash) (*BlockItemStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBlockItemStatus not implemented")
}
func (UnimplementedQueriesServer) GetCryptographicParameters(context.Context, *BlockHashInput) (*CryptographicParameters, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCryptographicParameters not implemented")
}
func (UnimplementedQueriesServer) GetBlockInfo(context.Context, *BlockHashInput) (*BlockInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBlockInfo not implemented")
}
func (UnimplementedQueriesServer) GetBakerList(*BlockHashInput, Queries_GetBakerListServer) error {
	return status.Errorf(codes.Unimplemented, "method GetBakerList not implemented")
}
func (UnimplementedQueriesServer) GetPoolInfo(context.Context, *PoolInfoRequest) (*PoolInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPoolInfo not implemented")
}
func (UnimplementedQueriesServer) GetPassiveDelegationInfo(context.Context, *BlockHashInput) (*PassiveDelegationInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPassiveDelegationInfo not implemented")
}
func (UnimplementedQueriesServer) GetBlocksAtHeight(context.Context, *BlocksAtHeightRequest) (*BlocksAtHeightResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBlocksAtHeight not implemented")
}
func (UnimplementedQueriesServer) GetTokenomicsInfo(context.Context, *BlockHashInput) (*TokenomicsInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTokenomicsInfo not implemented")
}
func (UnimplementedQueriesServer) InvokeInstance(context.Context, *InvokeInstanceRequest) (*InvokeInstanceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InvokeInstance not implemented")
}
func (UnimplementedQueriesServer) GetPoolDelegators(*GetPoolDelegatorsRequest, Queries_GetPoolDelegatorsServer) error {
	return status.Errorf(codes.Unimplemented, "method GetPoolDelegators not implemented")
}
func (UnimplementedQueriesServer) GetPoolDelegatorsRewardPeriod(*GetPoolDelegatorsRequest, Queries_GetPoolDelegatorsRewardPeriodServer) error {
	return status.Errorf(codes.Unimplemented, "method GetPoolDelegatorsRewardPeriod not implemented")
}
func (UnimplementedQueriesServer) GetPassiveDelegators(*BlockHashInput, Queries_GetPassiveDelegatorsServer) error {
	return status.Errorf(codes.Unimplemented, "method GetPassiveDelegators not implemented")
}
func (UnimplementedQueriesServer) GetPassiveDelegatorsRewardPeriod(*BlockHashInput, Queries_GetPassiveDelegatorsRewardPeriodServer) error {
	return status.Errorf(codes.Unimplemented, "method GetPassiveDelegatorsRewardPeriod not implemented")
}
func (UnimplementedQueriesServer) GetBranches(context.Context, *Empty) (*Branch, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBranches not implemented")
}
func (UnimplementedQueriesServer) GetElectionInfo(context.Context, *BlockHashInput) (*ElectionInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetElectionInfo not implemented")
}
func (UnimplementedQueriesServer) GetIdentityProviders(*BlockHashInput, Queries_GetIdentityProvidersServer) error {
	return status.Errorf(codes.Unimplemented, "method GetIdentityProviders not implemented")
}
func (UnimplementedQueriesServer) GetAnonymityRevokers(*BlockHashInput, Queries_GetAnonymityRevokersServer) error {
	return status.Errorf(codes.Unimplemented, "method GetAnonymityRevokers not implemented")
}
func (UnimplementedQueriesServer) GetAccountNonFinalizedTransactions(*AccountAddress, Queries_GetAccountNonFinalizedTransactionsServer) error {
	return status.Errorf(codes.Unimplemented, "method GetAccountNonFinalizedTransactions not implemented")
}
func (UnimplementedQueriesServer) GetBlockTransactionEvents(*BlockHashInput, Queries_GetBlockTransactionEventsServer) error {
	return status.Errorf(codes.Unimplemented, "method GetBlockTransactionEvents not implemented")
}
func (UnimplementedQueriesServer) GetBlockSpecialEvents(*BlockHashInput, Queries_GetBlockSpecialEventsServer) error {
	return status.Errorf(codes.Unimplemented, "method GetBlockSpecialEvents not implemented")
}
func (UnimplementedQueriesServer) GetBlockPendingUpdates(*BlockHashInput, Queries_GetBlockPendingUpdatesServer) error {
	return status.Errorf(codes.Unimplemented, "method GetBlockPendingUpdates not implemented")
}
func (UnimplementedQueriesServer) GetNextUpdateSequenceNumbers(context.Context, *BlockHashInput) (*NextUpdateSequenceNumbers, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNextUpdateSequenceNumbers not implemented")
}
func (UnimplementedQueriesServer) GetBakerEarliestWinTime(context.Context, *BakerId) (*Timestamp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBakerEarliestWinTime not implemented")
}
func (UnimplementedQueriesServer) Shutdown(context.Context, *Empty) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Shutdown not implemented")
}
func (UnimplementedQueriesServer) PeerConnect(context.Context, *IpSocketAddress) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PeerConnect not implemented")
}
func (UnimplementedQueriesServer) PeerDisconnect(context.Context, *IpSocketAddress) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PeerDisconnect not implemented")
}
func (UnimplementedQueriesServer) GetBannedPeers(context.Context, *Empty) (*BannedPeers, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBannedPeers not implemented")
}
func (UnimplementedQueriesServer) BanPeer(context.Context, *PeerToBan) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BanPeer not implemented")
}
func (UnimplementedQueriesServer) UnbanPeer(context.Context, *BannedPeer) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnbanPeer not implemented")
}
func (UnimplementedQueriesServer) DumpStart(context.Context, *DumpRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DumpStart not implemented")
}
func (UnimplementedQueriesServer) DumpStop(context.Context, *Empty) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DumpStop not implemented")
}
func (UnimplementedQueriesServer) GetPeersInfo(context.Context, *Empty) (*PeersInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPeersInfo not implemented")
}
func (UnimplementedQueriesServer) GetNodeInfo(context.Context, *Empty) (*NodeInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNodeInfo not implemented")
}
func (UnimplementedQueriesServer) SendBlockItem(context.Context, *SendBlockItemRequest) (*TransactionHash, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendBlockItem not implemented")
}
func (UnimplementedQueriesServer) GetAccountTransactionSignHash(context.Context, *PreAccountTransaction) (*AccountTransactionSignHash, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAccountTransactionSignHash not implemented")
}
func (UnimplementedQueriesServer) GetBlockChainParameters(context.Context, *BlockHashInput) (*ChainParameters, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBlockChainParameters not implemented")
}
func (UnimplementedQueriesServer) GetBlockFinalizationSummary(context.Context, *BlockHashInput) (*BlockFinalizationSummary, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBlockFinalizationSummary not implemented")
}
func (UnimplementedQueriesServer) GetBlockItems(*BlockHashInput, Queries_GetBlockItemsServer) error {
	return status.Errorf(codes.Unimplemented, "method GetBlockItems not implemented")
}
func (UnimplementedQueriesServer) GetBakersRewardPeriod(*BlockHashInput, Queries_GetBakersRewardPeriodServer) error {
	return status.Errorf(codes.Unimplemented, "method GetBakersRewardPeriod not implemented")
}
func (UnimplementedQueriesServer) GetBlockCertificates(context.Context, *BlockHashInput) (*BlockCertificates, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBlockCertificates not implemented")
}
func (UnimplementedQueriesServer) GetWinningBakersEpoch(*EpochRequest, Queries_GetWinningBakersEpochServer) error {
	return status.Errorf(codes.Unimplemented, "method GetWinningBakersEpoch not implemented")
}
func (UnimplementedQueriesServer) GetFirstBlockEpoch(context.Context, *EpochRequest) (*BlockHash, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFirstBlockEpoch not implemented")
}
func (UnimplementedQueriesServer) DryRun(Queries_DryRunServer) error {
	return status.Errorf(codes.Unimplemented, "method DryRun not implemented")
}
func (UnimplementedQueriesServer) mustEmbedUnimplementedQueriesServer() {}

// UnsafeQueriesServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to QueriesServer will
// result in compilation errors.
type UnsafeQueriesServer interface {
	mustEmbedUnimplementedQueriesServer()
}

func RegisterQueriesServer(s grpc.ServiceRegistrar, srv QueriesServer) {
	s.RegisterService(&Queries_ServiceDesc, srv)
}

func _Queries_GetBlocks_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueriesServer).GetBlocks(m, &queriesGetBlocksServer{stream})
}

type Queries_GetBlocksServer interface {
	Send(*ArrivedBlockInfo) error
	grpc.ServerStream
}

type queriesGetBlocksServer struct {
	grpc.ServerStream
}

func (x *queriesGetBlocksServer) Send(m *ArrivedBlockInfo) error {
	return x.ServerStream.SendMsg(m)
}

func _Queries_GetFinalizedBlocks_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueriesServer).GetFinalizedBlocks(m, &queriesGetFinalizedBlocksServer{stream})
}

type Queries_GetFinalizedBlocksServer interface {
	Send(*FinalizedBlockInfo) error
	grpc.ServerStream
}

type queriesGetFinalizedBlocksServer struct {
	grpc.ServerStream
}

func (x *queriesGetFinalizedBlocksServer) Send(m *FinalizedBlockInfo) error {
	return x.ServerStream.SendMsg(m)
}

func _Queries_GetAccountInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccountInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).GetAccountInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.v2.Queries/GetAccountInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).GetAccountInfo(ctx, req.(*AccountInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_GetAccountList_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(BlockHashInput)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueriesServer).GetAccountList(m, &queriesGetAccountListServer{stream})
}

type Queries_GetAccountListServer interface {
	Send(*AccountAddress) error
	grpc.ServerStream
}

type queriesGetAccountListServer struct {
	grpc.ServerStream
}

func (x *queriesGetAccountListServer) Send(m *AccountAddress) error {
	return x.ServerStream.SendMsg(m)
}

func _Queries_GetModuleList_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(BlockHashInput)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueriesServer).GetModuleList(m, &queriesGetModuleListServer{stream})
}

type Queries_GetModuleListServer interface {
	Send(*ModuleRef) error
	grpc.ServerStream
}

type queriesGetModuleListServer struct {
	grpc.ServerStream
}

func (x *queriesGetModuleListServer) Send(m *ModuleRef) error {
	return x.ServerStream.SendMsg(m)
}

func _Queries_GetAncestors_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(AncestorsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueriesServer).GetAncestors(m, &queriesGetAncestorsServer{stream})
}

type Queries_GetAncestorsServer interface {
	Send(*BlockHash) error
	grpc.ServerStream
}

type queriesGetAncestorsServer struct {
	grpc.ServerStream
}

func (x *queriesGetAncestorsServer) Send(m *BlockHash) error {
	return x.ServerStream.SendMsg(m)
}

func _Queries_GetModuleSource_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ModuleSourceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).GetModuleSource(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.v2.Queries/GetModuleSource",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).GetModuleSource(ctx, req.(*ModuleSourceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_GetInstanceList_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(BlockHashInput)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueriesServer).GetInstanceList(m, &queriesGetInstanceListServer{stream})
}

type Queries_GetInstanceListServer interface {
	Send(*ContractAddress) error
	grpc.ServerStream
}

type queriesGetInstanceListServer struct {
	grpc.ServerStream
}

func (x *queriesGetInstanceListServer) Send(m *ContractAddress) error {
	return x.ServerStream.SendMsg(m)
}

func _Queries_GetInstanceInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InstanceInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).GetInstanceInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.v2.Queries/GetInstanceInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).GetInstanceInfo(ctx, req.(*InstanceInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_GetInstanceState_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(InstanceInfoRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueriesServer).GetInstanceState(m, &queriesGetInstanceStateServer{stream})
}

type Queries_GetInstanceStateServer interface {
	Send(*InstanceStateKVPair) error
	grpc.ServerStream
}

type queriesGetInstanceStateServer struct {
	grpc.ServerStream
}

func (x *queriesGetInstanceStateServer) Send(m *InstanceStateKVPair) error {
	return x.ServerStream.SendMsg(m)
}

func _Queries_InstanceStateLookup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InstanceStateLookupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).InstanceStateLookup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.v2.Queries/InstanceStateLookup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).InstanceStateLookup(ctx, req.(*InstanceStateLookupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_GetNextAccountSequenceNumber_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccountAddress)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).GetNextAccountSequenceNumber(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.v2.Queries/GetNextAccountSequenceNumber",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).GetNextAccountSequenceNumber(ctx, req.(*AccountAddress))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_GetConsensusInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).GetConsensusInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.v2.Queries/GetConsensusInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).GetConsensusInfo(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_GetBlockItemStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TransactionHash)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).GetBlockItemStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.v2.Queries/GetBlockItemStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).GetBlockItemStatus(ctx, req.(*TransactionHash))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_GetCryptographicParameters_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlockHashInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).GetCryptographicParameters(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.v2.Queries/GetCryptographicParameters",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).GetCryptographicParameters(ctx, req.(*BlockHashInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_GetBlockInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlockHashInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).GetBlockInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.v2.Queries/GetBlockInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).GetBlockInfo(ctx, req.(*BlockHashInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_GetBakerList_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(BlockHashInput)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueriesServer).GetBakerList(m, &queriesGetBakerListServer{stream})
}

type Queries_GetBakerListServer interface {
	Send(*BakerId) error
	grpc.ServerStream
}

type queriesGetBakerListServer struct {
	grpc.ServerStream
}

func (x *queriesGetBakerListServer) Send(m *BakerId) error {
	return x.ServerStream.SendMsg(m)
}

func _Queries_GetPoolInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PoolInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).GetPoolInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.v2.Queries/GetPoolInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).GetPoolInfo(ctx, req.(*PoolInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_GetPassiveDelegationInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlockHashInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).GetPassiveDelegationInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.v2.Queries/GetPassiveDelegationInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).GetPassiveDelegationInfo(ctx, req.(*BlockHashInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_GetBlocksAtHeight_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlocksAtHeightRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).GetBlocksAtHeight(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.v2.Queries/GetBlocksAtHeight",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).GetBlocksAtHeight(ctx, req.(*BlocksAtHeightRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_GetTokenomicsInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlockHashInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).GetTokenomicsInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.v2.Queries/GetTokenomicsInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).GetTokenomicsInfo(ctx, req.(*BlockHashInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_InvokeInstance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InvokeInstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).InvokeInstance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.v2.Queries/InvokeInstance",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).InvokeInstance(ctx, req.(*InvokeInstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_GetPoolDelegators_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetPoolDelegatorsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueriesServer).GetPoolDelegators(m, &queriesGetPoolDelegatorsServer{stream})
}

type Queries_GetPoolDelegatorsServer interface {
	Send(*DelegatorInfo) error
	grpc.ServerStream
}

type queriesGetPoolDelegatorsServer struct {
	grpc.ServerStream
}

func (x *queriesGetPoolDelegatorsServer) Send(m *DelegatorInfo) error {
	return x.ServerStream.SendMsg(m)
}

func _Queries_GetPoolDelegatorsRewardPeriod_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetPoolDelegatorsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueriesServer).GetPoolDelegatorsRewardPeriod(m, &queriesGetPoolDelegatorsRewardPeriodServer{stream})
}

type Queries_GetPoolDelegatorsRewardPeriodServer interface {
	Send(*DelegatorRewardPeriodInfo) error
	grpc.ServerStream
}

type queriesGetPoolDelegatorsRewardPeriodServer struct {
	grpc.ServerStream
}

func (x *queriesGetPoolDelegatorsRewardPeriodServer) Send(m *DelegatorRewardPeriodInfo) error {
	return x.ServerStream.SendMsg(m)
}

func _Queries_GetPassiveDelegators_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(BlockHashInput)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueriesServer).GetPassiveDelegators(m, &queriesGetPassiveDelegatorsServer{stream})
}

type Queries_GetPassiveDelegatorsServer interface {
	Send(*DelegatorInfo) error
	grpc.ServerStream
}

type queriesGetPassiveDelegatorsServer struct {
	grpc.ServerStream
}

func (x *queriesGetPassiveDelegatorsServer) Send(m *DelegatorInfo) error {
	return x.ServerStream.SendMsg(m)
}

func _Queries_GetPassiveDelegatorsRewardPeriod_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(BlockHashInput)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueriesServer).GetPassiveDelegatorsRewardPeriod(m, &queriesGetPassiveDelegatorsRewardPeriodServer{stream})
}

type Queries_GetPassiveDelegatorsRewardPeriodServer interface {
	Send(*DelegatorRewardPeriodInfo) error
	grpc.ServerStream
}

type queriesGetPassiveDelegatorsRewardPeriodServer struct {
	grpc.ServerStream
}

func (x *queriesGetPassiveDelegatorsRewardPeriodServer) Send(m *DelegatorRewardPeriodInfo) error {
	return x.ServerStream.SendMsg(m)
}

func _Queries_GetBranches_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).GetBranches(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.v2.Queries/GetBranches",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).GetBranches(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_GetElectionInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlockHashInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).GetElectionInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.v2.Queries/GetElectionInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).GetElectionInfo(ctx, req.(*BlockHashInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_GetIdentityProviders_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(BlockHashInput)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueriesServer).GetIdentityProviders(m, &queriesGetIdentityProvidersServer{stream})
}

type Queries_GetIdentityProvidersServer interface {
	Send(*IpInfo) error
	grpc.ServerStream
}

type queriesGetIdentityProvidersServer struct {
	grpc.ServerStream
}

func (x *queriesGetIdentityProvidersServer) Send(m *IpInfo) error {
	return x.ServerStream.SendMsg(m)
}

func _Queries_GetAnonymityRevokers_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(BlockHashInput)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueriesServer).GetAnonymityRevokers(m, &queriesGetAnonymityRevokersServer{stream})
}

type Queries_GetAnonymityRevokersServer interface {
	Send(*ArInfo) error
	grpc.ServerStream
}

type queriesGetAnonymityRevokersServer struct {
	grpc.ServerStream
}

func (x *queriesGetAnonymityRevokersServer) Send(m *ArInfo) error {
	return x.ServerStream.SendMsg(m)
}

func _Queries_GetAccountNonFinalizedTransactions_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(AccountAddress)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueriesServer).GetAccountNonFinalizedTransactions(m, &queriesGetAccountNonFinalizedTransactionsServer{stream})
}

type Queries_GetAccountNonFinalizedTransactionsServer interface {
	Send(*TransactionHash) error
	grpc.ServerStream
}

type queriesGetAccountNonFinalizedTransactionsServer struct {
	grpc.ServerStream
}

func (x *queriesGetAccountNonFinalizedTransactionsServer) Send(m *TransactionHash) error {
	return x.ServerStream.SendMsg(m)
}

func _Queries_GetBlockTransactionEvents_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(BlockHashInput)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueriesServer).GetBlockTransactionEvents(m, &queriesGetBlockTransactionEventsServer{stream})
}

type Queries_GetBlockTransactionEventsServer interface {
	Send(*BlockItemSummary) error
	grpc.ServerStream
}

type queriesGetBlockTransactionEventsServer struct {
	grpc.ServerStream
}

func (x *queriesGetBlockTransactionEventsServer) Send(m *BlockItemSummary) error {
	return x.ServerStream.SendMsg(m)
}

func _Queries_GetBlockSpecialEvents_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(BlockHashInput)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueriesServer).GetBlockSpecialEvents(m, &queriesGetBlockSpecialEventsServer{stream})
}

type Queries_GetBlockSpecialEventsServer interface {
	Send(*BlockSpecialEvent) error
	grpc.ServerStream
}

type queriesGetBlockSpecialEventsServer struct {
	grpc.ServerStream
}

func (x *queriesGetBlockSpecialEventsServer) Send(m *BlockSpecialEvent) error {
	return x.ServerStream.SendMsg(m)
}

func _Queries_GetBlockPendingUpdates_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(BlockHashInput)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueriesServer).GetBlockPendingUpdates(m, &queriesGetBlockPendingUpdatesServer{stream})
}

type Queries_GetBlockPendingUpdatesServer interface {
	Send(*PendingUpdate) error
	grpc.ServerStream
}

type queriesGetBlockPendingUpdatesServer struct {
	grpc.ServerStream
}

func (x *queriesGetBlockPendingUpdatesServer) Send(m *PendingUpdate) error {
	return x.ServerStream.SendMsg(m)
}

func _Queries_GetNextUpdateSequenceNumbers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlockHashInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).GetNextUpdateSequenceNumbers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.v2.Queries/GetNextUpdateSequenceNumbers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).GetNextUpdateSequenceNumbers(ctx, req.(*BlockHashInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_GetBakerEarliestWinTime_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BakerId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).GetBakerEarliestWinTime(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.v2.Queries/GetBakerEarliestWinTime",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).GetBakerEarliestWinTime(ctx, req.(*BakerId))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_Shutdown_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).Shutdown(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.v2.Queries/Shutdown",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).Shutdown(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_PeerConnect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IpSocketAddress)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).PeerConnect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.v2.Queries/PeerConnect",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).PeerConnect(ctx, req.(*IpSocketAddress))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_PeerDisconnect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IpSocketAddress)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).PeerDisconnect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.v2.Queries/PeerDisconnect",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).PeerDisconnect(ctx, req.(*IpSocketAddress))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_GetBannedPeers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).GetBannedPeers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.v2.Queries/GetBannedPeers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).GetBannedPeers(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_BanPeer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PeerToBan)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).BanPeer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.v2.Queries/BanPeer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).BanPeer(ctx, req.(*PeerToBan))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_UnbanPeer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BannedPeer)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).UnbanPeer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.v2.Queries/UnbanPeer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).UnbanPeer(ctx, req.(*BannedPeer))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_DumpStart_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DumpRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).DumpStart(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.v2.Queries/DumpStart",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).DumpStart(ctx, req.(*DumpRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_DumpStop_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).DumpStop(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.v2.Queries/DumpStop",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).DumpStop(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_GetPeersInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).GetPeersInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.v2.Queries/GetPeersInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).GetPeersInfo(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_GetNodeInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).GetNodeInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.v2.Queries/GetNodeInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).GetNodeInfo(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_SendBlockItem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendBlockItemRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).SendBlockItem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.v2.Queries/SendBlockItem",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).SendBlockItem(ctx, req.(*SendBlockItemRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_GetAccountTransactionSignHash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PreAccountTransaction)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).GetAccountTransactionSignHash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.v2.Queries/GetAccountTransactionSignHash",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).GetAccountTransactionSignHash(ctx, req.(*PreAccountTransaction))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_GetBlockChainParameters_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlockHashInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).GetBlockChainParameters(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.v2.Queries/GetBlockChainParameters",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).GetBlockChainParameters(ctx, req.(*BlockHashInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_GetBlockFinalizationSummary_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlockHashInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).GetBlockFinalizationSummary(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.v2.Queries/GetBlockFinalizationSummary",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).GetBlockFinalizationSummary(ctx, req.(*BlockHashInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_GetBlockItems_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(BlockHashInput)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueriesServer).GetBlockItems(m, &queriesGetBlockItemsServer{stream})
}

type Queries_GetBlockItemsServer interface {
	Send(*BlockItem) error
	grpc.ServerStream
}

type queriesGetBlockItemsServer struct {
	grpc.ServerStream
}

func (x *queriesGetBlockItemsServer) Send(m *BlockItem) error {
	return x.ServerStream.SendMsg(m)
}

func _Queries_GetBakersRewardPeriod_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(BlockHashInput)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueriesServer).GetBakersRewardPeriod(m, &queriesGetBakersRewardPeriodServer{stream})
}

type Queries_GetBakersRewardPeriodServer interface {
	Send(*BakerRewardPeriodInfo) error
	grpc.ServerStream
}

type queriesGetBakersRewardPeriodServer struct {
	grpc.ServerStream
}

func (x *queriesGetBakersRewardPeriodServer) Send(m *BakerRewardPeriodInfo) error {
	return x.ServerStream.SendMsg(m)
}

func _Queries_GetBlockCertificates_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlockHashInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).GetBlockCertificates(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.v2.Queries/GetBlockCertificates",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).GetBlockCertificates(ctx, req.(*BlockHashInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_GetWinningBakersEpoch_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(EpochRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueriesServer).GetWinningBakersEpoch(m, &queriesGetWinningBakersEpochServer{stream})
}

type Queries_GetWinningBakersEpochServer interface {
	Send(*WinningBaker) error
	grpc.ServerStream
}

type queriesGetWinningBakersEpochServer struct {
	grpc.ServerStream
}

func (x *queriesGetWinningBakersEpochServer) Send(m *WinningBaker) error {
	return x.ServerStream.SendMsg(m)
}

func _Queries_GetFirstBlockEpoch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EpochRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).GetFirstBlockEpoch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.v2.Queries/GetFirstBlockEpoch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).GetFirstBlockEpoch(ctx, req.(*EpochRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_DryRun_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(QueriesServer).DryRun(&queriesDryRunServer{stream})
}

type Queries_DryRunServer interface {
	Send(*DryRunResponse) error
	Recv() (*DryRunRequest, error)
	grpc.ServerStream
}

type queriesDryRunServer struct {
	grpc.ServerStream
}

func (x *queriesDryRunServer) Send(m *DryRunResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *queriesDryRunServer) Recv() (*DryRunRequest, error) {
	m := new(DryRunRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Queries_ServiceDesc is the grpc.ServiceDesc for Queries service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Queries_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "concordium.v2.Queries",
	HandlerType: (*QueriesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetAccountInfo",
			Handler:    _Queries_GetAccountInfo_Handler,
		},
		{
			MethodName: "GetModuleSource",
			Handler:    _Queries_GetModuleSource_Handler,
		},
		{
			MethodName: "GetInstanceInfo",
			Handler:    _Queries_GetInstanceInfo_Handler,
		},
		{
			MethodName: "InstanceStateLookup",
			Handler:    _Queries_InstanceStateLookup_Handler,
		},
		{
			MethodName: "GetNextAccountSequenceNumber",
			Handler:    _Queries_GetNextAccountSequenceNumber_Handler,
		},
		{
			MethodName: "GetConsensusInfo",
			Handler:    _Queries_GetConsensusInfo_Handler,
		},
		{
			MethodName: "GetBlockItemStatus",
			Handler:    _Queries_GetBlockItemStatus_Handler,
		},
		{
			MethodName: "GetCryptographicParameters",
			Handler:    _Queries_GetCryptographicParameters_Handler,
		},
		{
			MethodName: "GetBlockInfo",
			Handler:    _Queries_GetBlockInfo_Handler,
		},
		{
			MethodName: "GetPoolInfo",
			Handler:    _Queries_GetPoolInfo_Handler,
		},
		{
			MethodName: "GetPassiveDelegationInfo",
			Handler:    _Queries_GetPassiveDelegationInfo_Handler,
		},
		{
			MethodName: "GetBlocksAtHeight",
			Handler:    _Queries_GetBlocksAtHeight_Handler,
		},
		{
			MethodName: "GetTokenomicsInfo",
			Handler:    _Queries_GetTokenomicsInfo_Handler,
		},
		{
			MethodName: "InvokeInstance",
			Handler:    _Queries_InvokeInstance_Handler,
		},
		{
			MethodName: "GetBranches",
			Handler:    _Queries_GetBranches_Handler,
		},
		{
			MethodName: "GetElectionInfo",
			Handler:    _Queries_GetElectionInfo_Handler,
		},
		{
			MethodName: "GetNextUpdateSequenceNumbers",
			Handler:    _Queries_GetNextUpdateSequenceNumbers_Handler,
		},
		{
			MethodName: "GetBakerEarliestWinTime",
			Handler:    _Queries_GetBakerEarliestWinTime_Handler,
		},
		{
			MethodName: "Shutdown",
			Handler:    _Queries_Shutdown_Handler,
		},
		{
			MethodName: "PeerConnect",
			Handler:    _Queries_PeerConnect_Handler,
		},
		{
			MethodName: "PeerDisconnect",
			Handler:    _Queries_PeerDisconnect_Handler,
		},
		{
			MethodName: "GetBannedPeers",
			Handler:    _Queries_GetBannedPeers_Handler,
		},
		{
			MethodName: "BanPeer",
			Handler:    _Queries_BanPeer_Handler,
		},
		{
			MethodName: "UnbanPeer",
			Handler:    _Queries_UnbanPeer_Handler,
		},
		{
			MethodName: "DumpStart",
			Handler:    _Queries_DumpStart_Handler,
		},
		{
			MethodName: "DumpStop",
			Handler:    _Queries_DumpStop_Handler,
		},
		{
			MethodName: "GetPeersInfo",
			Handler:    _Queries_GetPeersInfo_Handler,
		},
		{
			MethodName: "GetNodeInfo",
			Handler:    _Queries_GetNodeInfo_Handler,
		},
		{
			MethodName: "SendBlockItem",
			Handler:    _Queries_SendBlockItem_Handler,
		},
		{
			MethodName: "GetAccountTransactionSignHash",
			Handler:    _Queries_GetAccountTransactionSignHash_Handler,
		},
		{
			MethodName: "GetBlockChainParameters",
			Handler:    _Queries_GetBlockChainParameters_Handler,
		},
		{
			MethodName: "GetBlockFinalizationSummary",
			Handler:    _Queries_GetBlockFinalizationSummary_Handler,
		},
		{
			MethodName: "GetBlockCertificates",
			Handler:    _Queries_GetBlockCertificates_Handler,
		},
		{
			MethodName: "GetFirstBlockEpoch",
			Handler:    _Queries_GetFirstBlockEpoch_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetBlocks",
			Handler:       _Queries_GetBlocks_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetFinalizedBlocks",
			Handler:       _Queries_GetFinalizedBlocks_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetAccountList",
			Handler:       _Queries_GetAccountList_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetModuleList",
			Handler:       _Queries_GetModuleList_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetAncestors",
			Handler:       _Queries_GetAncestors_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetInstanceList",
			Handler:       _Queries_GetInstanceList_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetInstanceState",
			Handler:       _Queries_GetInstanceState_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetBakerList",
			Handler:       _Queries_GetBakerList_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetPoolDelegators",
			Handler:       _Queries_GetPoolDelegators_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetPoolDelegatorsRewardPeriod",
			Handler:       _Queries_GetPoolDelegatorsRewardPeriod_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetPassiveDelegators",
			Handler:       _Queries_GetPassiveDelegators_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetPassiveDelegatorsRewardPeriod",
			Handler:       _Queries_GetPassiveDelegatorsRewardPeriod_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetIdentityProviders",
			Handler:       _Queries_GetIdentityProviders_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetAnonymityRevokers",
			Handler:       _Queries_GetAnonymityRevokers_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetAccountNonFinalizedTransactions",
			Handler:       _Queries_GetAccountNonFinalizedTransactions_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetBlockTransactionEvents",
			Handler:       _Queries_GetBlockTransactionEvents_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetBlockSpecialEvents",
			Handler:       _Queries_GetBlockSpecialEvents_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetBlockPendingUpdates",
			Handler:       _Queries_GetBlockPendingUpdates_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetBlockItems",
			Handler:       _Queries_GetBlockItems_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetBakersRewardPeriod",
			Handler:       _Queries_GetBakersRewardPeriod_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetWinningBakersEpoch",
			Handler:       _Queries_GetWinningBakersEpoch_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "DryRun",
			Handler:       _Queries_DryRun_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "v2/concordium/service.proto",
}
