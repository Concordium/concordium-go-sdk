// Code generated by protoc-pb-go-grpc. DO NOT EDIT.
// versions:
// - protoc-pb-go-grpc v1.2.0
// - protoc             v3.17.3
// source: service.proto

package pb

import (
	"concordium-go-sdk/v2"
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// QueriesClient is the client API for Queries service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type QueriesClient interface {
	// Return a stream of blocks that arrive from the time the query is made onward.
	// This can be used to listen for incoming blocks.
	GetBlocks(ctx context.Context, in *v2.Empty, opts ...grpc.CallOption) (Queries_GetBlocksClient, error)
	// Return a stream of blocks that are finalized from the time the query is
	// made onward. This can be used to listen for newly finalized blocks. Note
	// that there is no guarantee that blocks will not be skipped if the client is
	// too slow in processing the stream, however blocks will always be sent by
	// increasing block height.
	GetFinalizedBlocks(ctx context.Context, in *v2.Empty, opts ...grpc.CallOption) (Queries_GetFinalizedBlocksClient, error)
	// Retrieve the information about the given account in the given block.
	GetAccountInfo(ctx context.Context, in *v2.AccountInfoRequest, opts ...grpc.CallOption) (*v2.AccountInfo, error)
	// Retrieve the list of accounts that exist at the end of the given block.
	GetAccountList(ctx context.Context, in *v2.BlockHashInput, opts ...grpc.CallOption) (Queries_GetAccountListClient, error)
	// Get a list of all smart contract modules. The stream will end
	// when all modules that exist in the state at the end of the given
	// block have been returned.
	GetModuleList(ctx context.Context, in *v2.BlockHashInput, opts ...grpc.CallOption) (Queries_GetModuleListClient, error)
	// Get a stream of ancestors for the provided block.
	// Starting with the provided block itself, moving backwards until no more
	// ancestors or the requested number of ancestors has been returned.
	GetAncestors(ctx context.Context, in *v2.AncestorsRequest, opts ...grpc.CallOption) (Queries_GetAncestorsClient, error)
	// Get the source of a smart contract module.
	GetModuleSource(ctx context.Context, in *v2.ModuleSourceRequest, opts ...grpc.CallOption) (*v2.VersionedModuleSource, error)
	// Get a list of addresses for all smart contract instances. The stream
	// will end when all instances that exist in the state at the end of the
	// given block has been returned.
	GetInstanceList(ctx context.Context, in *v2.BlockHashInput, opts ...grpc.CallOption) (Queries_GetInstanceListClient, error)
	// Get info about a smart contract instance as it appears at the end of the
	// given block.
	GetInstanceInfo(ctx context.Context, in *v2.InstanceInfoRequest, opts ...grpc.CallOption) (*v2.InstanceInfo, error)
	// Get the exact state of a specific contract instance, streamed as a list of
	// key-value pairs. The list is streamed in lexicographic order of keys.
	GetInstanceState(ctx context.Context, in *v2.InstanceInfoRequest, opts ...grpc.CallOption) (Queries_GetInstanceStateClient, error)
	// Get the value at a specific key of a contract state. In contrast to
	// `GetInstanceState` this is more efficient, but requires the user to know
	// the specific key to look for.
	InstanceStateLookup(ctx context.Context, in *v2.InstanceStateLookupRequest, opts ...grpc.CallOption) (*v2.InstanceStateValueAtKey, error)
	// Get the best guess as to what the next account sequence number should be.
	// If all account transactions are finalized then this information is reliable.
	// Otherwise this is the best guess, assuming all other transactions will be
	// committed to blocks and eventually finalized.
	GetNextAccountSequenceNumber(ctx context.Context, in *v2.AccountAddress, opts ...grpc.CallOption) (*v2.NextAccountSequenceNumber, error)
	// Get information about the current state of consensus.
	GetConsensusInfo(ctx context.Context, in *v2.Empty, opts ...grpc.CallOption) (*v2.ConsensusInfo, error)
	// Get the status of and information about a specific block item (transaction).
	GetBlockItemStatus(ctx context.Context, in *v2.TransactionHash, opts ...grpc.CallOption) (*v2.BlockItemStatus, error)
	// Get the cryptographic parameters in a given block.
	GetCryptographicParameters(ctx context.Context, in *v2.BlockHashInput, opts ...grpc.CallOption) (*v2.CryptographicParameters, error)
	// Get information, such as height, timings, and transaction counts for the given block.
	GetBlockInfo(ctx context.Context, in *v2.BlockHashInput, opts ...grpc.CallOption) (*v2.BlockInfo, error)
	// Get all the bakers at the end of the given block.
	GetBakerList(ctx context.Context, in *v2.BlockHashInput, opts ...grpc.CallOption) (Queries_GetBakerListClient, error)
	// Get information about a given pool at the end of a given block.
	GetPoolInfo(ctx context.Context, in *v2.PoolInfoRequest, opts ...grpc.CallOption) (*v2.PoolInfoResponse, error)
	// Get information about the passive delegators at the end of a given block.
	GetPassiveDelegationInfo(ctx context.Context, in *v2.BlockHashInput, opts ...grpc.CallOption) (*v2.PassiveDelegationInfo, error)
	// Get a list of live blocks at a given height.
	GetBlocksAtHeight(ctx context.Context, in *v2.BlocksAtHeightRequest, opts ...grpc.CallOption) (*v2.BlocksAtHeightResponse, error)
	// Get information about tokenomics at the end of a given block.
	GetTokenomicsInfo(ctx context.Context, in *v2.BlockHashInput, opts ...grpc.CallOption) (*v2.TokenomicsInfo, error)
	// Run the smart contract entrypoint in a given context and in the state at
	// the end of the given block.
	InvokeInstance(ctx context.Context, in *v2.InvokeInstanceRequest, opts ...grpc.CallOption) (*v2.InvokeInstanceResponse, error)
	// Get the registered delegators of a given pool at the end of a given block.
	// In contrast to the `GetPoolDelegatorsRewardPeriod` which returns delegators
	// that are fixed for the reward period of the block, this endpoint returns the
	// list of delegators that are registered in the block. Any changes to delegators
	// are immediately visible in this list.
	// The stream will end when all the delegators has been returned.
	GetPoolDelegators(ctx context.Context, in *v2.GetPoolDelegatorsRequest, opts ...grpc.CallOption) (Queries_GetPoolDelegatorsClient, error)
	// Get the fixed delegators of a given pool for the reward period of the given block.
	// In contracts to the `GetPoolDelegators` which returns delegators registered
	// for the given block, this endpoint returns the fixed delegators contributing
	// stake in the reward period containing the given block.
	// The stream will end when all the delegators has been returned.
	GetPoolDelegatorsRewardPeriod(ctx context.Context, in *v2.GetPoolDelegatorsRequest, opts ...grpc.CallOption) (Queries_GetPoolDelegatorsRewardPeriodClient, error)
	// Get the registered passive delegators at the end of a given block.
	// In contrast to the `GetPassiveDelegatorsRewardPeriod` which returns delegators
	// that are fixed for the reward period of the block, this endpoint returns the
	// list of delegators that are registered in the block. Any changes to delegators
	// are immediately visible in this list.
	// The stream will end when all the delegators has been returned.
	GetPassiveDelegators(ctx context.Context, in *v2.BlockHashInput, opts ...grpc.CallOption) (Queries_GetPassiveDelegatorsClient, error)
	// Get the fixed passive delegators for the reward period of the given block.
	// In contracts to the `GetPassiveDelegators` which returns delegators registered
	// for the given block, this endpoint returns the fixed delegators contributing
	// stake in the reward period containing the given block.
	// The stream will end when all the delegators has been returned.
	GetPassiveDelegatorsRewardPeriod(ctx context.Context, in *v2.BlockHashInput, opts ...grpc.CallOption) (Queries_GetPassiveDelegatorsRewardPeriodClient, error)
	// Get the current branches of blocks starting from and including the last finalized block.
	GetBranches(ctx context.Context, in *v2.Empty, opts ...grpc.CallOption) (*v2.Branch, error)
	// Get information related to the baker election for a particular block.
	GetElectionInfo(ctx context.Context, in *v2.BlockHashInput, opts ...grpc.CallOption) (*v2.ElectionInfo, error)
	// Get the identity providers registered as of the end of a given block.
	// The stream will end when all the identity providers have been returned.
	GetIdentityProviders(ctx context.Context, in *v2.BlockHashInput, opts ...grpc.CallOption) (Queries_GetIdentityProvidersClient, error)
	// Get the anonymity revokers registered as of the end of a given block.
	// The stream will end when all the anonymity revokers have been returned.
	GetAnonymityRevokers(ctx context.Context, in *v2.BlockHashInput, opts ...grpc.CallOption) (Queries_GetAnonymityRevokersClient, error)
	// Get a list of non-finalized transaction hashes for a given account. This
	// endpoint is not expected to return a large amount of data in most cases,
	// but in bad network condtions it might. The stream will end when all the
	// non-finalized transaction hashes have been returned.
	GetAccountNonFinalizedTransactions(ctx context.Context, in *v2.AccountAddress, opts ...grpc.CallOption) (Queries_GetAccountNonFinalizedTransactionsClient, error)
	// Get a list of transaction events in a given block.
	// The stream will end when all the transaction events for a given block have been returned.
	GetBlockTransactionEvents(ctx context.Context, in *v2.BlockHashInput, opts ...grpc.CallOption) (Queries_GetBlockTransactionEventsClient, error)
	// Get a list of special events in a given block. These are events generated
	// by the protocol, such as minting and reward payouts. They are not directly
	// generated by any transaction. The stream will end when all the special
	// events for a given block have been returned.
	GetBlockSpecialEvents(ctx context.Context, in *v2.BlockHashInput, opts ...grpc.CallOption) (Queries_GetBlockSpecialEventsClient, error)
	// Get the pending updates to chain parameters at the end of a given block.
	// The stream will end when all the pending updates for a given block have been returned.
	GetBlockPendingUpdates(ctx context.Context, in *v2.BlockHashInput, opts ...grpc.CallOption) (Queries_GetBlockPendingUpdatesClient, error)
	// Get next available sequence numbers for updating chain parameters after a given block.
	GetNextUpdateSequenceNumbers(ctx context.Context, in *v2.BlockHashInput, opts ...grpc.CallOption) (*v2.NextUpdateSequenceNumbers, error)
	// Shut down the node.
	// Return a GRPC error if the shutdown failed.
	Shutdown(ctx context.Context, in *v2.Empty, opts ...grpc.CallOption) (*v2.Empty, error)
	// Suggest to a peer to connect to the submitted peer details.
	// This, if successful, adds the peer to the list of given addresses.
	// Otherwise return a GRPC error.
	// Note. The peer might not be connected to instantly, in that case
	// the node will try to establish the connection in near future. This
	// function returns a GRPC status 'Ok' in this case.
	PeerConnect(ctx context.Context, in *v2.IpSocketAddress, opts ...grpc.CallOption) (*v2.Empty, error)
	// Disconnect from the peer and remove them from the given addresses list
	// if they are on it. Return if the request was processed successfully.
	// Otherwise return a GRPC error.
	PeerDisconnect(ctx context.Context, in *v2.IpSocketAddress, opts ...grpc.CallOption) (*v2.Empty, error)
	// Get a list of banned peers.
	GetBannedPeers(ctx context.Context, in *v2.Empty, opts ...grpc.CallOption) (*v2.BannedPeers, error)
	// Ban the given peer.
	// Returns a GRPC error if the action failed.
	BanPeer(ctx context.Context, in *v2.PeerToBan, opts ...grpc.CallOption) (*v2.Empty, error)
	// Unban the banned peer.
	// Returns a GRPC error if the action failed.
	UnbanPeer(ctx context.Context, in *v2.BannedPeer, opts ...grpc.CallOption) (*v2.Empty, error)
	// Start dumping packages into the specified file.
	// Only enabled if the node was built with the `network_dump` feature.
	// Returns a GRPC error if the network dump failed to start.
	DumpStart(ctx context.Context, in *v2.DumpRequest, opts ...grpc.CallOption) (*v2.Empty, error)
	// Stop dumping packages.
	// Only enabled if the node was built with the `network_dump` feature.
	// Returns a GRPC error if the network dump failed to be stopped.
	DumpStop(ctx context.Context, in *v2.Empty, opts ...grpc.CallOption) (*v2.Empty, error)
	/// Get a list of the peers that the node is connected to
	/// and assoicated network related information for each peer.
	GetPeersInfo(ctx context.Context, in *v2.Empty, opts ...grpc.CallOption) (*v2.PeersInfo, error)
	// Get information about the node.
	// The `NodeInfo` includes information of
	// * Meta information such as the, version of the node, type of the node, uptime and the local time of the node.
	// * NetworkInfo which yields data such as the node id, packets sent/received,
	//   average bytes per second sent/received.
	// * ConsensusInfo. The `ConsensusInfo` returned depends on if the node supports
	//   the protocol on chain and whether the node is configured as a baker or not.
	GetNodeInfo(ctx context.Context, in *v2.Empty, opts ...grpc.CallOption) (*v2.NodeInfo, error)
	// Send a block item. A block item is either an `AccountTransaction`, which is
	// a transaction signed and paid for by an account, a `CredentialDeployment`,
	// which creates a new account, or `UpdateInstruction`, which is an
	// instruction to change some parameters of the chain. Update instructions can
	// only be sent by the governance committee.
	//
	// Returns a hash of the block item, which can be used with
	// `GetBlockItemStatus`.
	SendBlockItem(ctx context.Context, in *v2.SendBlockItemRequest, opts ...grpc.CallOption) (*v2.TransactionHash, error)
	// Get the hash to be signed for an account transaction. The hash returned
	// should be signed and the signatures included as an
	// AccountTransactionSignature when calling `SendBlockItem`. This is provided as
	// a convenience to support cases where the right SDK is not available for
	// interacting with the node. If an SDK is available then it is strongly
	// recommended to compute this hash off-line using it. That reduces the trust
	// in the node, removes networking failure modes, and will perform better.
	GetAccountTransactionSignHash(ctx context.Context, in *v2.PreAccountTransaction, opts ...grpc.CallOption) (*v2.AccountTransactionSignHash, error)
	// Get the values of chain parameters in effect in the given block.
	GetBlockChainParameters(ctx context.Context, in *v2.BlockHashInput, opts ...grpc.CallOption) (*v2.ChainParameters, error)
	// Get the summary of the finalization data in a given block.
	GetBlockFinalizationSummary(ctx context.Context, in *v2.BlockHashInput, opts ...grpc.CallOption) (*v2.BlockFinalizationSummary, error)
	// Get the items of a block.
	GetBlockItems(ctx context.Context, in *v2.BlockHashInput, opts ...grpc.CallOption) (Queries_GetBlockItemsClient, error)
}

type queriesClient struct {
	cc grpc.ClientConnInterface
}

func NewQueriesClient(cc grpc.ClientConnInterface) QueriesClient {
	return &queriesClient{cc}
}

func (c *queriesClient) GetBlocks(ctx context.Context, in *v2.Empty, opts ...grpc.CallOption) (Queries_GetBlocksClient, error) {
	stream, err := c.cc.NewStream(ctx, &Queries_ServiceDesc.Streams[0], "/concordium.v2.Queries/GetBlocks", opts...)
	if err != nil {
		return nil, err
	}
	x := &queriesGetBlocksClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Queries_GetBlocksClient interface {
	Recv() (*v2.ArrivedBlockInfo, error)
	grpc.ClientStream
}

type queriesGetBlocksClient struct {
	grpc.ClientStream
}

func (x *queriesGetBlocksClient) Recv() (*v2.ArrivedBlockInfo, error) {
	m := new(v2.ArrivedBlockInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *queriesClient) GetFinalizedBlocks(ctx context.Context, in *v2.Empty, opts ...grpc.CallOption) (Queries_GetFinalizedBlocksClient, error) {
	stream, err := c.cc.NewStream(ctx, &Queries_ServiceDesc.Streams[1], "/concordium.v2.Queries/GetFinalizedBlocks", opts...)
	if err != nil {
		return nil, err
	}
	x := &queriesGetFinalizedBlocksClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Queries_GetFinalizedBlocksClient interface {
	Recv() (*v2.FinalizedBlockInfo, error)
	grpc.ClientStream
}

type queriesGetFinalizedBlocksClient struct {
	grpc.ClientStream
}

func (x *queriesGetFinalizedBlocksClient) Recv() (*v2.FinalizedBlockInfo, error) {
	m := new(v2.FinalizedBlockInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *queriesClient) GetAccountInfo(ctx context.Context, in *v2.AccountInfoRequest, opts ...grpc.CallOption) (*v2.AccountInfo, error) {
	out := new(v2.AccountInfo)
	err := c.cc.Invoke(ctx, "/concordium.v2.Queries/GetAccountInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) GetAccountList(ctx context.Context, in *v2.BlockHashInput, opts ...grpc.CallOption) (Queries_GetAccountListClient, error) {
	stream, err := c.cc.NewStream(ctx, &Queries_ServiceDesc.Streams[2], "/concordium.v2.Queries/GetAccountList", opts...)
	if err != nil {
		return nil, err
	}
	x := &queriesGetAccountListClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Queries_GetAccountListClient interface {
	Recv() (*v2.AccountAddress, error)
	grpc.ClientStream
}

type queriesGetAccountListClient struct {
	grpc.ClientStream
}

func (x *queriesGetAccountListClient) Recv() (*v2.AccountAddress, error) {
	m := new(v2.AccountAddress)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *queriesClient) GetModuleList(ctx context.Context, in *v2.BlockHashInput, opts ...grpc.CallOption) (Queries_GetModuleListClient, error) {
	stream, err := c.cc.NewStream(ctx, &Queries_ServiceDesc.Streams[3], "/concordium.v2.Queries/GetModuleList", opts...)
	if err != nil {
		return nil, err
	}
	x := &queriesGetModuleListClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Queries_GetModuleListClient interface {
	Recv() (*v2.ModuleRef, error)
	grpc.ClientStream
}

type queriesGetModuleListClient struct {
	grpc.ClientStream
}

func (x *queriesGetModuleListClient) Recv() (*v2.ModuleRef, error) {
	m := new(v2.ModuleRef)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *queriesClient) GetAncestors(ctx context.Context, in *v2.AncestorsRequest, opts ...grpc.CallOption) (Queries_GetAncestorsClient, error) {
	stream, err := c.cc.NewStream(ctx, &Queries_ServiceDesc.Streams[4], "/concordium.v2.Queries/GetAncestors", opts...)
	if err != nil {
		return nil, err
	}
	x := &queriesGetAncestorsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Queries_GetAncestorsClient interface {
	Recv() (*v2.BlockHash, error)
	grpc.ClientStream
}

type queriesGetAncestorsClient struct {
	grpc.ClientStream
}

func (x *queriesGetAncestorsClient) Recv() (*v2.BlockHash, error) {
	m := new(v2.BlockHash)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *queriesClient) GetModuleSource(ctx context.Context, in *v2.ModuleSourceRequest, opts ...grpc.CallOption) (*v2.VersionedModuleSource, error) {
	out := new(v2.VersionedModuleSource)
	err := c.cc.Invoke(ctx, "/concordium.v2.Queries/GetModuleSource", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) GetInstanceList(ctx context.Context, in *v2.BlockHashInput, opts ...grpc.CallOption) (Queries_GetInstanceListClient, error) {
	stream, err := c.cc.NewStream(ctx, &Queries_ServiceDesc.Streams[5], "/concordium.v2.Queries/GetInstanceList", opts...)
	if err != nil {
		return nil, err
	}
	x := &queriesGetInstanceListClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Queries_GetInstanceListClient interface {
	Recv() (*v2.ContractAddress, error)
	grpc.ClientStream
}

type queriesGetInstanceListClient struct {
	grpc.ClientStream
}

func (x *queriesGetInstanceListClient) Recv() (*v2.ContractAddress, error) {
	m := new(v2.ContractAddress)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *queriesClient) GetInstanceInfo(ctx context.Context, in *v2.InstanceInfoRequest, opts ...grpc.CallOption) (*v2.InstanceInfo, error) {
	out := new(v2.InstanceInfo)
	err := c.cc.Invoke(ctx, "/concordium.v2.Queries/GetInstanceInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) GetInstanceState(ctx context.Context, in *v2.InstanceInfoRequest, opts ...grpc.CallOption) (Queries_GetInstanceStateClient, error) {
	stream, err := c.cc.NewStream(ctx, &Queries_ServiceDesc.Streams[6], "/concordium.v2.Queries/GetInstanceState", opts...)
	if err != nil {
		return nil, err
	}
	x := &queriesGetInstanceStateClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Queries_GetInstanceStateClient interface {
	Recv() (*v2.InstanceStateKVPair, error)
	grpc.ClientStream
}

type queriesGetInstanceStateClient struct {
	grpc.ClientStream
}

func (x *queriesGetInstanceStateClient) Recv() (*v2.InstanceStateKVPair, error) {
	m := new(v2.InstanceStateKVPair)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *queriesClient) InstanceStateLookup(ctx context.Context, in *v2.InstanceStateLookupRequest, opts ...grpc.CallOption) (*v2.InstanceStateValueAtKey, error) {
	out := new(v2.InstanceStateValueAtKey)
	err := c.cc.Invoke(ctx, "/concordium.v2.Queries/InstanceStateLookup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) GetNextAccountSequenceNumber(ctx context.Context, in *v2.AccountAddress, opts ...grpc.CallOption) (*v2.NextAccountSequenceNumber, error) {
	out := new(v2.NextAccountSequenceNumber)
	err := c.cc.Invoke(ctx, "/concordium.v2.Queries/GetNextAccountSequenceNumber", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) GetConsensusInfo(ctx context.Context, in *v2.Empty, opts ...grpc.CallOption) (*v2.ConsensusInfo, error) {
	out := new(v2.ConsensusInfo)
	err := c.cc.Invoke(ctx, "/concordium.v2.Queries/GetConsensusInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) GetBlockItemStatus(ctx context.Context, in *v2.TransactionHash, opts ...grpc.CallOption) (*v2.BlockItemStatus, error) {
	out := new(v2.BlockItemStatus)
	err := c.cc.Invoke(ctx, "/concordium.v2.Queries/GetBlockItemStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) GetCryptographicParameters(ctx context.Context, in *v2.BlockHashInput, opts ...grpc.CallOption) (*v2.CryptographicParameters, error) {
	out := new(v2.CryptographicParameters)
	err := c.cc.Invoke(ctx, "/concordium.v2.Queries/GetCryptographicParameters", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) GetBlockInfo(ctx context.Context, in *v2.BlockHashInput, opts ...grpc.CallOption) (*v2.BlockInfo, error) {
	out := new(v2.BlockInfo)
	err := c.cc.Invoke(ctx, "/concordium.v2.Queries/GetBlockInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) GetBakerList(ctx context.Context, in *v2.BlockHashInput, opts ...grpc.CallOption) (Queries_GetBakerListClient, error) {
	stream, err := c.cc.NewStream(ctx, &Queries_ServiceDesc.Streams[7], "/concordium.v2.Queries/GetBakerList", opts...)
	if err != nil {
		return nil, err
	}
	x := &queriesGetBakerListClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Queries_GetBakerListClient interface {
	Recv() (*v2.BakerId, error)
	grpc.ClientStream
}

type queriesGetBakerListClient struct {
	grpc.ClientStream
}

func (x *queriesGetBakerListClient) Recv() (*v2.BakerId, error) {
	m := new(v2.BakerId)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *queriesClient) GetPoolInfo(ctx context.Context, in *v2.PoolInfoRequest, opts ...grpc.CallOption) (*v2.PoolInfoResponse, error) {
	out := new(v2.PoolInfoResponse)
	err := c.cc.Invoke(ctx, "/concordium.v2.Queries/GetPoolInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) GetPassiveDelegationInfo(ctx context.Context, in *v2.BlockHashInput, opts ...grpc.CallOption) (*v2.PassiveDelegationInfo, error) {
	out := new(v2.PassiveDelegationInfo)
	err := c.cc.Invoke(ctx, "/concordium.v2.Queries/GetPassiveDelegationInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) GetBlocksAtHeight(ctx context.Context, in *v2.BlocksAtHeightRequest, opts ...grpc.CallOption) (*v2.BlocksAtHeightResponse, error) {
	out := new(v2.BlocksAtHeightResponse)
	err := c.cc.Invoke(ctx, "/concordium.v2.Queries/GetBlocksAtHeight", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) GetTokenomicsInfo(ctx context.Context, in *v2.BlockHashInput, opts ...grpc.CallOption) (*v2.TokenomicsInfo, error) {
	out := new(v2.TokenomicsInfo)
	err := c.cc.Invoke(ctx, "/concordium.v2.Queries/GetTokenomicsInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) InvokeInstance(ctx context.Context, in *v2.InvokeInstanceRequest, opts ...grpc.CallOption) (*v2.InvokeInstanceResponse, error) {
	out := new(v2.InvokeInstanceResponse)
	err := c.cc.Invoke(ctx, "/concordium.v2.Queries/InvokeInstance", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) GetPoolDelegators(ctx context.Context, in *v2.GetPoolDelegatorsRequest, opts ...grpc.CallOption) (Queries_GetPoolDelegatorsClient, error) {
	stream, err := c.cc.NewStream(ctx, &Queries_ServiceDesc.Streams[8], "/concordium.v2.Queries/GetPoolDelegators", opts...)
	if err != nil {
		return nil, err
	}
	x := &queriesGetPoolDelegatorsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Queries_GetPoolDelegatorsClient interface {
	Recv() (*v2.DelegatorInfo, error)
	grpc.ClientStream
}

type queriesGetPoolDelegatorsClient struct {
	grpc.ClientStream
}

func (x *queriesGetPoolDelegatorsClient) Recv() (*v2.DelegatorInfo, error) {
	m := new(v2.DelegatorInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *queriesClient) GetPoolDelegatorsRewardPeriod(ctx context.Context, in *v2.GetPoolDelegatorsRequest, opts ...grpc.CallOption) (Queries_GetPoolDelegatorsRewardPeriodClient, error) {
	stream, err := c.cc.NewStream(ctx, &Queries_ServiceDesc.Streams[9], "/concordium.v2.Queries/GetPoolDelegatorsRewardPeriod", opts...)
	if err != nil {
		return nil, err
	}
	x := &queriesGetPoolDelegatorsRewardPeriodClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Queries_GetPoolDelegatorsRewardPeriodClient interface {
	Recv() (*v2.DelegatorRewardPeriodInfo, error)
	grpc.ClientStream
}

type queriesGetPoolDelegatorsRewardPeriodClient struct {
	grpc.ClientStream
}

func (x *queriesGetPoolDelegatorsRewardPeriodClient) Recv() (*v2.DelegatorRewardPeriodInfo, error) {
	m := new(v2.DelegatorRewardPeriodInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *queriesClient) GetPassiveDelegators(ctx context.Context, in *v2.BlockHashInput, opts ...grpc.CallOption) (Queries_GetPassiveDelegatorsClient, error) {
	stream, err := c.cc.NewStream(ctx, &Queries_ServiceDesc.Streams[10], "/concordium.v2.Queries/GetPassiveDelegators", opts...)
	if err != nil {
		return nil, err
	}
	x := &queriesGetPassiveDelegatorsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Queries_GetPassiveDelegatorsClient interface {
	Recv() (*v2.DelegatorInfo, error)
	grpc.ClientStream
}

type queriesGetPassiveDelegatorsClient struct {
	grpc.ClientStream
}

func (x *queriesGetPassiveDelegatorsClient) Recv() (*v2.DelegatorInfo, error) {
	m := new(v2.DelegatorInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *queriesClient) GetPassiveDelegatorsRewardPeriod(ctx context.Context, in *v2.BlockHashInput, opts ...grpc.CallOption) (Queries_GetPassiveDelegatorsRewardPeriodClient, error) {
	stream, err := c.cc.NewStream(ctx, &Queries_ServiceDesc.Streams[11], "/concordium.v2.Queries/GetPassiveDelegatorsRewardPeriod", opts...)
	if err != nil {
		return nil, err
	}
	x := &queriesGetPassiveDelegatorsRewardPeriodClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Queries_GetPassiveDelegatorsRewardPeriodClient interface {
	Recv() (*v2.DelegatorRewardPeriodInfo, error)
	grpc.ClientStream
}

type queriesGetPassiveDelegatorsRewardPeriodClient struct {
	grpc.ClientStream
}

func (x *queriesGetPassiveDelegatorsRewardPeriodClient) Recv() (*v2.DelegatorRewardPeriodInfo, error) {
	m := new(v2.DelegatorRewardPeriodInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *queriesClient) GetBranches(ctx context.Context, in *v2.Empty, opts ...grpc.CallOption) (*v2.Branch, error) {
	out := new(v2.Branch)
	err := c.cc.Invoke(ctx, "/concordium.v2.Queries/GetBranches", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) GetElectionInfo(ctx context.Context, in *v2.BlockHashInput, opts ...grpc.CallOption) (*v2.ElectionInfo, error) {
	out := new(v2.ElectionInfo)
	err := c.cc.Invoke(ctx, "/concordium.v2.Queries/GetElectionInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) GetIdentityProviders(ctx context.Context, in *v2.BlockHashInput, opts ...grpc.CallOption) (Queries_GetIdentityProvidersClient, error) {
	stream, err := c.cc.NewStream(ctx, &Queries_ServiceDesc.Streams[12], "/concordium.v2.Queries/GetIdentityProviders", opts...)
	if err != nil {
		return nil, err
	}
	x := &queriesGetIdentityProvidersClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Queries_GetIdentityProvidersClient interface {
	Recv() (*v2.IpInfo, error)
	grpc.ClientStream
}

type queriesGetIdentityProvidersClient struct {
	grpc.ClientStream
}

func (x *queriesGetIdentityProvidersClient) Recv() (*v2.IpInfo, error) {
	m := new(v2.IpInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *queriesClient) GetAnonymityRevokers(ctx context.Context, in *v2.BlockHashInput, opts ...grpc.CallOption) (Queries_GetAnonymityRevokersClient, error) {
	stream, err := c.cc.NewStream(ctx, &Queries_ServiceDesc.Streams[13], "/concordium.v2.Queries/GetAnonymityRevokers", opts...)
	if err != nil {
		return nil, err
	}
	x := &queriesGetAnonymityRevokersClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Queries_GetAnonymityRevokersClient interface {
	Recv() (*v2.ArInfo, error)
	grpc.ClientStream
}

type queriesGetAnonymityRevokersClient struct {
	grpc.ClientStream
}

func (x *queriesGetAnonymityRevokersClient) Recv() (*v2.ArInfo, error) {
	m := new(v2.ArInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *queriesClient) GetAccountNonFinalizedTransactions(ctx context.Context, in *v2.AccountAddress, opts ...grpc.CallOption) (Queries_GetAccountNonFinalizedTransactionsClient, error) {
	stream, err := c.cc.NewStream(ctx, &Queries_ServiceDesc.Streams[14], "/concordium.v2.Queries/GetAccountNonFinalizedTransactions", opts...)
	if err != nil {
		return nil, err
	}
	x := &queriesGetAccountNonFinalizedTransactionsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Queries_GetAccountNonFinalizedTransactionsClient interface {
	Recv() (*v2.TransactionHash, error)
	grpc.ClientStream
}

type queriesGetAccountNonFinalizedTransactionsClient struct {
	grpc.ClientStream
}

func (x *queriesGetAccountNonFinalizedTransactionsClient) Recv() (*v2.TransactionHash, error) {
	m := new(v2.TransactionHash)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *queriesClient) GetBlockTransactionEvents(ctx context.Context, in *v2.BlockHashInput, opts ...grpc.CallOption) (Queries_GetBlockTransactionEventsClient, error) {
	stream, err := c.cc.NewStream(ctx, &Queries_ServiceDesc.Streams[15], "/concordium.v2.Queries/GetBlockTransactionEvents", opts...)
	if err != nil {
		return nil, err
	}
	x := &queriesGetBlockTransactionEventsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Queries_GetBlockTransactionEventsClient interface {
	Recv() (*v2.BlockItemSummary, error)
	grpc.ClientStream
}

type queriesGetBlockTransactionEventsClient struct {
	grpc.ClientStream
}

func (x *queriesGetBlockTransactionEventsClient) Recv() (*v2.BlockItemSummary, error) {
	m := new(v2.BlockItemSummary)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *queriesClient) GetBlockSpecialEvents(ctx context.Context, in *v2.BlockHashInput, opts ...grpc.CallOption) (Queries_GetBlockSpecialEventsClient, error) {
	stream, err := c.cc.NewStream(ctx, &Queries_ServiceDesc.Streams[16], "/concordium.v2.Queries/GetBlockSpecialEvents", opts...)
	if err != nil {
		return nil, err
	}
	x := &queriesGetBlockSpecialEventsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Queries_GetBlockSpecialEventsClient interface {
	Recv() (*v2.BlockSpecialEvent, error)
	grpc.ClientStream
}

type queriesGetBlockSpecialEventsClient struct {
	grpc.ClientStream
}

func (x *queriesGetBlockSpecialEventsClient) Recv() (*v2.BlockSpecialEvent, error) {
	m := new(v2.BlockSpecialEvent)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *queriesClient) GetBlockPendingUpdates(ctx context.Context, in *v2.BlockHashInput, opts ...grpc.CallOption) (Queries_GetBlockPendingUpdatesClient, error) {
	stream, err := c.cc.NewStream(ctx, &Queries_ServiceDesc.Streams[17], "/concordium.v2.Queries/GetBlockPendingUpdates", opts...)
	if err != nil {
		return nil, err
	}
	x := &queriesGetBlockPendingUpdatesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Queries_GetBlockPendingUpdatesClient interface {
	Recv() (*v2.PendingUpdate, error)
	grpc.ClientStream
}

type queriesGetBlockPendingUpdatesClient struct {
	grpc.ClientStream
}

func (x *queriesGetBlockPendingUpdatesClient) Recv() (*v2.PendingUpdate, error) {
	m := new(v2.PendingUpdate)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *queriesClient) GetNextUpdateSequenceNumbers(ctx context.Context, in *v2.BlockHashInput, opts ...grpc.CallOption) (*v2.NextUpdateSequenceNumbers, error) {
	out := new(v2.NextUpdateSequenceNumbers)
	err := c.cc.Invoke(ctx, "/concordium.v2.Queries/GetNextUpdateSequenceNumbers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) Shutdown(ctx context.Context, in *v2.Empty, opts ...grpc.CallOption) (*v2.Empty, error) {
	out := new(v2.Empty)
	err := c.cc.Invoke(ctx, "/concordium.v2.Queries/Shutdown", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) PeerConnect(ctx context.Context, in *v2.IpSocketAddress, opts ...grpc.CallOption) (*v2.Empty, error) {
	out := new(v2.Empty)
	err := c.cc.Invoke(ctx, "/concordium.v2.Queries/PeerConnect", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) PeerDisconnect(ctx context.Context, in *v2.IpSocketAddress, opts ...grpc.CallOption) (*v2.Empty, error) {
	out := new(v2.Empty)
	err := c.cc.Invoke(ctx, "/concordium.v2.Queries/PeerDisconnect", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) GetBannedPeers(ctx context.Context, in *v2.Empty, opts ...grpc.CallOption) (*v2.BannedPeers, error) {
	out := new(v2.BannedPeers)
	err := c.cc.Invoke(ctx, "/concordium.v2.Queries/GetBannedPeers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) BanPeer(ctx context.Context, in *v2.PeerToBan, opts ...grpc.CallOption) (*v2.Empty, error) {
	out := new(v2.Empty)
	err := c.cc.Invoke(ctx, "/concordium.v2.Queries/BanPeer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) UnbanPeer(ctx context.Context, in *v2.BannedPeer, opts ...grpc.CallOption) (*v2.Empty, error) {
	out := new(v2.Empty)
	err := c.cc.Invoke(ctx, "/concordium.v2.Queries/UnbanPeer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) DumpStart(ctx context.Context, in *v2.DumpRequest, opts ...grpc.CallOption) (*v2.Empty, error) {
	out := new(v2.Empty)
	err := c.cc.Invoke(ctx, "/concordium.v2.Queries/DumpStart", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) DumpStop(ctx context.Context, in *v2.Empty, opts ...grpc.CallOption) (*v2.Empty, error) {
	out := new(v2.Empty)
	err := c.cc.Invoke(ctx, "/concordium.v2.Queries/DumpStop", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) GetPeersInfo(ctx context.Context, in *v2.Empty, opts ...grpc.CallOption) (*v2.PeersInfo, error) {
	out := new(v2.PeersInfo)
	err := c.cc.Invoke(ctx, "/concordium.v2.Queries/GetPeersInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) GetNodeInfo(ctx context.Context, in *v2.Empty, opts ...grpc.CallOption) (*v2.NodeInfo, error) {
	out := new(v2.NodeInfo)
	err := c.cc.Invoke(ctx, "/concordium.v2.Queries/GetNodeInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) SendBlockItem(ctx context.Context, in *v2.SendBlockItemRequest, opts ...grpc.CallOption) (*v2.TransactionHash, error) {
	out := new(v2.TransactionHash)
	err := c.cc.Invoke(ctx, "/concordium.v2.Queries/SendBlockItem", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) GetAccountTransactionSignHash(ctx context.Context, in *v2.PreAccountTransaction, opts ...grpc.CallOption) (*v2.AccountTransactionSignHash, error) {
	out := new(v2.AccountTransactionSignHash)
	err := c.cc.Invoke(ctx, "/concordium.v2.Queries/GetAccountTransactionSignHash", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) GetBlockChainParameters(ctx context.Context, in *v2.BlockHashInput, opts ...grpc.CallOption) (*v2.ChainParameters, error) {
	out := new(v2.ChainParameters)
	err := c.cc.Invoke(ctx, "/concordium.v2.Queries/GetBlockChainParameters", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) GetBlockFinalizationSummary(ctx context.Context, in *v2.BlockHashInput, opts ...grpc.CallOption) (*v2.BlockFinalizationSummary, error) {
	out := new(v2.BlockFinalizationSummary)
	err := c.cc.Invoke(ctx, "/concordium.v2.Queries/GetBlockFinalizationSummary", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queriesClient) GetBlockItems(ctx context.Context, in *v2.BlockHashInput, opts ...grpc.CallOption) (Queries_GetBlockItemsClient, error) {
	stream, err := c.cc.NewStream(ctx, &Queries_ServiceDesc.Streams[18], "/concordium.v2.Queries/GetBlockItems", opts...)
	if err != nil {
		return nil, err
	}
	x := &queriesGetBlockItemsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Queries_GetBlockItemsClient interface {
	Recv() (*v2.BlockItem, error)
	grpc.ClientStream
}

type queriesGetBlockItemsClient struct {
	grpc.ClientStream
}

func (x *queriesGetBlockItemsClient) Recv() (*v2.BlockItem, error) {
	m := new(v2.BlockItem)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// QueriesServer is the server API for Queries service.
// All implementations must embed UnimplementedQueriesServer
// for forward compatibility
type QueriesServer interface {
	// Return a stream of blocks that arrive from the time the query is made onward.
	// This can be used to listen for incoming blocks.
	GetBlocks(*v2.Empty, Queries_GetBlocksServer) error
	// Return a stream of blocks that are finalized from the time the query is
	// made onward. This can be used to listen for newly finalized blocks. Note
	// that there is no guarantee that blocks will not be skipped if the client is
	// too slow in processing the stream, however blocks will always be sent by
	// increasing block height.
	GetFinalizedBlocks(*v2.Empty, Queries_GetFinalizedBlocksServer) error
	// Retrieve the information about the given account in the given block.
	GetAccountInfo(context.Context, *v2.AccountInfoRequest) (*v2.AccountInfo, error)
	// Retrieve the list of accounts that exist at the end of the given block.
	GetAccountList(*v2.BlockHashInput, Queries_GetAccountListServer) error
	// Get a list of all smart contract modules. The stream will end
	// when all modules that exist in the state at the end of the given
	// block have been returned.
	GetModuleList(*v2.BlockHashInput, Queries_GetModuleListServer) error
	// Get a stream of ancestors for the provided block.
	// Starting with the provided block itself, moving backwards until no more
	// ancestors or the requested number of ancestors has been returned.
	GetAncestors(*v2.AncestorsRequest, Queries_GetAncestorsServer) error
	// Get the source of a smart contract module.
	GetModuleSource(context.Context, *v2.ModuleSourceRequest) (*v2.VersionedModuleSource, error)
	// Get a list of addresses for all smart contract instances. The stream
	// will end when all instances that exist in the state at the end of the
	// given block has been returned.
	GetInstanceList(*v2.BlockHashInput, Queries_GetInstanceListServer) error
	// Get info about a smart contract instance as it appears at the end of the
	// given block.
	GetInstanceInfo(context.Context, *v2.InstanceInfoRequest) (*v2.InstanceInfo, error)
	// Get the exact state of a specific contract instance, streamed as a list of
	// key-value pairs. The list is streamed in lexicographic order of keys.
	GetInstanceState(*v2.InstanceInfoRequest, Queries_GetInstanceStateServer) error
	// Get the value at a specific key of a contract state. In contrast to
	// `GetInstanceState` this is more efficient, but requires the user to know
	// the specific key to look for.
	InstanceStateLookup(context.Context, *v2.InstanceStateLookupRequest) (*v2.InstanceStateValueAtKey, error)
	// Get the best guess as to what the next account sequence number should be.
	// If all account transactions are finalized then this information is reliable.
	// Otherwise this is the best guess, assuming all other transactions will be
	// committed to blocks and eventually finalized.
	GetNextAccountSequenceNumber(context.Context, *v2.AccountAddress) (*v2.NextAccountSequenceNumber, error)
	// Get information about the current state of consensus.
	GetConsensusInfo(context.Context, *v2.Empty) (*v2.ConsensusInfo, error)
	// Get the status of and information about a specific block item (transaction).
	GetBlockItemStatus(context.Context, *v2.TransactionHash) (*v2.BlockItemStatus, error)
	// Get the cryptographic parameters in a given block.
	GetCryptographicParameters(context.Context, *v2.BlockHashInput) (*v2.CryptographicParameters, error)
	// Get information, such as height, timings, and transaction counts for the given block.
	GetBlockInfo(context.Context, *v2.BlockHashInput) (*v2.BlockInfo, error)
	// Get all the bakers at the end of the given block.
	GetBakerList(*v2.BlockHashInput, Queries_GetBakerListServer) error
	// Get information about a given pool at the end of a given block.
	GetPoolInfo(context.Context, *v2.PoolInfoRequest) (*v2.PoolInfoResponse, error)
	// Get information about the passive delegators at the end of a given block.
	GetPassiveDelegationInfo(context.Context, *v2.BlockHashInput) (*v2.PassiveDelegationInfo, error)
	// Get a list of live blocks at a given height.
	GetBlocksAtHeight(context.Context, *v2.BlocksAtHeightRequest) (*v2.BlocksAtHeightResponse, error)
	// Get information about tokenomics at the end of a given block.
	GetTokenomicsInfo(context.Context, *v2.BlockHashInput) (*v2.TokenomicsInfo, error)
	// Run the smart contract entrypoint in a given context and in the state at
	// the end of the given block.
	InvokeInstance(context.Context, *v2.InvokeInstanceRequest) (*v2.InvokeInstanceResponse, error)
	// Get the registered delegators of a given pool at the end of a given block.
	// In contrast to the `GetPoolDelegatorsRewardPeriod` which returns delegators
	// that are fixed for the reward period of the block, this endpoint returns the
	// list of delegators that are registered in the block. Any changes to delegators
	// are immediately visible in this list.
	// The stream will end when all the delegators has been returned.
	GetPoolDelegators(*v2.GetPoolDelegatorsRequest, Queries_GetPoolDelegatorsServer) error
	// Get the fixed delegators of a given pool for the reward period of the given block.
	// In contracts to the `GetPoolDelegators` which returns delegators registered
	// for the given block, this endpoint returns the fixed delegators contributing
	// stake in the reward period containing the given block.
	// The stream will end when all the delegators has been returned.
	GetPoolDelegatorsRewardPeriod(*v2.GetPoolDelegatorsRequest, Queries_GetPoolDelegatorsRewardPeriodServer) error
	// Get the registered passive delegators at the end of a given block.
	// In contrast to the `GetPassiveDelegatorsRewardPeriod` which returns delegators
	// that are fixed for the reward period of the block, this endpoint returns the
	// list of delegators that are registered in the block. Any changes to delegators
	// are immediately visible in this list.
	// The stream will end when all the delegators has been returned.
	GetPassiveDelegators(*v2.BlockHashInput, Queries_GetPassiveDelegatorsServer) error
	// Get the fixed passive delegators for the reward period of the given block.
	// In contracts to the `GetPassiveDelegators` which returns delegators registered
	// for the given block, this endpoint returns the fixed delegators contributing
	// stake in the reward period containing the given block.
	// The stream will end when all the delegators has been returned.
	GetPassiveDelegatorsRewardPeriod(*v2.BlockHashInput, Queries_GetPassiveDelegatorsRewardPeriodServer) error
	// Get the current branches of blocks starting from and including the last finalized block.
	GetBranches(context.Context, *v2.Empty) (*v2.Branch, error)
	// Get information related to the baker election for a particular block.
	GetElectionInfo(context.Context, *v2.BlockHashInput) (*v2.ElectionInfo, error)
	// Get the identity providers registered as of the end of a given block.
	// The stream will end when all the identity providers have been returned.
	GetIdentityProviders(*v2.BlockHashInput, Queries_GetIdentityProvidersServer) error
	// Get the anonymity revokers registered as of the end of a given block.
	// The stream will end when all the anonymity revokers have been returned.
	GetAnonymityRevokers(*v2.BlockHashInput, Queries_GetAnonymityRevokersServer) error
	// Get a list of non-finalized transaction hashes for a given account. This
	// endpoint is not expected to return a large amount of data in most cases,
	// but in bad network condtions it might. The stream will end when all the
	// non-finalized transaction hashes have been returned.
	GetAccountNonFinalizedTransactions(*v2.AccountAddress, Queries_GetAccountNonFinalizedTransactionsServer) error
	// Get a list of transaction events in a given block.
	// The stream will end when all the transaction events for a given block have been returned.
	GetBlockTransactionEvents(*v2.BlockHashInput, Queries_GetBlockTransactionEventsServer) error
	// Get a list of special events in a given block. These are events generated
	// by the protocol, such as minting and reward payouts. They are not directly
	// generated by any transaction. The stream will end when all the special
	// events for a given block have been returned.
	GetBlockSpecialEvents(*v2.BlockHashInput, Queries_GetBlockSpecialEventsServer) error
	// Get the pending updates to chain parameters at the end of a given block.
	// The stream will end when all the pending updates for a given block have been returned.
	GetBlockPendingUpdates(*v2.BlockHashInput, Queries_GetBlockPendingUpdatesServer) error
	// Get next available sequence numbers for updating chain parameters after a given block.
	GetNextUpdateSequenceNumbers(context.Context, *v2.BlockHashInput) (*v2.NextUpdateSequenceNumbers, error)
	// Shut down the node.
	// Return a GRPC error if the shutdown failed.
	Shutdown(context.Context, *v2.Empty) (*v2.Empty, error)
	// Suggest to a peer to connect to the submitted peer details.
	// This, if successful, adds the peer to the list of given addresses.
	// Otherwise return a GRPC error.
	// Note. The peer might not be connected to instantly, in that case
	// the node will try to establish the connection in near future. This
	// function returns a GRPC status 'Ok' in this case.
	PeerConnect(context.Context, *v2.IpSocketAddress) (*v2.Empty, error)
	// Disconnect from the peer and remove them from the given addresses list
	// if they are on it. Return if the request was processed successfully.
	// Otherwise return a GRPC error.
	PeerDisconnect(context.Context, *v2.IpSocketAddress) (*v2.Empty, error)
	// Get a list of banned peers.
	GetBannedPeers(context.Context, *v2.Empty) (*v2.BannedPeers, error)
	// Ban the given peer.
	// Returns a GRPC error if the action failed.
	BanPeer(context.Context, *v2.PeerToBan) (*v2.Empty, error)
	// Unban the banned peer.
	// Returns a GRPC error if the action failed.
	UnbanPeer(context.Context, *v2.BannedPeer) (*v2.Empty, error)
	// Start dumping packages into the specified file.
	// Only enabled if the node was built with the `network_dump` feature.
	// Returns a GRPC error if the network dump failed to start.
	DumpStart(context.Context, *v2.DumpRequest) (*v2.Empty, error)
	// Stop dumping packages.
	// Only enabled if the node was built with the `network_dump` feature.
	// Returns a GRPC error if the network dump failed to be stopped.
	DumpStop(context.Context, *v2.Empty) (*v2.Empty, error)
	/// Get a list of the peers that the node is connected to
	/// and assoicated network related information for each peer.
	GetPeersInfo(context.Context, *v2.Empty) (*v2.PeersInfo, error)
	// Get information about the node.
	// The `NodeInfo` includes information of
	// * Meta information such as the, version of the node, type of the node, uptime and the local time of the node.
	// * NetworkInfo which yields data such as the node id, packets sent/received,
	//   average bytes per second sent/received.
	// * ConsensusInfo. The `ConsensusInfo` returned depends on if the node supports
	//   the protocol on chain and whether the node is configured as a baker or not.
	GetNodeInfo(context.Context, *v2.Empty) (*v2.NodeInfo, error)
	// Send a block item. A block item is either an `AccountTransaction`, which is
	// a transaction signed and paid for by an account, a `CredentialDeployment`,
	// which creates a new account, or `UpdateInstruction`, which is an
	// instruction to change some parameters of the chain. Update instructions can
	// only be sent by the governance committee.
	//
	// Returns a hash of the block item, which can be used with
	// `GetBlockItemStatus`.
	SendBlockItem(context.Context, *v2.SendBlockItemRequest) (*v2.TransactionHash, error)
	// Get the hash to be signed for an account transaction. The hash returned
	// should be signed and the signatures included as an
	// AccountTransactionSignature when calling `SendBlockItem`. This is provided as
	// a convenience to support cases where the right SDK is not available for
	// interacting with the node. If an SDK is available then it is strongly
	// recommended to compute this hash off-line using it. That reduces the trust
	// in the node, removes networking failure modes, and will perform better.
	GetAccountTransactionSignHash(context.Context, *v2.PreAccountTransaction) (*v2.AccountTransactionSignHash, error)
	// Get the values of chain parameters in effect in the given block.
	GetBlockChainParameters(context.Context, *v2.BlockHashInput) (*v2.ChainParameters, error)
	// Get the summary of the finalization data in a given block.
	GetBlockFinalizationSummary(context.Context, *v2.BlockHashInput) (*v2.BlockFinalizationSummary, error)
	// Get the items of a block.
	GetBlockItems(*v2.BlockHashInput, Queries_GetBlockItemsServer) error
	mustEmbedUnimplementedQueriesServer()
}

// UnimplementedQueriesServer must be embedded to have forward compatible implementations.
type UnimplementedQueriesServer struct {
}

func (UnimplementedQueriesServer) GetBlocks(*v2.Empty, Queries_GetBlocksServer) error {
	return status.Errorf(codes.Unimplemented, "method GetBlocks not implemented")
}
func (UnimplementedQueriesServer) GetFinalizedBlocks(*v2.Empty, Queries_GetFinalizedBlocksServer) error {
	return status.Errorf(codes.Unimplemented, "method GetFinalizedBlocks not implemented")
}
func (UnimplementedQueriesServer) GetAccountInfo(context.Context, *v2.AccountInfoRequest) (*v2.AccountInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAccountInfo not implemented")
}
func (UnimplementedQueriesServer) GetAccountList(*v2.BlockHashInput, Queries_GetAccountListServer) error {
	return status.Errorf(codes.Unimplemented, "method GetAccountList not implemented")
}
func (UnimplementedQueriesServer) GetModuleList(*v2.BlockHashInput, Queries_GetModuleListServer) error {
	return status.Errorf(codes.Unimplemented, "method GetModuleList not implemented")
}
func (UnimplementedQueriesServer) GetAncestors(*v2.AncestorsRequest, Queries_GetAncestorsServer) error {
	return status.Errorf(codes.Unimplemented, "method GetAncestors not implemented")
}
func (UnimplementedQueriesServer) GetModuleSource(context.Context, *v2.ModuleSourceRequest) (*v2.VersionedModuleSource, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetModuleSource not implemented")
}
func (UnimplementedQueriesServer) GetInstanceList(*v2.BlockHashInput, Queries_GetInstanceListServer) error {
	return status.Errorf(codes.Unimplemented, "method GetInstanceList not implemented")
}
func (UnimplementedQueriesServer) GetInstanceInfo(context.Context, *v2.InstanceInfoRequest) (*v2.InstanceInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetInstanceInfo not implemented")
}
func (UnimplementedQueriesServer) GetInstanceState(*v2.InstanceInfoRequest, Queries_GetInstanceStateServer) error {
	return status.Errorf(codes.Unimplemented, "method GetInstanceState not implemented")
}
func (UnimplementedQueriesServer) InstanceStateLookup(context.Context, *v2.InstanceStateLookupRequest) (*v2.InstanceStateValueAtKey, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InstanceStateLookup not implemented")
}
func (UnimplementedQueriesServer) GetNextAccountSequenceNumber(context.Context, *v2.AccountAddress) (*v2.NextAccountSequenceNumber, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNextAccountSequenceNumber not implemented")
}
func (UnimplementedQueriesServer) GetConsensusInfo(context.Context, *v2.Empty) (*v2.ConsensusInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetConsensusInfo not implemented")
}
func (UnimplementedQueriesServer) GetBlockItemStatus(context.Context, *v2.TransactionHash) (*v2.BlockItemStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBlockItemStatus not implemented")
}
func (UnimplementedQueriesServer) GetCryptographicParameters(context.Context, *v2.BlockHashInput) (*v2.CryptographicParameters, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCryptographicParameters not implemented")
}
func (UnimplementedQueriesServer) GetBlockInfo(context.Context, *v2.BlockHashInput) (*v2.BlockInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBlockInfo not implemented")
}
func (UnimplementedQueriesServer) GetBakerList(*v2.BlockHashInput, Queries_GetBakerListServer) error {
	return status.Errorf(codes.Unimplemented, "method GetBakerList not implemented")
}
func (UnimplementedQueriesServer) GetPoolInfo(context.Context, *v2.PoolInfoRequest) (*v2.PoolInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPoolInfo not implemented")
}
func (UnimplementedQueriesServer) GetPassiveDelegationInfo(context.Context, *v2.BlockHashInput) (*v2.PassiveDelegationInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPassiveDelegationInfo not implemented")
}
func (UnimplementedQueriesServer) GetBlocksAtHeight(context.Context, *v2.BlocksAtHeightRequest) (*v2.BlocksAtHeightResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBlocksAtHeight not implemented")
}
func (UnimplementedQueriesServer) GetTokenomicsInfo(context.Context, *v2.BlockHashInput) (*v2.TokenomicsInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTokenomicsInfo not implemented")
}
func (UnimplementedQueriesServer) InvokeInstance(context.Context, *v2.InvokeInstanceRequest) (*v2.InvokeInstanceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InvokeInstance not implemented")
}
func (UnimplementedQueriesServer) GetPoolDelegators(*v2.GetPoolDelegatorsRequest, Queries_GetPoolDelegatorsServer) error {
	return status.Errorf(codes.Unimplemented, "method GetPoolDelegators not implemented")
}
func (UnimplementedQueriesServer) GetPoolDelegatorsRewardPeriod(*v2.GetPoolDelegatorsRequest, Queries_GetPoolDelegatorsRewardPeriodServer) error {
	return status.Errorf(codes.Unimplemented, "method GetPoolDelegatorsRewardPeriod not implemented")
}
func (UnimplementedQueriesServer) GetPassiveDelegators(*v2.BlockHashInput, Queries_GetPassiveDelegatorsServer) error {
	return status.Errorf(codes.Unimplemented, "method GetPassiveDelegators not implemented")
}
func (UnimplementedQueriesServer) GetPassiveDelegatorsRewardPeriod(*v2.BlockHashInput, Queries_GetPassiveDelegatorsRewardPeriodServer) error {
	return status.Errorf(codes.Unimplemented, "method GetPassiveDelegatorsRewardPeriod not implemented")
}
func (UnimplementedQueriesServer) GetBranches(context.Context, *v2.Empty) (*v2.Branch, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBranches not implemented")
}
func (UnimplementedQueriesServer) GetElectionInfo(context.Context, *v2.BlockHashInput) (*v2.ElectionInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetElectionInfo not implemented")
}
func (UnimplementedQueriesServer) GetIdentityProviders(*v2.BlockHashInput, Queries_GetIdentityProvidersServer) error {
	return status.Errorf(codes.Unimplemented, "method GetIdentityProviders not implemented")
}
func (UnimplementedQueriesServer) GetAnonymityRevokers(*v2.BlockHashInput, Queries_GetAnonymityRevokersServer) error {
	return status.Errorf(codes.Unimplemented, "method GetAnonymityRevokers not implemented")
}
func (UnimplementedQueriesServer) GetAccountNonFinalizedTransactions(*v2.AccountAddress, Queries_GetAccountNonFinalizedTransactionsServer) error {
	return status.Errorf(codes.Unimplemented, "method GetAccountNonFinalizedTransactions not implemented")
}
func (UnimplementedQueriesServer) GetBlockTransactionEvents(*v2.BlockHashInput, Queries_GetBlockTransactionEventsServer) error {
	return status.Errorf(codes.Unimplemented, "method GetBlockTransactionEvents not implemented")
}
func (UnimplementedQueriesServer) GetBlockSpecialEvents(*v2.BlockHashInput, Queries_GetBlockSpecialEventsServer) error {
	return status.Errorf(codes.Unimplemented, "method GetBlockSpecialEvents not implemented")
}
func (UnimplementedQueriesServer) GetBlockPendingUpdates(*v2.BlockHashInput, Queries_GetBlockPendingUpdatesServer) error {
	return status.Errorf(codes.Unimplemented, "method GetBlockPendingUpdates not implemented")
}
func (UnimplementedQueriesServer) GetNextUpdateSequenceNumbers(context.Context, *v2.BlockHashInput) (*v2.NextUpdateSequenceNumbers, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNextUpdateSequenceNumbers not implemented")
}
func (UnimplementedQueriesServer) Shutdown(context.Context, *v2.Empty) (*v2.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Shutdown not implemented")
}
func (UnimplementedQueriesServer) PeerConnect(context.Context, *v2.IpSocketAddress) (*v2.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PeerConnect not implemented")
}
func (UnimplementedQueriesServer) PeerDisconnect(context.Context, *v2.IpSocketAddress) (*v2.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PeerDisconnect not implemented")
}
func (UnimplementedQueriesServer) GetBannedPeers(context.Context, *v2.Empty) (*v2.BannedPeers, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBannedPeers not implemented")
}
func (UnimplementedQueriesServer) BanPeer(context.Context, *v2.PeerToBan) (*v2.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BanPeer not implemented")
}
func (UnimplementedQueriesServer) UnbanPeer(context.Context, *v2.BannedPeer) (*v2.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnbanPeer not implemented")
}
func (UnimplementedQueriesServer) DumpStart(context.Context, *v2.DumpRequest) (*v2.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DumpStart not implemented")
}
func (UnimplementedQueriesServer) DumpStop(context.Context, *v2.Empty) (*v2.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DumpStop not implemented")
}
func (UnimplementedQueriesServer) GetPeersInfo(context.Context, *v2.Empty) (*v2.PeersInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPeersInfo not implemented")
}
func (UnimplementedQueriesServer) GetNodeInfo(context.Context, *v2.Empty) (*v2.NodeInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNodeInfo not implemented")
}
func (UnimplementedQueriesServer) SendBlockItem(context.Context, *v2.SendBlockItemRequest) (*v2.TransactionHash, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendBlockItem not implemented")
}
func (UnimplementedQueriesServer) GetAccountTransactionSignHash(context.Context, *v2.PreAccountTransaction) (*v2.AccountTransactionSignHash, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAccountTransactionSignHash not implemented")
}
func (UnimplementedQueriesServer) GetBlockChainParameters(context.Context, *v2.BlockHashInput) (*v2.ChainParameters, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBlockChainParameters not implemented")
}
func (UnimplementedQueriesServer) GetBlockFinalizationSummary(context.Context, *v2.BlockHashInput) (*v2.BlockFinalizationSummary, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBlockFinalizationSummary not implemented")
}
func (UnimplementedQueriesServer) GetBlockItems(*v2.BlockHashInput, Queries_GetBlockItemsServer) error {
	return status.Errorf(codes.Unimplemented, "method GetBlockItems not implemented")
}
func (UnimplementedQueriesServer) mustEmbedUnimplementedQueriesServer() {}

// UnsafeQueriesServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to QueriesServer will
// result in compilation errors.
type UnsafeQueriesServer interface {
	mustEmbedUnimplementedQueriesServer()
}

func RegisterQueriesServer(s grpc.ServiceRegistrar, srv QueriesServer) {
	s.RegisterService(&Queries_ServiceDesc, srv)
}

func _Queries_GetBlocks_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(v2.Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueriesServer).GetBlocks(m, &queriesGetBlocksServer{stream})
}

type Queries_GetBlocksServer interface {
	Send(*v2.ArrivedBlockInfo) error
	grpc.ServerStream
}

type queriesGetBlocksServer struct {
	grpc.ServerStream
}

func (x *queriesGetBlocksServer) Send(m *v2.ArrivedBlockInfo) error {
	return x.ServerStream.SendMsg(m)
}

func _Queries_GetFinalizedBlocks_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(v2.Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueriesServer).GetFinalizedBlocks(m, &queriesGetFinalizedBlocksServer{stream})
}

type Queries_GetFinalizedBlocksServer interface {
	Send(*v2.FinalizedBlockInfo) error
	grpc.ServerStream
}

type queriesGetFinalizedBlocksServer struct {
	grpc.ServerStream
}

func (x *queriesGetFinalizedBlocksServer) Send(m *v2.FinalizedBlockInfo) error {
	return x.ServerStream.SendMsg(m)
}

func _Queries_GetAccountInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v2.AccountInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).GetAccountInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.v2.Queries/GetAccountInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).GetAccountInfo(ctx, req.(*v2.AccountInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_GetAccountList_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(v2.BlockHashInput)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueriesServer).GetAccountList(m, &queriesGetAccountListServer{stream})
}

type Queries_GetAccountListServer interface {
	Send(*v2.AccountAddress) error
	grpc.ServerStream
}

type queriesGetAccountListServer struct {
	grpc.ServerStream
}

func (x *queriesGetAccountListServer) Send(m *v2.AccountAddress) error {
	return x.ServerStream.SendMsg(m)
}

func _Queries_GetModuleList_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(v2.BlockHashInput)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueriesServer).GetModuleList(m, &queriesGetModuleListServer{stream})
}

type Queries_GetModuleListServer interface {
	Send(*v2.ModuleRef) error
	grpc.ServerStream
}

type queriesGetModuleListServer struct {
	grpc.ServerStream
}

func (x *queriesGetModuleListServer) Send(m *v2.ModuleRef) error {
	return x.ServerStream.SendMsg(m)
}

func _Queries_GetAncestors_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(v2.AncestorsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueriesServer).GetAncestors(m, &queriesGetAncestorsServer{stream})
}

type Queries_GetAncestorsServer interface {
	Send(*v2.BlockHash) error
	grpc.ServerStream
}

type queriesGetAncestorsServer struct {
	grpc.ServerStream
}

func (x *queriesGetAncestorsServer) Send(m *v2.BlockHash) error {
	return x.ServerStream.SendMsg(m)
}

func _Queries_GetModuleSource_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v2.ModuleSourceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).GetModuleSource(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.v2.Queries/GetModuleSource",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).GetModuleSource(ctx, req.(*v2.ModuleSourceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_GetInstanceList_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(v2.BlockHashInput)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueriesServer).GetInstanceList(m, &queriesGetInstanceListServer{stream})
}

type Queries_GetInstanceListServer interface {
	Send(*v2.ContractAddress) error
	grpc.ServerStream
}

type queriesGetInstanceListServer struct {
	grpc.ServerStream
}

func (x *queriesGetInstanceListServer) Send(m *v2.ContractAddress) error {
	return x.ServerStream.SendMsg(m)
}

func _Queries_GetInstanceInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v2.InstanceInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).GetInstanceInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.v2.Queries/GetInstanceInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).GetInstanceInfo(ctx, req.(*v2.InstanceInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_GetInstanceState_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(v2.InstanceInfoRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueriesServer).GetInstanceState(m, &queriesGetInstanceStateServer{stream})
}

type Queries_GetInstanceStateServer interface {
	Send(*v2.InstanceStateKVPair) error
	grpc.ServerStream
}

type queriesGetInstanceStateServer struct {
	grpc.ServerStream
}

func (x *queriesGetInstanceStateServer) Send(m *v2.InstanceStateKVPair) error {
	return x.ServerStream.SendMsg(m)
}

func _Queries_InstanceStateLookup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v2.InstanceStateLookupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).InstanceStateLookup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.v2.Queries/InstanceStateLookup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).InstanceStateLookup(ctx, req.(*v2.InstanceStateLookupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_GetNextAccountSequenceNumber_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v2.AccountAddress)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).GetNextAccountSequenceNumber(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.v2.Queries/GetNextAccountSequenceNumber",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).GetNextAccountSequenceNumber(ctx, req.(*v2.AccountAddress))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_GetConsensusInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v2.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).GetConsensusInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.v2.Queries/GetConsensusInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).GetConsensusInfo(ctx, req.(*v2.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_GetBlockItemStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v2.TransactionHash)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).GetBlockItemStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.v2.Queries/GetBlockItemStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).GetBlockItemStatus(ctx, req.(*v2.TransactionHash))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_GetCryptographicParameters_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v2.BlockHashInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).GetCryptographicParameters(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.v2.Queries/GetCryptographicParameters",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).GetCryptographicParameters(ctx, req.(*v2.BlockHashInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_GetBlockInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v2.BlockHashInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).GetBlockInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.v2.Queries/GetBlockInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).GetBlockInfo(ctx, req.(*v2.BlockHashInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_GetBakerList_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(v2.BlockHashInput)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueriesServer).GetBakerList(m, &queriesGetBakerListServer{stream})
}

type Queries_GetBakerListServer interface {
	Send(*v2.BakerId) error
	grpc.ServerStream
}

type queriesGetBakerListServer struct {
	grpc.ServerStream
}

func (x *queriesGetBakerListServer) Send(m *v2.BakerId) error {
	return x.ServerStream.SendMsg(m)
}

func _Queries_GetPoolInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v2.PoolInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).GetPoolInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.v2.Queries/GetPoolInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).GetPoolInfo(ctx, req.(*v2.PoolInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_GetPassiveDelegationInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v2.BlockHashInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).GetPassiveDelegationInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.v2.Queries/GetPassiveDelegationInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).GetPassiveDelegationInfo(ctx, req.(*v2.BlockHashInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_GetBlocksAtHeight_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v2.BlocksAtHeightRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).GetBlocksAtHeight(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.v2.Queries/GetBlocksAtHeight",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).GetBlocksAtHeight(ctx, req.(*v2.BlocksAtHeightRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_GetTokenomicsInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v2.BlockHashInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).GetTokenomicsInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.v2.Queries/GetTokenomicsInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).GetTokenomicsInfo(ctx, req.(*v2.BlockHashInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_InvokeInstance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v2.InvokeInstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).InvokeInstance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.v2.Queries/InvokeInstance",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).InvokeInstance(ctx, req.(*v2.InvokeInstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_GetPoolDelegators_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(v2.GetPoolDelegatorsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueriesServer).GetPoolDelegators(m, &queriesGetPoolDelegatorsServer{stream})
}

type Queries_GetPoolDelegatorsServer interface {
	Send(*v2.DelegatorInfo) error
	grpc.ServerStream
}

type queriesGetPoolDelegatorsServer struct {
	grpc.ServerStream
}

func (x *queriesGetPoolDelegatorsServer) Send(m *v2.DelegatorInfo) error {
	return x.ServerStream.SendMsg(m)
}

func _Queries_GetPoolDelegatorsRewardPeriod_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(v2.GetPoolDelegatorsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueriesServer).GetPoolDelegatorsRewardPeriod(m, &queriesGetPoolDelegatorsRewardPeriodServer{stream})
}

type Queries_GetPoolDelegatorsRewardPeriodServer interface {
	Send(*v2.DelegatorRewardPeriodInfo) error
	grpc.ServerStream
}

type queriesGetPoolDelegatorsRewardPeriodServer struct {
	grpc.ServerStream
}

func (x *queriesGetPoolDelegatorsRewardPeriodServer) Send(m *v2.DelegatorRewardPeriodInfo) error {
	return x.ServerStream.SendMsg(m)
}

func _Queries_GetPassiveDelegators_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(v2.BlockHashInput)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueriesServer).GetPassiveDelegators(m, &queriesGetPassiveDelegatorsServer{stream})
}

type Queries_GetPassiveDelegatorsServer interface {
	Send(*v2.DelegatorInfo) error
	grpc.ServerStream
}

type queriesGetPassiveDelegatorsServer struct {
	grpc.ServerStream
}

func (x *queriesGetPassiveDelegatorsServer) Send(m *v2.DelegatorInfo) error {
	return x.ServerStream.SendMsg(m)
}

func _Queries_GetPassiveDelegatorsRewardPeriod_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(v2.BlockHashInput)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueriesServer).GetPassiveDelegatorsRewardPeriod(m, &queriesGetPassiveDelegatorsRewardPeriodServer{stream})
}

type Queries_GetPassiveDelegatorsRewardPeriodServer interface {
	Send(*v2.DelegatorRewardPeriodInfo) error
	grpc.ServerStream
}

type queriesGetPassiveDelegatorsRewardPeriodServer struct {
	grpc.ServerStream
}

func (x *queriesGetPassiveDelegatorsRewardPeriodServer) Send(m *v2.DelegatorRewardPeriodInfo) error {
	return x.ServerStream.SendMsg(m)
}

func _Queries_GetBranches_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v2.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).GetBranches(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.v2.Queries/GetBranches",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).GetBranches(ctx, req.(*v2.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_GetElectionInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v2.BlockHashInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).GetElectionInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.v2.Queries/GetElectionInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).GetElectionInfo(ctx, req.(*v2.BlockHashInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_GetIdentityProviders_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(v2.BlockHashInput)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueriesServer).GetIdentityProviders(m, &queriesGetIdentityProvidersServer{stream})
}

type Queries_GetIdentityProvidersServer interface {
	Send(*v2.IpInfo) error
	grpc.ServerStream
}

type queriesGetIdentityProvidersServer struct {
	grpc.ServerStream
}

func (x *queriesGetIdentityProvidersServer) Send(m *v2.IpInfo) error {
	return x.ServerStream.SendMsg(m)
}

func _Queries_GetAnonymityRevokers_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(v2.BlockHashInput)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueriesServer).GetAnonymityRevokers(m, &queriesGetAnonymityRevokersServer{stream})
}

type Queries_GetAnonymityRevokersServer interface {
	Send(*v2.ArInfo) error
	grpc.ServerStream
}

type queriesGetAnonymityRevokersServer struct {
	grpc.ServerStream
}

func (x *queriesGetAnonymityRevokersServer) Send(m *v2.ArInfo) error {
	return x.ServerStream.SendMsg(m)
}

func _Queries_GetAccountNonFinalizedTransactions_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(v2.AccountAddress)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueriesServer).GetAccountNonFinalizedTransactions(m, &queriesGetAccountNonFinalizedTransactionsServer{stream})
}

type Queries_GetAccountNonFinalizedTransactionsServer interface {
	Send(*v2.TransactionHash) error
	grpc.ServerStream
}

type queriesGetAccountNonFinalizedTransactionsServer struct {
	grpc.ServerStream
}

func (x *queriesGetAccountNonFinalizedTransactionsServer) Send(m *v2.TransactionHash) error {
	return x.ServerStream.SendMsg(m)
}

func _Queries_GetBlockTransactionEvents_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(v2.BlockHashInput)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueriesServer).GetBlockTransactionEvents(m, &queriesGetBlockTransactionEventsServer{stream})
}

type Queries_GetBlockTransactionEventsServer interface {
	Send(*v2.BlockItemSummary) error
	grpc.ServerStream
}

type queriesGetBlockTransactionEventsServer struct {
	grpc.ServerStream
}

func (x *queriesGetBlockTransactionEventsServer) Send(m *v2.BlockItemSummary) error {
	return x.ServerStream.SendMsg(m)
}

func _Queries_GetBlockSpecialEvents_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(v2.BlockHashInput)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueriesServer).GetBlockSpecialEvents(m, &queriesGetBlockSpecialEventsServer{stream})
}

type Queries_GetBlockSpecialEventsServer interface {
	Send(*v2.BlockSpecialEvent) error
	grpc.ServerStream
}

type queriesGetBlockSpecialEventsServer struct {
	grpc.ServerStream
}

func (x *queriesGetBlockSpecialEventsServer) Send(m *v2.BlockSpecialEvent) error {
	return x.ServerStream.SendMsg(m)
}

func _Queries_GetBlockPendingUpdates_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(v2.BlockHashInput)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueriesServer).GetBlockPendingUpdates(m, &queriesGetBlockPendingUpdatesServer{stream})
}

type Queries_GetBlockPendingUpdatesServer interface {
	Send(*v2.PendingUpdate) error
	grpc.ServerStream
}

type queriesGetBlockPendingUpdatesServer struct {
	grpc.ServerStream
}

func (x *queriesGetBlockPendingUpdatesServer) Send(m *v2.PendingUpdate) error {
	return x.ServerStream.SendMsg(m)
}

func _Queries_GetNextUpdateSequenceNumbers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v2.BlockHashInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).GetNextUpdateSequenceNumbers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.v2.Queries/GetNextUpdateSequenceNumbers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).GetNextUpdateSequenceNumbers(ctx, req.(*v2.BlockHashInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_Shutdown_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v2.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).Shutdown(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.v2.Queries/Shutdown",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).Shutdown(ctx, req.(*v2.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_PeerConnect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v2.IpSocketAddress)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).PeerConnect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.v2.Queries/PeerConnect",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).PeerConnect(ctx, req.(*v2.IpSocketAddress))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_PeerDisconnect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v2.IpSocketAddress)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).PeerDisconnect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.v2.Queries/PeerDisconnect",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).PeerDisconnect(ctx, req.(*v2.IpSocketAddress))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_GetBannedPeers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v2.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).GetBannedPeers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.v2.Queries/GetBannedPeers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).GetBannedPeers(ctx, req.(*v2.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_BanPeer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v2.PeerToBan)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).BanPeer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.v2.Queries/BanPeer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).BanPeer(ctx, req.(*v2.PeerToBan))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_UnbanPeer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v2.BannedPeer)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).UnbanPeer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.v2.Queries/UnbanPeer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).UnbanPeer(ctx, req.(*v2.BannedPeer))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_DumpStart_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v2.DumpRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).DumpStart(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.v2.Queries/DumpStart",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).DumpStart(ctx, req.(*v2.DumpRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_DumpStop_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v2.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).DumpStop(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.v2.Queries/DumpStop",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).DumpStop(ctx, req.(*v2.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_GetPeersInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v2.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).GetPeersInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.v2.Queries/GetPeersInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).GetPeersInfo(ctx, req.(*v2.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_GetNodeInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v2.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).GetNodeInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.v2.Queries/GetNodeInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).GetNodeInfo(ctx, req.(*v2.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_SendBlockItem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v2.SendBlockItemRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).SendBlockItem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.v2.Queries/SendBlockItem",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).SendBlockItem(ctx, req.(*v2.SendBlockItemRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_GetAccountTransactionSignHash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v2.PreAccountTransaction)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).GetAccountTransactionSignHash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.v2.Queries/GetAccountTransactionSignHash",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).GetAccountTransactionSignHash(ctx, req.(*v2.PreAccountTransaction))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_GetBlockChainParameters_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v2.BlockHashInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).GetBlockChainParameters(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.v2.Queries/GetBlockChainParameters",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).GetBlockChainParameters(ctx, req.(*v2.BlockHashInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_GetBlockFinalizationSummary_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v2.BlockHashInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueriesServer).GetBlockFinalizationSummary(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.v2.Queries/GetBlockFinalizationSummary",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueriesServer).GetBlockFinalizationSummary(ctx, req.(*v2.BlockHashInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queries_GetBlockItems_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(v2.BlockHashInput)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueriesServer).GetBlockItems(m, &queriesGetBlockItemsServer{stream})
}

type Queries_GetBlockItemsServer interface {
	Send(*v2.BlockItem) error
	grpc.ServerStream
}

type queriesGetBlockItemsServer struct {
	grpc.ServerStream
}

func (x *queriesGetBlockItemsServer) Send(m *v2.BlockItem) error {
	return x.ServerStream.SendMsg(m)
}

// Queries_ServiceDesc is the grpc.ServiceDesc for Queries service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Queries_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "concordium.v2.Queries",
	HandlerType: (*QueriesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetAccountInfo",
			Handler:    _Queries_GetAccountInfo_Handler,
		},
		{
			MethodName: "GetModuleSource",
			Handler:    _Queries_GetModuleSource_Handler,
		},
		{
			MethodName: "GetInstanceInfo",
			Handler:    _Queries_GetInstanceInfo_Handler,
		},
		{
			MethodName: "InstanceStateLookup",
			Handler:    _Queries_InstanceStateLookup_Handler,
		},
		{
			MethodName: "GetNextAccountSequenceNumber",
			Handler:    _Queries_GetNextAccountSequenceNumber_Handler,
		},
		{
			MethodName: "GetConsensusInfo",
			Handler:    _Queries_GetConsensusInfo_Handler,
		},
		{
			MethodName: "GetBlockItemStatus",
			Handler:    _Queries_GetBlockItemStatus_Handler,
		},
		{
			MethodName: "GetCryptographicParameters",
			Handler:    _Queries_GetCryptographicParameters_Handler,
		},
		{
			MethodName: "GetBlockInfo",
			Handler:    _Queries_GetBlockInfo_Handler,
		},
		{
			MethodName: "GetPoolInfo",
			Handler:    _Queries_GetPoolInfo_Handler,
		},
		{
			MethodName: "GetPassiveDelegationInfo",
			Handler:    _Queries_GetPassiveDelegationInfo_Handler,
		},
		{
			MethodName: "GetBlocksAtHeight",
			Handler:    _Queries_GetBlocksAtHeight_Handler,
		},
		{
			MethodName: "GetTokenomicsInfo",
			Handler:    _Queries_GetTokenomicsInfo_Handler,
		},
		{
			MethodName: "InvokeInstance",
			Handler:    _Queries_InvokeInstance_Handler,
		},
		{
			MethodName: "GetBranches",
			Handler:    _Queries_GetBranches_Handler,
		},
		{
			MethodName: "GetElectionInfo",
			Handler:    _Queries_GetElectionInfo_Handler,
		},
		{
			MethodName: "GetNextUpdateSequenceNumbers",
			Handler:    _Queries_GetNextUpdateSequenceNumbers_Handler,
		},
		{
			MethodName: "Shutdown",
			Handler:    _Queries_Shutdown_Handler,
		},
		{
			MethodName: "PeerConnect",
			Handler:    _Queries_PeerConnect_Handler,
		},
		{
			MethodName: "PeerDisconnect",
			Handler:    _Queries_PeerDisconnect_Handler,
		},
		{
			MethodName: "GetBannedPeers",
			Handler:    _Queries_GetBannedPeers_Handler,
		},
		{
			MethodName: "BanPeer",
			Handler:    _Queries_BanPeer_Handler,
		},
		{
			MethodName: "UnbanPeer",
			Handler:    _Queries_UnbanPeer_Handler,
		},
		{
			MethodName: "DumpStart",
			Handler:    _Queries_DumpStart_Handler,
		},
		{
			MethodName: "DumpStop",
			Handler:    _Queries_DumpStop_Handler,
		},
		{
			MethodName: "GetPeersInfo",
			Handler:    _Queries_GetPeersInfo_Handler,
		},
		{
			MethodName: "GetNodeInfo",
			Handler:    _Queries_GetNodeInfo_Handler,
		},
		{
			MethodName: "SendBlockItem",
			Handler:    _Queries_SendBlockItem_Handler,
		},
		{
			MethodName: "GetAccountTransactionSignHash",
			Handler:    _Queries_GetAccountTransactionSignHash_Handler,
		},
		{
			MethodName: "GetBlockChainParameters",
			Handler:    _Queries_GetBlockChainParameters_Handler,
		},
		{
			MethodName: "GetBlockFinalizationSummary",
			Handler:    _Queries_GetBlockFinalizationSummary_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetBlocks",
			Handler:       _Queries_GetBlocks_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetFinalizedBlocks",
			Handler:       _Queries_GetFinalizedBlocks_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetAccountList",
			Handler:       _Queries_GetAccountList_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetModuleList",
			Handler:       _Queries_GetModuleList_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetAncestors",
			Handler:       _Queries_GetAncestors_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetInstanceList",
			Handler:       _Queries_GetInstanceList_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetInstanceState",
			Handler:       _Queries_GetInstanceState_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetBakerList",
			Handler:       _Queries_GetBakerList_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetPoolDelegators",
			Handler:       _Queries_GetPoolDelegators_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetPoolDelegatorsRewardPeriod",
			Handler:       _Queries_GetPoolDelegatorsRewardPeriod_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetPassiveDelegators",
			Handler:       _Queries_GetPassiveDelegators_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetPassiveDelegatorsRewardPeriod",
			Handler:       _Queries_GetPassiveDelegatorsRewardPeriod_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetIdentityProviders",
			Handler:       _Queries_GetIdentityProviders_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetAnonymityRevokers",
			Handler:       _Queries_GetAnonymityRevokers_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetAccountNonFinalizedTransactions",
			Handler:       _Queries_GetAccountNonFinalizedTransactions_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetBlockTransactionEvents",
			Handler:       _Queries_GetBlockTransactionEvents_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetBlockSpecialEvents",
			Handler:       _Queries_GetBlockSpecialEvents_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetBlockPendingUpdates",
			Handler:       _Queries_GetBlockPendingUpdates_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetBlockItems",
			Handler:       _Queries_GetBlockItems_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "service.proto",
}
