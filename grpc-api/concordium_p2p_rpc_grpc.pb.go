// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package grpc_api

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// P2PClient is the client API for P2P service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type P2PClient interface {
	// Suggest to a peer to connect to the submitted peer details.
	// This, if successful, adds the peer to the list of given addresses.
	PeerConnect(ctx context.Context, in *PeerConnectRequest, opts ...grpc.CallOption) (*BoolResponse, error)
	// Disconnect from the peer and remove them from the given addresses list
	// if they are on it. Return if the request was processed successfully.
	PeerDisconnect(ctx context.Context, in *PeerConnectRequest, opts ...grpc.CallOption) (*BoolResponse, error)
	// Uptime of the *node* in milliseconds.
	PeerUptime(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*NumberResponse, error)
	// Total number of sent packets by the node.
	PeerTotalSent(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*NumberResponse, error)
	// Total number of received packets by the node.
	PeerTotalReceived(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*NumberResponse, error)
	// Node software version.
	PeerVersion(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*StringResponse, error)
	// Stats for connected peers.
	PeerStats(ctx context.Context, in *PeersRequest, opts ...grpc.CallOption) (*PeerStatsResponse, error)
	// List of connected peers.
	PeerList(ctx context.Context, in *PeersRequest, opts ...grpc.CallOption) (*PeerListResponse, error)
	// Ban a the given peer.
	BanNode(ctx context.Context, in *PeerElement, opts ...grpc.CallOption) (*BoolResponse, error)
	// Unban the given peer.
	UnbanNode(ctx context.Context, in *PeerElement, opts ...grpc.CallOption) (*BoolResponse, error)
	// Join the provided network.
	JoinNetwork(ctx context.Context, in *NetworkChangeRequest, opts ...grpc.CallOption) (*BoolResponse, error)
	// Leave the provided network.
	LeaveNetwork(ctx context.Context, in *NetworkChangeRequest, opts ...grpc.CallOption) (*BoolResponse, error)
	// Get information about the running node.
	NodeInfo(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*NodeInfoResponse, error)
	// Get information about the consensus.
	// A JSON schema for the return type is provided at: https://developer.concordium.software/en/mainnet/net/references/grpc.html.
	GetConsensusStatus(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*JsonResponse, error)
	// Get information about the block.
	// A JSON schema for the return type is provided at: https://developer.concordium.software/en/mainnet/net/references/grpc.html.
	GetBlockInfo(ctx context.Context, in *BlockHash, opts ...grpc.CallOption) (*JsonResponse, error)
	// Get ancestors for the provided block.
	// A JSON schema for the return type is provided at: https://developer.concordium.software/en/mainnet/net/references/grpc.html.
	GetAncestors(ctx context.Context, in *BlockHashAndAmount, opts ...grpc.CallOption) (*JsonResponse, error)
	// Get the current branches.
	// A JSON schema for the return type is provided at: https://developer.concordium.software/en/mainnet/net/references/grpc.html.
	GetBranches(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*JsonResponse, error)
	// Get the blocks at the given height.
	// A JSON schema for the return type is provided at: https://developer.concordium.software/en/mainnet/net/references/grpc.html.
	GetBlocksAtHeight(ctx context.Context, in *BlockHeight, opts ...grpc.CallOption) (*JsonResponse, error)
	// Submit a transaction.
	SendTransaction(ctx context.Context, in *SendTransactionRequest, opts ...grpc.CallOption) (*BoolResponse, error)
	// Start the baker in the consensus module.
	StartBaker(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*BoolResponse, error)
	// Stop the baker in the consensus module.
	StopBaker(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*BoolResponse, error)
	// Get a list of accounts that exist in the state after the given block.
	// A JSON schema for the return type is provided at: https://developer.concordium.software/en/mainnet/net/references/grpc.html.
	GetAccountList(ctx context.Context, in *BlockHash, opts ...grpc.CallOption) (*JsonResponse, error)
	// Get all smart contract instances that exist in the state after the given block.
	// A JSON schema for the return type is provided at: https://developer.concordium.software/en/mainnet/net/references/grpc.html.
	GetInstances(ctx context.Context, in *BlockHash, opts ...grpc.CallOption) (*JsonResponse, error)
	// Get information about an account.
	// A JSON schema for the return type is provided at: https://developer.concordium.software/en/mainnet/net/references/grpc.html.
	GetAccountInfo(ctx context.Context, in *GetAddressInfoRequest, opts ...grpc.CallOption) (*JsonResponse, error)
	// Get information about a smart contract instance.
	// A JSON schema for the return type is provided at: https://developer.concordium.software/en/mainnet/net/references/grpc.html.
	GetInstanceInfo(ctx context.Context, in *GetAddressInfoRequest, opts ...grpc.CallOption) (*JsonResponse, error)
	// Invoke a smart contract instance and view the result *as if* it had been updated at the end of the provided block.
	// This is *not* a transaction.
	// A JSON schema for the return type is provided at: https://developer.concordium.software/en/mainnet/net/references/grpc.html.
	InvokeContract(ctx context.Context, in *InvokeContractRequest, opts ...grpc.CallOption) (*JsonResponse, error)
	// Get an overview of the balance of special accounts in the given block.
	// A JSON schema for the return type is provided at: https://developer.concordium.software/en/mainnet/net/references/grpc.html.
	GetRewardStatus(ctx context.Context, in *BlockHash, opts ...grpc.CallOption) (*JsonResponse, error)
	// Get an overview of the parameters used for baking.
	// A JSON schema for the return type is provided at: https://developer.concordium.software/en/mainnet/net/references/grpc.html.
	GetBirkParameters(ctx context.Context, in *BlockHash, opts ...grpc.CallOption) (*JsonResponse, error)
	// Get a list of smart contract modules that exist in the state after the given block.
	// A JSON schema for the return type is provided at: https://developer.concordium.software/en/mainnet/net/references/grpc.html.
	GetModuleList(ctx context.Context, in *BlockHash, opts ...grpc.CallOption) (*JsonResponse, error)
	// Get the source of a smart contract module.
	GetModuleSource(ctx context.Context, in *GetModuleSourceRequest, opts ...grpc.CallOption) (*BytesResponse, error)
	// Get a list of all identity providers that exist in the state after the given block.
	// A JSON schema for the return type is provided at: https://developer.concordium.software/en/mainnet/net/references/grpc.html.
	GetIdentityProviders(ctx context.Context, in *BlockHash, opts ...grpc.CallOption) (*JsonResponse, error)
	// Get a list of all anonymity revokers that exist in the state after the given block.
	// A JSON schema for the return type is provided at: https://developer.concordium.software/en/mainnet/net/references/grpc.html.
	GetAnonymityRevokers(ctx context.Context, in *BlockHash, opts ...grpc.CallOption) (*JsonResponse, error)
	// Get the cryptographic parameters used in the given block.
	// A JSON schema for the return type is provided at: https://developer.concordium.software/en/mainnet/net/references/grpc.html.
	GetCryptographicParameters(ctx context.Context, in *BlockHash, opts ...grpc.CallOption) (*JsonResponse, error)
	// Get a list of all baker IDs registered at that block in ascending order. Or null, if the block is invalid.
	// A JSON schema for the return type is provided at: https://developer.concordium.software/en/mainnet/net/references/grpc.html.
	GetBakerList(ctx context.Context, in *BlockHash, opts ...grpc.CallOption) (*JsonResponse, error)
	// Get the status of a pool. If passiveDelegation == true, this returns the status for the passive delegators.
	// Otherwise, it returns the status for the baker with the specified ID (if it exists).
	// A JSON schema for the return type is provided at: https://developer.concordium.software/en/mainnet/net/references/grpc.html.
	GetPoolStatus(ctx context.Context, in *GetPoolStatusRequest, opts ...grpc.CallOption) (*JsonResponse, error)
	// Get a list of banned peers.
	GetBannedPeers(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*PeerListResponse, error)
	// Shut down the node.
	Shutdown(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*BoolResponse, error)
	// Start dumping packages into the specified file.
	// Only enabled if the node was built with the `network_dump` feature.
	DumpStart(ctx context.Context, in *DumpRequest, opts ...grpc.CallOption) (*BoolResponse, error)
	// Stop dumping packages.
	// Only enabled if the node was built with the `network_dump` feature.
	DumpStop(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*BoolResponse, error)
	// Query for the status of a transaction by its hash.
	// A JSON schema for the return type is provided at: https://developer.concordium.software/en/mainnet/net/references/grpc.html.
	GetTransactionStatus(ctx context.Context, in *TransactionHash, opts ...grpc.CallOption) (*JsonResponse, error)
	// Query for transactions in a block by its hash.
	// A JSON schema for the return type is provided at: https://developer.concordium.software/en/mainnet/net/references/grpc.html.
	GetTransactionStatusInBlock(ctx context.Context, in *GetTransactionStatusInBlockRequest, opts ...grpc.CallOption) (*JsonResponse, error)
	// Query for non-finalized transactions present on an account by the account address.
	// A JSON schema for the return type is provided at: https://developer.concordium.software/en/mainnet/net/references/grpc.html.
	GetAccountNonFinalizedTransactions(ctx context.Context, in *AccountAddress, opts ...grpc.CallOption) (*JsonResponse, error)
	// Request a summary for a block by its hash.
	// A JSON schema for the return type is provided at: https://developer.concordium.software/en/mainnet/net/references/grpc.html.
	GetBlockSummary(ctx context.Context, in *BlockHash, opts ...grpc.CallOption) (*JsonResponse, error)
	// Request next nonce information for an account.
	// A JSON schema for the return type is provided at: https://developer.concordium.software/en/mainnet/net/references/grpc.html.
	GetNextAccountNonce(ctx context.Context, in *AccountAddress, opts ...grpc.CallOption) (*JsonResponse, error)
}

type p2PClient struct {
	cc grpc.ClientConnInterface
}

func NewP2PClient(cc grpc.ClientConnInterface) P2PClient {
	return &p2PClient{cc}
}

func (c *p2PClient) PeerConnect(ctx context.Context, in *PeerConnectRequest, opts ...grpc.CallOption) (*BoolResponse, error) {
	out := new(BoolResponse)
	err := c.cc.Invoke(ctx, "/concordium.P2P/PeerConnect", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *p2PClient) PeerDisconnect(ctx context.Context, in *PeerConnectRequest, opts ...grpc.CallOption) (*BoolResponse, error) {
	out := new(BoolResponse)
	err := c.cc.Invoke(ctx, "/concordium.P2P/PeerDisconnect", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *p2PClient) PeerUptime(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*NumberResponse, error) {
	out := new(NumberResponse)
	err := c.cc.Invoke(ctx, "/concordium.P2P/PeerUptime", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *p2PClient) PeerTotalSent(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*NumberResponse, error) {
	out := new(NumberResponse)
	err := c.cc.Invoke(ctx, "/concordium.P2P/PeerTotalSent", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *p2PClient) PeerTotalReceived(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*NumberResponse, error) {
	out := new(NumberResponse)
	err := c.cc.Invoke(ctx, "/concordium.P2P/PeerTotalReceived", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *p2PClient) PeerVersion(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*StringResponse, error) {
	out := new(StringResponse)
	err := c.cc.Invoke(ctx, "/concordium.P2P/PeerVersion", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *p2PClient) PeerStats(ctx context.Context, in *PeersRequest, opts ...grpc.CallOption) (*PeerStatsResponse, error) {
	out := new(PeerStatsResponse)
	err := c.cc.Invoke(ctx, "/concordium.P2P/PeerStats", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *p2PClient) PeerList(ctx context.Context, in *PeersRequest, opts ...grpc.CallOption) (*PeerListResponse, error) {
	out := new(PeerListResponse)
	err := c.cc.Invoke(ctx, "/concordium.P2P/PeerList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *p2PClient) BanNode(ctx context.Context, in *PeerElement, opts ...grpc.CallOption) (*BoolResponse, error) {
	out := new(BoolResponse)
	err := c.cc.Invoke(ctx, "/concordium.P2P/BanNode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *p2PClient) UnbanNode(ctx context.Context, in *PeerElement, opts ...grpc.CallOption) (*BoolResponse, error) {
	out := new(BoolResponse)
	err := c.cc.Invoke(ctx, "/concordium.P2P/UnbanNode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *p2PClient) JoinNetwork(ctx context.Context, in *NetworkChangeRequest, opts ...grpc.CallOption) (*BoolResponse, error) {
	out := new(BoolResponse)
	err := c.cc.Invoke(ctx, "/concordium.P2P/JoinNetwork", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *p2PClient) LeaveNetwork(ctx context.Context, in *NetworkChangeRequest, opts ...grpc.CallOption) (*BoolResponse, error) {
	out := new(BoolResponse)
	err := c.cc.Invoke(ctx, "/concordium.P2P/LeaveNetwork", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *p2PClient) NodeInfo(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*NodeInfoResponse, error) {
	out := new(NodeInfoResponse)
	err := c.cc.Invoke(ctx, "/concordium.P2P/NodeInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *p2PClient) GetConsensusStatus(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*JsonResponse, error) {
	out := new(JsonResponse)
	err := c.cc.Invoke(ctx, "/concordium.P2P/GetConsensusStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *p2PClient) GetBlockInfo(ctx context.Context, in *BlockHash, opts ...grpc.CallOption) (*JsonResponse, error) {
	out := new(JsonResponse)
	err := c.cc.Invoke(ctx, "/concordium.P2P/GetBlockInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *p2PClient) GetAncestors(ctx context.Context, in *BlockHashAndAmount, opts ...grpc.CallOption) (*JsonResponse, error) {
	out := new(JsonResponse)
	err := c.cc.Invoke(ctx, "/concordium.P2P/GetAncestors", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *p2PClient) GetBranches(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*JsonResponse, error) {
	out := new(JsonResponse)
	err := c.cc.Invoke(ctx, "/concordium.P2P/GetBranches", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *p2PClient) GetBlocksAtHeight(ctx context.Context, in *BlockHeight, opts ...grpc.CallOption) (*JsonResponse, error) {
	out := new(JsonResponse)
	err := c.cc.Invoke(ctx, "/concordium.P2P/GetBlocksAtHeight", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *p2PClient) SendTransaction(ctx context.Context, in *SendTransactionRequest, opts ...grpc.CallOption) (*BoolResponse, error) {
	out := new(BoolResponse)
	err := c.cc.Invoke(ctx, "/concordium.P2P/SendTransaction", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *p2PClient) StartBaker(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*BoolResponse, error) {
	out := new(BoolResponse)
	err := c.cc.Invoke(ctx, "/concordium.P2P/StartBaker", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *p2PClient) StopBaker(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*BoolResponse, error) {
	out := new(BoolResponse)
	err := c.cc.Invoke(ctx, "/concordium.P2P/StopBaker", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *p2PClient) GetAccountList(ctx context.Context, in *BlockHash, opts ...grpc.CallOption) (*JsonResponse, error) {
	out := new(JsonResponse)
	err := c.cc.Invoke(ctx, "/concordium.P2P/GetAccountList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *p2PClient) GetInstances(ctx context.Context, in *BlockHash, opts ...grpc.CallOption) (*JsonResponse, error) {
	out := new(JsonResponse)
	err := c.cc.Invoke(ctx, "/concordium.P2P/GetInstances", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *p2PClient) GetAccountInfo(ctx context.Context, in *GetAddressInfoRequest, opts ...grpc.CallOption) (*JsonResponse, error) {
	out := new(JsonResponse)
	err := c.cc.Invoke(ctx, "/concordium.P2P/GetAccountInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *p2PClient) GetInstanceInfo(ctx context.Context, in *GetAddressInfoRequest, opts ...grpc.CallOption) (*JsonResponse, error) {
	out := new(JsonResponse)
	err := c.cc.Invoke(ctx, "/concordium.P2P/GetInstanceInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *p2PClient) InvokeContract(ctx context.Context, in *InvokeContractRequest, opts ...grpc.CallOption) (*JsonResponse, error) {
	out := new(JsonResponse)
	err := c.cc.Invoke(ctx, "/concordium.P2P/InvokeContract", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *p2PClient) GetRewardStatus(ctx context.Context, in *BlockHash, opts ...grpc.CallOption) (*JsonResponse, error) {
	out := new(JsonResponse)
	err := c.cc.Invoke(ctx, "/concordium.P2P/GetRewardStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *p2PClient) GetBirkParameters(ctx context.Context, in *BlockHash, opts ...grpc.CallOption) (*JsonResponse, error) {
	out := new(JsonResponse)
	err := c.cc.Invoke(ctx, "/concordium.P2P/GetBirkParameters", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *p2PClient) GetModuleList(ctx context.Context, in *BlockHash, opts ...grpc.CallOption) (*JsonResponse, error) {
	out := new(JsonResponse)
	err := c.cc.Invoke(ctx, "/concordium.P2P/GetModuleList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *p2PClient) GetModuleSource(ctx context.Context, in *GetModuleSourceRequest, opts ...grpc.CallOption) (*BytesResponse, error) {
	out := new(BytesResponse)
	err := c.cc.Invoke(ctx, "/concordium.P2P/GetModuleSource", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *p2PClient) GetIdentityProviders(ctx context.Context, in *BlockHash, opts ...grpc.CallOption) (*JsonResponse, error) {
	out := new(JsonResponse)
	err := c.cc.Invoke(ctx, "/concordium.P2P/GetIdentityProviders", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *p2PClient) GetAnonymityRevokers(ctx context.Context, in *BlockHash, opts ...grpc.CallOption) (*JsonResponse, error) {
	out := new(JsonResponse)
	err := c.cc.Invoke(ctx, "/concordium.P2P/GetAnonymityRevokers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *p2PClient) GetCryptographicParameters(ctx context.Context, in *BlockHash, opts ...grpc.CallOption) (*JsonResponse, error) {
	out := new(JsonResponse)
	err := c.cc.Invoke(ctx, "/concordium.P2P/GetCryptographicParameters", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *p2PClient) GetBakerList(ctx context.Context, in *BlockHash, opts ...grpc.CallOption) (*JsonResponse, error) {
	out := new(JsonResponse)
	err := c.cc.Invoke(ctx, "/concordium.P2P/GetBakerList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *p2PClient) GetPoolStatus(ctx context.Context, in *GetPoolStatusRequest, opts ...grpc.CallOption) (*JsonResponse, error) {
	out := new(JsonResponse)
	err := c.cc.Invoke(ctx, "/concordium.P2P/GetPoolStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *p2PClient) GetBannedPeers(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*PeerListResponse, error) {
	out := new(PeerListResponse)
	err := c.cc.Invoke(ctx, "/concordium.P2P/GetBannedPeers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *p2PClient) Shutdown(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*BoolResponse, error) {
	out := new(BoolResponse)
	err := c.cc.Invoke(ctx, "/concordium.P2P/Shutdown", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *p2PClient) DumpStart(ctx context.Context, in *DumpRequest, opts ...grpc.CallOption) (*BoolResponse, error) {
	out := new(BoolResponse)
	err := c.cc.Invoke(ctx, "/concordium.P2P/DumpStart", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *p2PClient) DumpStop(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*BoolResponse, error) {
	out := new(BoolResponse)
	err := c.cc.Invoke(ctx, "/concordium.P2P/DumpStop", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *p2PClient) GetTransactionStatus(ctx context.Context, in *TransactionHash, opts ...grpc.CallOption) (*JsonResponse, error) {
	out := new(JsonResponse)
	err := c.cc.Invoke(ctx, "/concordium.P2P/GetTransactionStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *p2PClient) GetTransactionStatusInBlock(ctx context.Context, in *GetTransactionStatusInBlockRequest, opts ...grpc.CallOption) (*JsonResponse, error) {
	out := new(JsonResponse)
	err := c.cc.Invoke(ctx, "/concordium.P2P/GetTransactionStatusInBlock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *p2PClient) GetAccountNonFinalizedTransactions(ctx context.Context, in *AccountAddress, opts ...grpc.CallOption) (*JsonResponse, error) {
	out := new(JsonResponse)
	err := c.cc.Invoke(ctx, "/concordium.P2P/GetAccountNonFinalizedTransactions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *p2PClient) GetBlockSummary(ctx context.Context, in *BlockHash, opts ...grpc.CallOption) (*JsonResponse, error) {
	out := new(JsonResponse)
	err := c.cc.Invoke(ctx, "/concordium.P2P/GetBlockSummary", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *p2PClient) GetNextAccountNonce(ctx context.Context, in *AccountAddress, opts ...grpc.CallOption) (*JsonResponse, error) {
	out := new(JsonResponse)
	err := c.cc.Invoke(ctx, "/concordium.P2P/GetNextAccountNonce", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// P2PServer is the server API for P2P service.
// All implementations must embed UnimplementedP2PServer
// for forward compatibility
type P2PServer interface {
	// Suggest to a peer to connect to the submitted peer details.
	// This, if successful, adds the peer to the list of given addresses.
	PeerConnect(context.Context, *PeerConnectRequest) (*BoolResponse, error)
	// Disconnect from the peer and remove them from the given addresses list
	// if they are on it. Return if the request was processed successfully.
	PeerDisconnect(context.Context, *PeerConnectRequest) (*BoolResponse, error)
	// Uptime of the *node* in milliseconds.
	PeerUptime(context.Context, *Empty) (*NumberResponse, error)
	// Total number of sent packets by the node.
	PeerTotalSent(context.Context, *Empty) (*NumberResponse, error)
	// Total number of received packets by the node.
	PeerTotalReceived(context.Context, *Empty) (*NumberResponse, error)
	// Node software version.
	PeerVersion(context.Context, *Empty) (*StringResponse, error)
	// Stats for connected peers.
	PeerStats(context.Context, *PeersRequest) (*PeerStatsResponse, error)
	// List of connected peers.
	PeerList(context.Context, *PeersRequest) (*PeerListResponse, error)
	// Ban a the given peer.
	BanNode(context.Context, *PeerElement) (*BoolResponse, error)
	// Unban the given peer.
	UnbanNode(context.Context, *PeerElement) (*BoolResponse, error)
	// Join the provided network.
	JoinNetwork(context.Context, *NetworkChangeRequest) (*BoolResponse, error)
	// Leave the provided network.
	LeaveNetwork(context.Context, *NetworkChangeRequest) (*BoolResponse, error)
	// Get information about the running node.
	NodeInfo(context.Context, *Empty) (*NodeInfoResponse, error)
	// Get information about the consensus.
	// A JSON schema for the return type is provided at: https://developer.concordium.software/en/mainnet/net/references/grpc.html.
	GetConsensusStatus(context.Context, *Empty) (*JsonResponse, error)
	// Get information about the block.
	// A JSON schema for the return type is provided at: https://developer.concordium.software/en/mainnet/net/references/grpc.html.
	GetBlockInfo(context.Context, *BlockHash) (*JsonResponse, error)
	// Get ancestors for the provided block.
	// A JSON schema for the return type is provided at: https://developer.concordium.software/en/mainnet/net/references/grpc.html.
	GetAncestors(context.Context, *BlockHashAndAmount) (*JsonResponse, error)
	// Get the current branches.
	// A JSON schema for the return type is provided at: https://developer.concordium.software/en/mainnet/net/references/grpc.html.
	GetBranches(context.Context, *Empty) (*JsonResponse, error)
	// Get the blocks at the given height.
	// A JSON schema for the return type is provided at: https://developer.concordium.software/en/mainnet/net/references/grpc.html.
	GetBlocksAtHeight(context.Context, *BlockHeight) (*JsonResponse, error)
	// Submit a transaction.
	SendTransaction(context.Context, *SendTransactionRequest) (*BoolResponse, error)
	// Start the baker in the consensus module.
	StartBaker(context.Context, *Empty) (*BoolResponse, error)
	// Stop the baker in the consensus module.
	StopBaker(context.Context, *Empty) (*BoolResponse, error)
	// Get a list of accounts that exist in the state after the given block.
	// A JSON schema for the return type is provided at: https://developer.concordium.software/en/mainnet/net/references/grpc.html.
	GetAccountList(context.Context, *BlockHash) (*JsonResponse, error)
	// Get all smart contract instances that exist in the state after the given block.
	// A JSON schema for the return type is provided at: https://developer.concordium.software/en/mainnet/net/references/grpc.html.
	GetInstances(context.Context, *BlockHash) (*JsonResponse, error)
	// Get information about an account.
	// A JSON schema for the return type is provided at: https://developer.concordium.software/en/mainnet/net/references/grpc.html.
	GetAccountInfo(context.Context, *GetAddressInfoRequest) (*JsonResponse, error)
	// Get information about a smart contract instance.
	// A JSON schema for the return type is provided at: https://developer.concordium.software/en/mainnet/net/references/grpc.html.
	GetInstanceInfo(context.Context, *GetAddressInfoRequest) (*JsonResponse, error)
	// Invoke a smart contract instance and view the result *as if* it had been updated at the end of the provided block.
	// This is *not* a transaction.
	// A JSON schema for the return type is provided at: https://developer.concordium.software/en/mainnet/net/references/grpc.html.
	InvokeContract(context.Context, *InvokeContractRequest) (*JsonResponse, error)
	// Get an overview of the balance of special accounts in the given block.
	// A JSON schema for the return type is provided at: https://developer.concordium.software/en/mainnet/net/references/grpc.html.
	GetRewardStatus(context.Context, *BlockHash) (*JsonResponse, error)
	// Get an overview of the parameters used for baking.
	// A JSON schema for the return type is provided at: https://developer.concordium.software/en/mainnet/net/references/grpc.html.
	GetBirkParameters(context.Context, *BlockHash) (*JsonResponse, error)
	// Get a list of smart contract modules that exist in the state after the given block.
	// A JSON schema for the return type is provided at: https://developer.concordium.software/en/mainnet/net/references/grpc.html.
	GetModuleList(context.Context, *BlockHash) (*JsonResponse, error)
	// Get the source of a smart contract module.
	GetModuleSource(context.Context, *GetModuleSourceRequest) (*BytesResponse, error)
	// Get a list of all identity providers that exist in the state after the given block.
	// A JSON schema for the return type is provided at: https://developer.concordium.software/en/mainnet/net/references/grpc.html.
	GetIdentityProviders(context.Context, *BlockHash) (*JsonResponse, error)
	// Get a list of all anonymity revokers that exist in the state after the given block.
	// A JSON schema for the return type is provided at: https://developer.concordium.software/en/mainnet/net/references/grpc.html.
	GetAnonymityRevokers(context.Context, *BlockHash) (*JsonResponse, error)
	// Get the cryptographic parameters used in the given block.
	// A JSON schema for the return type is provided at: https://developer.concordium.software/en/mainnet/net/references/grpc.html.
	GetCryptographicParameters(context.Context, *BlockHash) (*JsonResponse, error)
	// Get a list of all baker IDs registered at that block in ascending order. Or null, if the block is invalid.
	// A JSON schema for the return type is provided at: https://developer.concordium.software/en/mainnet/net/references/grpc.html.
	GetBakerList(context.Context, *BlockHash) (*JsonResponse, error)
	// Get the status of a pool. If passiveDelegation == true, this returns the status for the passive delegators.
	// Otherwise, it returns the status for the baker with the specified ID (if it exists).
	// A JSON schema for the return type is provided at: https://developer.concordium.software/en/mainnet/net/references/grpc.html.
	GetPoolStatus(context.Context, *GetPoolStatusRequest) (*JsonResponse, error)
	// Get a list of banned peers.
	GetBannedPeers(context.Context, *Empty) (*PeerListResponse, error)
	// Shut down the node.
	Shutdown(context.Context, *Empty) (*BoolResponse, error)
	// Start dumping packages into the specified file.
	// Only enabled if the node was built with the `network_dump` feature.
	DumpStart(context.Context, *DumpRequest) (*BoolResponse, error)
	// Stop dumping packages.
	// Only enabled if the node was built with the `network_dump` feature.
	DumpStop(context.Context, *Empty) (*BoolResponse, error)
	// Query for the status of a transaction by its hash.
	// A JSON schema for the return type is provided at: https://developer.concordium.software/en/mainnet/net/references/grpc.html.
	GetTransactionStatus(context.Context, *TransactionHash) (*JsonResponse, error)
	// Query for transactions in a block by its hash.
	// A JSON schema for the return type is provided at: https://developer.concordium.software/en/mainnet/net/references/grpc.html.
	GetTransactionStatusInBlock(context.Context, *GetTransactionStatusInBlockRequest) (*JsonResponse, error)
	// Query for non-finalized transactions present on an account by the account address.
	// A JSON schema for the return type is provided at: https://developer.concordium.software/en/mainnet/net/references/grpc.html.
	GetAccountNonFinalizedTransactions(context.Context, *AccountAddress) (*JsonResponse, error)
	// Request a summary for a block by its hash.
	// A JSON schema for the return type is provided at: https://developer.concordium.software/en/mainnet/net/references/grpc.html.
	GetBlockSummary(context.Context, *BlockHash) (*JsonResponse, error)
	// Request next nonce information for an account.
	// A JSON schema for the return type is provided at: https://developer.concordium.software/en/mainnet/net/references/grpc.html.
	GetNextAccountNonce(context.Context, *AccountAddress) (*JsonResponse, error)
	mustEmbedUnimplementedP2PServer()
}

// UnimplementedP2PServer must be embedded to have forward compatible implementations.
type UnimplementedP2PServer struct {
}

func (UnimplementedP2PServer) PeerConnect(context.Context, *PeerConnectRequest) (*BoolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PeerConnect not implemented")
}
func (UnimplementedP2PServer) PeerDisconnect(context.Context, *PeerConnectRequest) (*BoolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PeerDisconnect not implemented")
}
func (UnimplementedP2PServer) PeerUptime(context.Context, *Empty) (*NumberResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PeerUptime not implemented")
}
func (UnimplementedP2PServer) PeerTotalSent(context.Context, *Empty) (*NumberResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PeerTotalSent not implemented")
}
func (UnimplementedP2PServer) PeerTotalReceived(context.Context, *Empty) (*NumberResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PeerTotalReceived not implemented")
}
func (UnimplementedP2PServer) PeerVersion(context.Context, *Empty) (*StringResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PeerVersion not implemented")
}
func (UnimplementedP2PServer) PeerStats(context.Context, *PeersRequest) (*PeerStatsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PeerStats not implemented")
}
func (UnimplementedP2PServer) PeerList(context.Context, *PeersRequest) (*PeerListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PeerList not implemented")
}
func (UnimplementedP2PServer) BanNode(context.Context, *PeerElement) (*BoolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BanNode not implemented")
}
func (UnimplementedP2PServer) UnbanNode(context.Context, *PeerElement) (*BoolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnbanNode not implemented")
}
func (UnimplementedP2PServer) JoinNetwork(context.Context, *NetworkChangeRequest) (*BoolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method JoinNetwork not implemented")
}
func (UnimplementedP2PServer) LeaveNetwork(context.Context, *NetworkChangeRequest) (*BoolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LeaveNetwork not implemented")
}
func (UnimplementedP2PServer) NodeInfo(context.Context, *Empty) (*NodeInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NodeInfo not implemented")
}
func (UnimplementedP2PServer) GetConsensusStatus(context.Context, *Empty) (*JsonResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetConsensusStatus not implemented")
}
func (UnimplementedP2PServer) GetBlockInfo(context.Context, *BlockHash) (*JsonResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBlockInfo not implemented")
}
func (UnimplementedP2PServer) GetAncestors(context.Context, *BlockHashAndAmount) (*JsonResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAncestors not implemented")
}
func (UnimplementedP2PServer) GetBranches(context.Context, *Empty) (*JsonResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBranches not implemented")
}
func (UnimplementedP2PServer) GetBlocksAtHeight(context.Context, *BlockHeight) (*JsonResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBlocksAtHeight not implemented")
}
func (UnimplementedP2PServer) SendTransaction(context.Context, *SendTransactionRequest) (*BoolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendTransaction not implemented")
}
func (UnimplementedP2PServer) StartBaker(context.Context, *Empty) (*BoolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartBaker not implemented")
}
func (UnimplementedP2PServer) StopBaker(context.Context, *Empty) (*BoolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopBaker not implemented")
}
func (UnimplementedP2PServer) GetAccountList(context.Context, *BlockHash) (*JsonResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAccountList not implemented")
}
func (UnimplementedP2PServer) GetInstances(context.Context, *BlockHash) (*JsonResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetInstances not implemented")
}
func (UnimplementedP2PServer) GetAccountInfo(context.Context, *GetAddressInfoRequest) (*JsonResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAccountInfo not implemented")
}
func (UnimplementedP2PServer) GetInstanceInfo(context.Context, *GetAddressInfoRequest) (*JsonResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetInstanceInfo not implemented")
}
func (UnimplementedP2PServer) InvokeContract(context.Context, *InvokeContractRequest) (*JsonResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InvokeContract not implemented")
}
func (UnimplementedP2PServer) GetRewardStatus(context.Context, *BlockHash) (*JsonResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRewardStatus not implemented")
}
func (UnimplementedP2PServer) GetBirkParameters(context.Context, *BlockHash) (*JsonResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBirkParameters not implemented")
}
func (UnimplementedP2PServer) GetModuleList(context.Context, *BlockHash) (*JsonResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetModuleList not implemented")
}
func (UnimplementedP2PServer) GetModuleSource(context.Context, *GetModuleSourceRequest) (*BytesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetModuleSource not implemented")
}
func (UnimplementedP2PServer) GetIdentityProviders(context.Context, *BlockHash) (*JsonResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetIdentityProviders not implemented")
}
func (UnimplementedP2PServer) GetAnonymityRevokers(context.Context, *BlockHash) (*JsonResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAnonymityRevokers not implemented")
}
func (UnimplementedP2PServer) GetCryptographicParameters(context.Context, *BlockHash) (*JsonResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCryptographicParameters not implemented")
}
func (UnimplementedP2PServer) GetBakerList(context.Context, *BlockHash) (*JsonResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBakerList not implemented")
}
func (UnimplementedP2PServer) GetPoolStatus(context.Context, *GetPoolStatusRequest) (*JsonResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPoolStatus not implemented")
}
func (UnimplementedP2PServer) GetBannedPeers(context.Context, *Empty) (*PeerListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBannedPeers not implemented")
}
func (UnimplementedP2PServer) Shutdown(context.Context, *Empty) (*BoolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Shutdown not implemented")
}
func (UnimplementedP2PServer) DumpStart(context.Context, *DumpRequest) (*BoolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DumpStart not implemented")
}
func (UnimplementedP2PServer) DumpStop(context.Context, *Empty) (*BoolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DumpStop not implemented")
}
func (UnimplementedP2PServer) GetTransactionStatus(context.Context, *TransactionHash) (*JsonResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTransactionStatus not implemented")
}
func (UnimplementedP2PServer) GetTransactionStatusInBlock(context.Context, *GetTransactionStatusInBlockRequest) (*JsonResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTransactionStatusInBlock not implemented")
}
func (UnimplementedP2PServer) GetAccountNonFinalizedTransactions(context.Context, *AccountAddress) (*JsonResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAccountNonFinalizedTransactions not implemented")
}
func (UnimplementedP2PServer) GetBlockSummary(context.Context, *BlockHash) (*JsonResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBlockSummary not implemented")
}
func (UnimplementedP2PServer) GetNextAccountNonce(context.Context, *AccountAddress) (*JsonResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNextAccountNonce not implemented")
}
func (UnimplementedP2PServer) mustEmbedUnimplementedP2PServer() {}

// UnsafeP2PServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to P2PServer will
// result in compilation errors.
type UnsafeP2PServer interface {
	mustEmbedUnimplementedP2PServer()
}

func RegisterP2PServer(s grpc.ServiceRegistrar, srv P2PServer) {
	s.RegisterService(&P2P_ServiceDesc, srv)
}

func _P2P_PeerConnect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PeerConnectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(P2PServer).PeerConnect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.P2P/PeerConnect",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(P2PServer).PeerConnect(ctx, req.(*PeerConnectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _P2P_PeerDisconnect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PeerConnectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(P2PServer).PeerDisconnect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.P2P/PeerDisconnect",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(P2PServer).PeerDisconnect(ctx, req.(*PeerConnectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _P2P_PeerUptime_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(P2PServer).PeerUptime(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.P2P/PeerUptime",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(P2PServer).PeerUptime(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _P2P_PeerTotalSent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(P2PServer).PeerTotalSent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.P2P/PeerTotalSent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(P2PServer).PeerTotalSent(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _P2P_PeerTotalReceived_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(P2PServer).PeerTotalReceived(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.P2P/PeerTotalReceived",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(P2PServer).PeerTotalReceived(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _P2P_PeerVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(P2PServer).PeerVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.P2P/PeerVersion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(P2PServer).PeerVersion(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _P2P_PeerStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PeersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(P2PServer).PeerStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.P2P/PeerStats",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(P2PServer).PeerStats(ctx, req.(*PeersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _P2P_PeerList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PeersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(P2PServer).PeerList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.P2P/PeerList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(P2PServer).PeerList(ctx, req.(*PeersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _P2P_BanNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PeerElement)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(P2PServer).BanNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.P2P/BanNode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(P2PServer).BanNode(ctx, req.(*PeerElement))
	}
	return interceptor(ctx, in, info, handler)
}

func _P2P_UnbanNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PeerElement)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(P2PServer).UnbanNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.P2P/UnbanNode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(P2PServer).UnbanNode(ctx, req.(*PeerElement))
	}
	return interceptor(ctx, in, info, handler)
}

func _P2P_JoinNetwork_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NetworkChangeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(P2PServer).JoinNetwork(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.P2P/JoinNetwork",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(P2PServer).JoinNetwork(ctx, req.(*NetworkChangeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _P2P_LeaveNetwork_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NetworkChangeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(P2PServer).LeaveNetwork(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.P2P/LeaveNetwork",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(P2PServer).LeaveNetwork(ctx, req.(*NetworkChangeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _P2P_NodeInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(P2PServer).NodeInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.P2P/NodeInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(P2PServer).NodeInfo(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _P2P_GetConsensusStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(P2PServer).GetConsensusStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.P2P/GetConsensusStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(P2PServer).GetConsensusStatus(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _P2P_GetBlockInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlockHash)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(P2PServer).GetBlockInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.P2P/GetBlockInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(P2PServer).GetBlockInfo(ctx, req.(*BlockHash))
	}
	return interceptor(ctx, in, info, handler)
}

func _P2P_GetAncestors_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlockHashAndAmount)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(P2PServer).GetAncestors(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.P2P/GetAncestors",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(P2PServer).GetAncestors(ctx, req.(*BlockHashAndAmount))
	}
	return interceptor(ctx, in, info, handler)
}

func _P2P_GetBranches_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(P2PServer).GetBranches(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.P2P/GetBranches",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(P2PServer).GetBranches(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _P2P_GetBlocksAtHeight_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlockHeight)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(P2PServer).GetBlocksAtHeight(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.P2P/GetBlocksAtHeight",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(P2PServer).GetBlocksAtHeight(ctx, req.(*BlockHeight))
	}
	return interceptor(ctx, in, info, handler)
}

func _P2P_SendTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendTransactionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(P2PServer).SendTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.P2P/SendTransaction",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(P2PServer).SendTransaction(ctx, req.(*SendTransactionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _P2P_StartBaker_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(P2PServer).StartBaker(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.P2P/StartBaker",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(P2PServer).StartBaker(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _P2P_StopBaker_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(P2PServer).StopBaker(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.P2P/StopBaker",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(P2PServer).StopBaker(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _P2P_GetAccountList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlockHash)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(P2PServer).GetAccountList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.P2P/GetAccountList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(P2PServer).GetAccountList(ctx, req.(*BlockHash))
	}
	return interceptor(ctx, in, info, handler)
}

func _P2P_GetInstances_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlockHash)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(P2PServer).GetInstances(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.P2P/GetInstances",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(P2PServer).GetInstances(ctx, req.(*BlockHash))
	}
	return interceptor(ctx, in, info, handler)
}

func _P2P_GetAccountInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAddressInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(P2PServer).GetAccountInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.P2P/GetAccountInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(P2PServer).GetAccountInfo(ctx, req.(*GetAddressInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _P2P_GetInstanceInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAddressInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(P2PServer).GetInstanceInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.P2P/GetInstanceInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(P2PServer).GetInstanceInfo(ctx, req.(*GetAddressInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _P2P_InvokeContract_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InvokeContractRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(P2PServer).InvokeContract(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.P2P/InvokeContract",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(P2PServer).InvokeContract(ctx, req.(*InvokeContractRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _P2P_GetRewardStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlockHash)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(P2PServer).GetRewardStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.P2P/GetRewardStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(P2PServer).GetRewardStatus(ctx, req.(*BlockHash))
	}
	return interceptor(ctx, in, info, handler)
}

func _P2P_GetBirkParameters_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlockHash)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(P2PServer).GetBirkParameters(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.P2P/GetBirkParameters",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(P2PServer).GetBirkParameters(ctx, req.(*BlockHash))
	}
	return interceptor(ctx, in, info, handler)
}

func _P2P_GetModuleList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlockHash)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(P2PServer).GetModuleList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.P2P/GetModuleList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(P2PServer).GetModuleList(ctx, req.(*BlockHash))
	}
	return interceptor(ctx, in, info, handler)
}

func _P2P_GetModuleSource_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetModuleSourceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(P2PServer).GetModuleSource(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.P2P/GetModuleSource",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(P2PServer).GetModuleSource(ctx, req.(*GetModuleSourceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _P2P_GetIdentityProviders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlockHash)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(P2PServer).GetIdentityProviders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.P2P/GetIdentityProviders",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(P2PServer).GetIdentityProviders(ctx, req.(*BlockHash))
	}
	return interceptor(ctx, in, info, handler)
}

func _P2P_GetAnonymityRevokers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlockHash)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(P2PServer).GetAnonymityRevokers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.P2P/GetAnonymityRevokers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(P2PServer).GetAnonymityRevokers(ctx, req.(*BlockHash))
	}
	return interceptor(ctx, in, info, handler)
}

func _P2P_GetCryptographicParameters_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlockHash)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(P2PServer).GetCryptographicParameters(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.P2P/GetCryptographicParameters",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(P2PServer).GetCryptographicParameters(ctx, req.(*BlockHash))
	}
	return interceptor(ctx, in, info, handler)
}

func _P2P_GetBakerList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlockHash)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(P2PServer).GetBakerList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.P2P/GetBakerList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(P2PServer).GetBakerList(ctx, req.(*BlockHash))
	}
	return interceptor(ctx, in, info, handler)
}

func _P2P_GetPoolStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPoolStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(P2PServer).GetPoolStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.P2P/GetPoolStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(P2PServer).GetPoolStatus(ctx, req.(*GetPoolStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _P2P_GetBannedPeers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(P2PServer).GetBannedPeers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.P2P/GetBannedPeers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(P2PServer).GetBannedPeers(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _P2P_Shutdown_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(P2PServer).Shutdown(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.P2P/Shutdown",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(P2PServer).Shutdown(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _P2P_DumpStart_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DumpRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(P2PServer).DumpStart(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.P2P/DumpStart",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(P2PServer).DumpStart(ctx, req.(*DumpRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _P2P_DumpStop_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(P2PServer).DumpStop(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.P2P/DumpStop",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(P2PServer).DumpStop(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _P2P_GetTransactionStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TransactionHash)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(P2PServer).GetTransactionStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.P2P/GetTransactionStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(P2PServer).GetTransactionStatus(ctx, req.(*TransactionHash))
	}
	return interceptor(ctx, in, info, handler)
}

func _P2P_GetTransactionStatusInBlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTransactionStatusInBlockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(P2PServer).GetTransactionStatusInBlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.P2P/GetTransactionStatusInBlock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(P2PServer).GetTransactionStatusInBlock(ctx, req.(*GetTransactionStatusInBlockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _P2P_GetAccountNonFinalizedTransactions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccountAddress)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(P2PServer).GetAccountNonFinalizedTransactions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.P2P/GetAccountNonFinalizedTransactions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(P2PServer).GetAccountNonFinalizedTransactions(ctx, req.(*AccountAddress))
	}
	return interceptor(ctx, in, info, handler)
}

func _P2P_GetBlockSummary_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlockHash)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(P2PServer).GetBlockSummary(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.P2P/GetBlockSummary",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(P2PServer).GetBlockSummary(ctx, req.(*BlockHash))
	}
	return interceptor(ctx, in, info, handler)
}

func _P2P_GetNextAccountNonce_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccountAddress)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(P2PServer).GetNextAccountNonce(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/concordium.P2P/GetNextAccountNonce",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(P2PServer).GetNextAccountNonce(ctx, req.(*AccountAddress))
	}
	return interceptor(ctx, in, info, handler)
}

// P2P_ServiceDesc is the grpc.ServiceDesc for P2P service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var P2P_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "concordium.P2P",
	HandlerType: (*P2PServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "PeerConnect",
			Handler:    _P2P_PeerConnect_Handler,
		},
		{
			MethodName: "PeerDisconnect",
			Handler:    _P2P_PeerDisconnect_Handler,
		},
		{
			MethodName: "PeerUptime",
			Handler:    _P2P_PeerUptime_Handler,
		},
		{
			MethodName: "PeerTotalSent",
			Handler:    _P2P_PeerTotalSent_Handler,
		},
		{
			MethodName: "PeerTotalReceived",
			Handler:    _P2P_PeerTotalReceived_Handler,
		},
		{
			MethodName: "PeerVersion",
			Handler:    _P2P_PeerVersion_Handler,
		},
		{
			MethodName: "PeerStats",
			Handler:    _P2P_PeerStats_Handler,
		},
		{
			MethodName: "PeerList",
			Handler:    _P2P_PeerList_Handler,
		},
		{
			MethodName: "BanNode",
			Handler:    _P2P_BanNode_Handler,
		},
		{
			MethodName: "UnbanNode",
			Handler:    _P2P_UnbanNode_Handler,
		},
		{
			MethodName: "JoinNetwork",
			Handler:    _P2P_JoinNetwork_Handler,
		},
		{
			MethodName: "LeaveNetwork",
			Handler:    _P2P_LeaveNetwork_Handler,
		},
		{
			MethodName: "NodeInfo",
			Handler:    _P2P_NodeInfo_Handler,
		},
		{
			MethodName: "GetConsensusStatus",
			Handler:    _P2P_GetConsensusStatus_Handler,
		},
		{
			MethodName: "GetBlockInfo",
			Handler:    _P2P_GetBlockInfo_Handler,
		},
		{
			MethodName: "GetAncestors",
			Handler:    _P2P_GetAncestors_Handler,
		},
		{
			MethodName: "GetBranches",
			Handler:    _P2P_GetBranches_Handler,
		},
		{
			MethodName: "GetBlocksAtHeight",
			Handler:    _P2P_GetBlocksAtHeight_Handler,
		},
		{
			MethodName: "SendTransaction",
			Handler:    _P2P_SendTransaction_Handler,
		},
		{
			MethodName: "StartBaker",
			Handler:    _P2P_StartBaker_Handler,
		},
		{
			MethodName: "StopBaker",
			Handler:    _P2P_StopBaker_Handler,
		},
		{
			MethodName: "GetAccountList",
			Handler:    _P2P_GetAccountList_Handler,
		},
		{
			MethodName: "GetInstances",
			Handler:    _P2P_GetInstances_Handler,
		},
		{
			MethodName: "GetAccountInfo",
			Handler:    _P2P_GetAccountInfo_Handler,
		},
		{
			MethodName: "GetInstanceInfo",
			Handler:    _P2P_GetInstanceInfo_Handler,
		},
		{
			MethodName: "InvokeContract",
			Handler:    _P2P_InvokeContract_Handler,
		},
		{
			MethodName: "GetRewardStatus",
			Handler:    _P2P_GetRewardStatus_Handler,
		},
		{
			MethodName: "GetBirkParameters",
			Handler:    _P2P_GetBirkParameters_Handler,
		},
		{
			MethodName: "GetModuleList",
			Handler:    _P2P_GetModuleList_Handler,
		},
		{
			MethodName: "GetModuleSource",
			Handler:    _P2P_GetModuleSource_Handler,
		},
		{
			MethodName: "GetIdentityProviders",
			Handler:    _P2P_GetIdentityProviders_Handler,
		},
		{
			MethodName: "GetAnonymityRevokers",
			Handler:    _P2P_GetAnonymityRevokers_Handler,
		},
		{
			MethodName: "GetCryptographicParameters",
			Handler:    _P2P_GetCryptographicParameters_Handler,
		},
		{
			MethodName: "GetBakerList",
			Handler:    _P2P_GetBakerList_Handler,
		},
		{
			MethodName: "GetPoolStatus",
			Handler:    _P2P_GetPoolStatus_Handler,
		},
		{
			MethodName: "GetBannedPeers",
			Handler:    _P2P_GetBannedPeers_Handler,
		},
		{
			MethodName: "Shutdown",
			Handler:    _P2P_Shutdown_Handler,
		},
		{
			MethodName: "DumpStart",
			Handler:    _P2P_DumpStart_Handler,
		},
		{
			MethodName: "DumpStop",
			Handler:    _P2P_DumpStop_Handler,
		},
		{
			MethodName: "GetTransactionStatus",
			Handler:    _P2P_GetTransactionStatus_Handler,
		},
		{
			MethodName: "GetTransactionStatusInBlock",
			Handler:    _P2P_GetTransactionStatusInBlock_Handler,
		},
		{
			MethodName: "GetAccountNonFinalizedTransactions",
			Handler:    _P2P_GetAccountNonFinalizedTransactions_Handler,
		},
		{
			MethodName: "GetBlockSummary",
			Handler:    _P2P_GetBlockSummary_Handler,
		},
		{
			MethodName: "GetNextAccountNonce",
			Handler:    _P2P_GetNextAccountNonce_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "grpc-api/concordium_p2p_rpc.proto",
}
